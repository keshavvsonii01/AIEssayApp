/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/quill";
exports.ids = ["vendor-chunks/quill"];
exports.modules = {

/***/ "(ssr)/./node_modules/quill/dist/quill.js":
/*!******************************************!*\
  !*** ./node_modules/quill/dist/quill.js ***!
  \******************************************/
/***/ (function(module) {

eval("/*!\n * Quill Editor v1.3.7\n * https://quilljs.com/\n * Copyright (c) 2014, Jason Chen\n * Copyright (c) 2013, salesforce.com\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(typeof self !== \"undefined\" ? self : this, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_715__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_715__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_715__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_715__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_715__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_715__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_715__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_715__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_715__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_715__.p = \"\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_715__(__nested_webpack_require_715__.s = 109);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1, __nested_webpack_require_3404__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var container_1 = __nested_webpack_require_3404__(17);\n            var format_1 = __nested_webpack_require_3404__(18);\n            var leaf_1 = __nested_webpack_require_3404__(19);\n            var scroll_1 = __nested_webpack_require_3404__(45);\n            var inline_1 = __nested_webpack_require_3404__(46);\n            var block_1 = __nested_webpack_require_3404__(47);\n            var embed_1 = __nested_webpack_require_3404__(48);\n            var text_1 = __nested_webpack_require_3404__(49);\n            var attributor_1 = __nested_webpack_require_3404__(12);\n            var class_1 = __nested_webpack_require_3404__(32);\n            var style_1 = __nested_webpack_require_3404__(33);\n            var store_1 = __nested_webpack_require_3404__(31);\n            var Registry = __nested_webpack_require_3404__(1);\n            var Parchment = {\n                Scope: Registry.Scope,\n                create: Registry.create,\n                find: Registry.find,\n                query: Registry.query,\n                register: Registry.register,\n                Container: container_1.default,\n                Format: format_1.default,\n                Leaf: leaf_1.default,\n                Embed: embed_1.default,\n                Scroll: scroll_1.default,\n                Block: block_1.default,\n                Inline: inline_1.default,\n                Text: text_1.default,\n                Attributor: {\n                    Attribute: attributor_1.default,\n                    Class: class_1.default,\n                    Style: style_1.default,\n                    Store: store_1.default\n                }\n            };\n            exports1.default = Parchment;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var ParchmentError = /** @class */ function(_super) {\n                __extends(ParchmentError, _super);\n                function ParchmentError(message) {\n                    var _this = this;\n                    message = \"[Parchment] \" + message;\n                    _this = _super.call(this, message) || this;\n                    _this.message = message;\n                    _this.name = _this.constructor.name;\n                    return _this;\n                }\n                return ParchmentError;\n            }(Error);\n            exports1.ParchmentError = ParchmentError;\n            var attributes = {};\n            var classes = {};\n            var tags = {};\n            var types = {};\n            exports1.DATA_KEY = \"__blot\";\n            var Scope;\n            (function(Scope) {\n                Scope[Scope[\"TYPE\"] = 3] = \"TYPE\";\n                Scope[Scope[\"LEVEL\"] = 12] = \"LEVEL\";\n                Scope[Scope[\"ATTRIBUTE\"] = 13] = \"ATTRIBUTE\";\n                Scope[Scope[\"BLOT\"] = 14] = \"BLOT\";\n                Scope[Scope[\"INLINE\"] = 7] = \"INLINE\";\n                Scope[Scope[\"BLOCK\"] = 11] = \"BLOCK\";\n                Scope[Scope[\"BLOCK_BLOT\"] = 10] = \"BLOCK_BLOT\";\n                Scope[Scope[\"INLINE_BLOT\"] = 6] = \"INLINE_BLOT\";\n                Scope[Scope[\"BLOCK_ATTRIBUTE\"] = 9] = \"BLOCK_ATTRIBUTE\";\n                Scope[Scope[\"INLINE_ATTRIBUTE\"] = 5] = \"INLINE_ATTRIBUTE\";\n                Scope[Scope[\"ANY\"] = 15] = \"ANY\";\n            })(Scope = exports1.Scope || (exports1.Scope = {}));\n            function create(input, value) {\n                var match = query(input);\n                if (match == null) {\n                    throw new ParchmentError(\"Unable to create \" + input + \" blot\");\n                }\n                var BlotClass = match;\n                var node = // @ts-ignore\n                input instanceof Node || input[\"nodeType\"] === Node.TEXT_NODE ? input : BlotClass.create(value);\n                return new BlotClass(node, value);\n            }\n            exports1.create = create;\n            function find(node, bubble) {\n                if (bubble === void 0) {\n                    bubble = false;\n                }\n                if (node == null) return null;\n                // @ts-ignore\n                if (node[exports1.DATA_KEY] != null) return node[exports1.DATA_KEY].blot;\n                if (bubble) return find(node.parentNode, bubble);\n                return null;\n            }\n            exports1.find = find;\n            function query(query, scope) {\n                if (scope === void 0) {\n                    scope = Scope.ANY;\n                }\n                var match;\n                if (typeof query === \"string\") {\n                    match = types[query] || attributes[query];\n                // @ts-ignore\n                } else if (query instanceof Text || query[\"nodeType\"] === Node.TEXT_NODE) {\n                    match = types[\"text\"];\n                } else if (typeof query === \"number\") {\n                    if (query & Scope.LEVEL & Scope.BLOCK) {\n                        match = types[\"block\"];\n                    } else if (query & Scope.LEVEL & Scope.INLINE) {\n                        match = types[\"inline\"];\n                    }\n                } else if (query instanceof HTMLElement) {\n                    var names = (query.getAttribute(\"class\") || \"\").split(/\\s+/);\n                    for(var i in names){\n                        match = classes[names[i]];\n                        if (match) break;\n                    }\n                    match = match || tags[query.tagName];\n                }\n                if (match == null) return null;\n                // @ts-ignore\n                if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope) return match;\n                return null;\n            }\n            exports1.query = query;\n            function register() {\n                var Definitions = [];\n                for(var _i = 0; _i < arguments.length; _i++){\n                    Definitions[_i] = arguments[_i];\n                }\n                if (Definitions.length > 1) {\n                    return Definitions.map(function(d) {\n                        return register(d);\n                    });\n                }\n                var Definition = Definitions[0];\n                if (typeof Definition.blotName !== \"string\" && typeof Definition.attrName !== \"string\") {\n                    throw new ParchmentError(\"Invalid definition\");\n                } else if (Definition.blotName === \"abstract\") {\n                    throw new ParchmentError(\"Cannot register abstract class\");\n                }\n                types[Definition.blotName || Definition.attrName] = Definition;\n                if (typeof Definition.keyName === \"string\") {\n                    attributes[Definition.keyName] = Definition;\n                } else {\n                    if (Definition.className != null) {\n                        classes[Definition.className] = Definition;\n                    }\n                    if (Definition.tagName != null) {\n                        if (Array.isArray(Definition.tagName)) {\n                            Definition.tagName = Definition.tagName.map(function(tagName) {\n                                return tagName.toUpperCase();\n                            });\n                        } else {\n                            Definition.tagName = Definition.tagName.toUpperCase();\n                        }\n                        var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [\n                            Definition.tagName\n                        ];\n                        tagNames.forEach(function(tag) {\n                            if (tags[tag] == null || Definition.className == null) {\n                                tags[tag] = Definition;\n                            }\n                        });\n                    }\n                }\n                return Definition;\n            }\n            exports1.register = register;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __nested_webpack_require_12128__) {\n            var diff = __nested_webpack_require_12128__(51);\n            var equal = __nested_webpack_require_12128__(11);\n            var extend = __nested_webpack_require_12128__(3);\n            var op = __nested_webpack_require_12128__(20);\n            var NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\n            var Delta = function(ops) {\n                // Assume we are given a well formed ops\n                if (Array.isArray(ops)) {\n                    this.ops = ops;\n                } else if (ops != null && Array.isArray(ops.ops)) {\n                    this.ops = ops.ops;\n                } else {\n                    this.ops = [];\n                }\n            };\n            Delta.prototype.insert = function(text, attributes) {\n                var newOp = {};\n                if (text.length === 0) return this;\n                newOp.insert = text;\n                if (attributes != null && typeof attributes === \"object\" && Object.keys(attributes).length > 0) {\n                    newOp.attributes = attributes;\n                }\n                return this.push(newOp);\n            };\n            Delta.prototype[\"delete\"] = function(length) {\n                if (length <= 0) return this;\n                return this.push({\n                    \"delete\": length\n                });\n            };\n            Delta.prototype.retain = function(length, attributes) {\n                if (length <= 0) return this;\n                var newOp = {\n                    retain: length\n                };\n                if (attributes != null && typeof attributes === \"object\" && Object.keys(attributes).length > 0) {\n                    newOp.attributes = attributes;\n                }\n                return this.push(newOp);\n            };\n            Delta.prototype.push = function(newOp) {\n                var index = this.ops.length;\n                var lastOp = this.ops[index - 1];\n                newOp = extend(true, {}, newOp);\n                if (typeof lastOp === \"object\") {\n                    if (typeof newOp[\"delete\"] === \"number\" && typeof lastOp[\"delete\"] === \"number\") {\n                        this.ops[index - 1] = {\n                            \"delete\": lastOp[\"delete\"] + newOp[\"delete\"]\n                        };\n                        return this;\n                    }\n                    // Since it does not matter if we insert before or after deleting at the same index,\n                    // always prefer to insert first\n                    if (typeof lastOp[\"delete\"] === \"number\" && newOp.insert != null) {\n                        index -= 1;\n                        lastOp = this.ops[index - 1];\n                        if (typeof lastOp !== \"object\") {\n                            this.ops.unshift(newOp);\n                            return this;\n                        }\n                    }\n                    if (equal(newOp.attributes, lastOp.attributes)) {\n                        if (typeof newOp.insert === \"string\" && typeof lastOp.insert === \"string\") {\n                            this.ops[index - 1] = {\n                                insert: lastOp.insert + newOp.insert\n                            };\n                            if (typeof newOp.attributes === \"object\") this.ops[index - 1].attributes = newOp.attributes;\n                            return this;\n                        } else if (typeof newOp.retain === \"number\" && typeof lastOp.retain === \"number\") {\n                            this.ops[index - 1] = {\n                                retain: lastOp.retain + newOp.retain\n                            };\n                            if (typeof newOp.attributes === \"object\") this.ops[index - 1].attributes = newOp.attributes;\n                            return this;\n                        }\n                    }\n                }\n                if (index === this.ops.length) {\n                    this.ops.push(newOp);\n                } else {\n                    this.ops.splice(index, 0, newOp);\n                }\n                return this;\n            };\n            Delta.prototype.chop = function() {\n                var lastOp = this.ops[this.ops.length - 1];\n                if (lastOp && lastOp.retain && !lastOp.attributes) {\n                    this.ops.pop();\n                }\n                return this;\n            };\n            Delta.prototype.filter = function(predicate) {\n                return this.ops.filter(predicate);\n            };\n            Delta.prototype.forEach = function(predicate) {\n                this.ops.forEach(predicate);\n            };\n            Delta.prototype.map = function(predicate) {\n                return this.ops.map(predicate);\n            };\n            Delta.prototype.partition = function(predicate) {\n                var passed = [], failed = [];\n                this.forEach(function(op) {\n                    var target = predicate(op) ? passed : failed;\n                    target.push(op);\n                });\n                return [\n                    passed,\n                    failed\n                ];\n            };\n            Delta.prototype.reduce = function(predicate, initial) {\n                return this.ops.reduce(predicate, initial);\n            };\n            Delta.prototype.changeLength = function() {\n                return this.reduce(function(length, elem) {\n                    if (elem.insert) {\n                        return length + op.length(elem);\n                    } else if (elem.delete) {\n                        return length - elem.delete;\n                    }\n                    return length;\n                }, 0);\n            };\n            Delta.prototype.length = function() {\n                return this.reduce(function(length, elem) {\n                    return length + op.length(elem);\n                }, 0);\n            };\n            Delta.prototype.slice = function(start, end) {\n                start = start || 0;\n                if (typeof end !== \"number\") end = Infinity;\n                var ops = [];\n                var iter = op.iterator(this.ops);\n                var index = 0;\n                while(index < end && iter.hasNext()){\n                    var nextOp;\n                    if (index < start) {\n                        nextOp = iter.next(start - index);\n                    } else {\n                        nextOp = iter.next(end - index);\n                        ops.push(nextOp);\n                    }\n                    index += op.length(nextOp);\n                }\n                return new Delta(ops);\n            };\n            Delta.prototype.compose = function(other) {\n                var thisIter = op.iterator(this.ops);\n                var otherIter = op.iterator(other.ops);\n                var ops = [];\n                var firstOther = otherIter.peek();\n                if (firstOther != null && typeof firstOther.retain === \"number\" && firstOther.attributes == null) {\n                    var firstLeft = firstOther.retain;\n                    while(thisIter.peekType() === \"insert\" && thisIter.peekLength() <= firstLeft){\n                        firstLeft -= thisIter.peekLength();\n                        ops.push(thisIter.next());\n                    }\n                    if (firstOther.retain - firstLeft > 0) {\n                        otherIter.next(firstOther.retain - firstLeft);\n                    }\n                }\n                var delta = new Delta(ops);\n                while(thisIter.hasNext() || otherIter.hasNext()){\n                    if (otherIter.peekType() === \"insert\") {\n                        delta.push(otherIter.next());\n                    } else if (thisIter.peekType() === \"delete\") {\n                        delta.push(thisIter.next());\n                    } else {\n                        var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                        var thisOp = thisIter.next(length);\n                        var otherOp = otherIter.next(length);\n                        if (typeof otherOp.retain === \"number\") {\n                            var newOp = {};\n                            if (typeof thisOp.retain === \"number\") {\n                                newOp.retain = length;\n                            } else {\n                                newOp.insert = thisOp.insert;\n                            }\n                            // Preserve null when composing with a retain, otherwise remove it for inserts\n                            var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === \"number\");\n                            if (attributes) newOp.attributes = attributes;\n                            delta.push(newOp);\n                            // Optimization if rest of other is just retain\n                            if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {\n                                var rest = new Delta(thisIter.rest());\n                                return delta.concat(rest).chop();\n                            }\n                        // Other op should be delete, we could be an insert or retain\n                        // Insert + delete cancels out\n                        } else if (typeof otherOp[\"delete\"] === \"number\" && typeof thisOp.retain === \"number\") {\n                            delta.push(otherOp);\n                        }\n                    }\n                }\n                return delta.chop();\n            };\n            Delta.prototype.concat = function(other) {\n                var delta = new Delta(this.ops.slice());\n                if (other.ops.length > 0) {\n                    delta.push(other.ops[0]);\n                    delta.ops = delta.ops.concat(other.ops.slice(1));\n                }\n                return delta;\n            };\n            Delta.prototype.diff = function(other, index) {\n                if (this.ops === other.ops) {\n                    return new Delta();\n                }\n                var strings = [\n                    this,\n                    other\n                ].map(function(delta) {\n                    return delta.map(function(op) {\n                        if (op.insert != null) {\n                            return typeof op.insert === \"string\" ? op.insert : NULL_CHARACTER;\n                        }\n                        var prep = delta === other ? \"on\" : \"with\";\n                        throw new Error(\"diff() called \" + prep + \" non-document\");\n                    }).join(\"\");\n                });\n                var delta = new Delta();\n                var diffResult = diff(strings[0], strings[1], index);\n                var thisIter = op.iterator(this.ops);\n                var otherIter = op.iterator(other.ops);\n                diffResult.forEach(function(component) {\n                    var length = component[1].length;\n                    while(length > 0){\n                        var opLength = 0;\n                        switch(component[0]){\n                            case diff.INSERT:\n                                opLength = Math.min(otherIter.peekLength(), length);\n                                delta.push(otherIter.next(opLength));\n                                break;\n                            case diff.DELETE:\n                                opLength = Math.min(length, thisIter.peekLength());\n                                thisIter.next(opLength);\n                                delta[\"delete\"](opLength);\n                                break;\n                            case diff.EQUAL:\n                                opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n                                var thisOp = thisIter.next(opLength);\n                                var otherOp = otherIter.next(opLength);\n                                if (equal(thisOp.insert, otherOp.insert)) {\n                                    delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));\n                                } else {\n                                    delta.push(otherOp)[\"delete\"](opLength);\n                                }\n                                break;\n                        }\n                        length -= opLength;\n                    }\n                });\n                return delta.chop();\n            };\n            Delta.prototype.eachLine = function(predicate, newline) {\n                newline = newline || \"\\n\";\n                var iter = op.iterator(this.ops);\n                var line = new Delta();\n                var i = 0;\n                while(iter.hasNext()){\n                    if (iter.peekType() !== \"insert\") return;\n                    var thisOp = iter.peek();\n                    var start = op.length(thisOp) - iter.peekLength();\n                    var index = typeof thisOp.insert === \"string\" ? thisOp.insert.indexOf(newline, start) - start : -1;\n                    if (index < 0) {\n                        line.push(iter.next());\n                    } else if (index > 0) {\n                        line.push(iter.next(index));\n                    } else {\n                        if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n                            return;\n                        }\n                        i += 1;\n                        line = new Delta();\n                    }\n                }\n                if (line.length() > 0) {\n                    predicate(line, {}, i);\n                }\n            };\n            Delta.prototype.transform = function(other, priority) {\n                priority = !!priority;\n                if (typeof other === \"number\") {\n                    return this.transformPosition(other, priority);\n                }\n                var thisIter = op.iterator(this.ops);\n                var otherIter = op.iterator(other.ops);\n                var delta = new Delta();\n                while(thisIter.hasNext() || otherIter.hasNext()){\n                    if (thisIter.peekType() === \"insert\" && (priority || otherIter.peekType() !== \"insert\")) {\n                        delta.retain(op.length(thisIter.next()));\n                    } else if (otherIter.peekType() === \"insert\") {\n                        delta.push(otherIter.next());\n                    } else {\n                        var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                        var thisOp = thisIter.next(length);\n                        var otherOp = otherIter.next(length);\n                        if (thisOp[\"delete\"]) {\n                            continue;\n                        } else if (otherOp[\"delete\"]) {\n                            delta.push(otherOp);\n                        } else {\n                            // We retain either their retain or insert\n                            delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));\n                        }\n                    }\n                }\n                return delta.chop();\n            };\n            Delta.prototype.transformPosition = function(index, priority) {\n                priority = !!priority;\n                var thisIter = op.iterator(this.ops);\n                var offset = 0;\n                while(thisIter.hasNext() && offset <= index){\n                    var length = thisIter.peekLength();\n                    var nextType = thisIter.peekType();\n                    thisIter.next();\n                    if (nextType === \"delete\") {\n                        index -= Math.min(length, index - offset);\n                        continue;\n                    } else if (nextType === \"insert\" && (offset < index || !priority)) {\n                        index += length;\n                    }\n                    offset += length;\n                }\n                return index;\n            };\n            module1.exports = Delta;\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            var hasOwn = Object.prototype.hasOwnProperty;\n            var toStr = Object.prototype.toString;\n            var defineProperty = Object.defineProperty;\n            var gOPD = Object.getOwnPropertyDescriptor;\n            var isArray = function isArray(arr) {\n                if (typeof Array.isArray === \"function\") {\n                    return Array.isArray(arr);\n                }\n                return toStr.call(arr) === \"[object Array]\";\n            };\n            var isPlainObject = function isPlainObject(obj) {\n                if (!obj || toStr.call(obj) !== \"[object Object]\") {\n                    return false;\n                }\n                var hasOwnConstructor = hasOwn.call(obj, \"constructor\");\n                var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\");\n                // Not own constructor property must be Object\n                if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n                    return false;\n                }\n                // Own properties are enumerated firstly, so to speed up,\n                // if last one is own, then all properties are own.\n                var key;\n                for(key in obj){}\n                return typeof key === \"undefined\" || hasOwn.call(obj, key);\n            };\n            // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\n            var setProperty = function setProperty(target, options) {\n                if (defineProperty && options.name === \"__proto__\") {\n                    defineProperty(target, options.name, {\n                        enumerable: true,\n                        configurable: true,\n                        value: options.newValue,\n                        writable: true\n                    });\n                } else {\n                    target[options.name] = options.newValue;\n                }\n            };\n            // Return undefined instead of __proto__ if '__proto__' is not an own property\n            var getProperty = function getProperty(obj, name) {\n                if (name === \"__proto__\") {\n                    if (!hasOwn.call(obj, name)) {\n                        return void 0;\n                    } else if (gOPD) {\n                        // In early versions of node, obj['__proto__'] is buggy when obj has\n                        // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n                        return gOPD(obj, name).value;\n                    }\n                }\n                return obj[name];\n            };\n            module1.exports = function extend() {\n                var options, name, src, copy, copyIsArray, clone;\n                var target = arguments[0];\n                var i = 1;\n                var length = arguments.length;\n                var deep = false;\n                // Handle a deep copy situation\n                if (typeof target === \"boolean\") {\n                    deep = target;\n                    target = arguments[1] || {};\n                    // skip the boolean and the target\n                    i = 2;\n                }\n                if (target == null || typeof target !== \"object\" && typeof target !== \"function\") {\n                    target = {};\n                }\n                for(; i < length; ++i){\n                    options = arguments[i];\n                    // Only deal with non-null/undefined values\n                    if (options != null) {\n                        // Extend the base object\n                        for(name in options){\n                            src = getProperty(target, name);\n                            copy = getProperty(options, name);\n                            // Prevent never-ending loop\n                            if (target !== copy) {\n                                // Recurse if we're merging plain objects or arrays\n                                if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n                                    if (copyIsArray) {\n                                        copyIsArray = false;\n                                        clone = src && isArray(src) ? src : [];\n                                    } else {\n                                        clone = src && isPlainObject(src) ? src : {};\n                                    }\n                                    // Never move original objects, clone them\n                                    setProperty(target, {\n                                        name: name,\n                                        newValue: extend(deep, clone, copy)\n                                    });\n                                // Don't bring in undefined values\n                                } else if (typeof copy !== \"undefined\") {\n                                    setProperty(target, {\n                                        name: name,\n                                        newValue: copy\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                // Return the modified object\n                return target;\n            };\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __nested_webpack_require_33519__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.BlockEmbed = exports1.bubbleFormats = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _extend = __nested_webpack_require_33519__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _quillDelta = __nested_webpack_require_33519__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _parchment = __nested_webpack_require_33519__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _break = __nested_webpack_require_33519__(16);\n            var _break2 = _interopRequireDefault(_break);\n            var _inline = __nested_webpack_require_33519__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            var _text = __nested_webpack_require_33519__(7);\n            var _text2 = _interopRequireDefault(_text);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var NEWLINE_LENGTH = 1;\n            var BlockEmbed = function(_Parchment$Embed) {\n                _inherits(BlockEmbed, _Parchment$Embed);\n                function BlockEmbed() {\n                    _classCallCheck(this, BlockEmbed);\n                    return _possibleConstructorReturn(this, (BlockEmbed.__proto__ || Object.getPrototypeOf(BlockEmbed)).apply(this, arguments));\n                }\n                _createClass(BlockEmbed, [\n                    {\n                        key: \"attach\",\n                        value: function attach() {\n                            _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), \"attach\", this).call(this);\n                            this.attributes = new _parchment2.default.Attributor.Store(this.domNode);\n                        }\n                    },\n                    {\n                        key: \"delta\",\n                        value: function delta() {\n                            return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);\n                            if (attribute != null) {\n                                this.attributes.attribute(attribute, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, name, value) {\n                            this.format(name, value);\n                        }\n                    },\n                    {\n                        key: \"insertAt\",\n                        value: function insertAt(index, value, def) {\n                            if (typeof value === \"string\" && value.endsWith(\"\\n\")) {\n                                var block = _parchment2.default.create(Block.blotName);\n                                this.parent.insertBefore(block, index === 0 ? this : this.next);\n                                block.insertAt(0, value.slice(0, -1));\n                            } else {\n                                _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), \"insertAt\", this).call(this, index, value, def);\n                            }\n                        }\n                    }\n                ]);\n                return BlockEmbed;\n            }(_parchment2.default.Embed);\n            BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;\n            // It is important for cursor behavior BlockEmbeds use tags that are block level elements\n            var Block = function(_Parchment$Block) {\n                _inherits(Block, _Parchment$Block);\n                function Block(domNode) {\n                    _classCallCheck(this, Block);\n                    var _this2 = _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).call(this, domNode));\n                    _this2.cache = {};\n                    return _this2;\n                }\n                _createClass(Block, [\n                    {\n                        key: \"delta\",\n                        value: function delta() {\n                            if (this.cache.delta == null) {\n                                this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function(delta, leaf) {\n                                    if (leaf.length() === 0) {\n                                        return delta;\n                                    } else {\n                                        return delta.insert(leaf.value(), bubbleFormats(leaf));\n                                    }\n                                }, new _quillDelta2.default()).insert(\"\\n\", bubbleFormats(this));\n                            }\n                            return this.cache.delta;\n                        }\n                    },\n                    {\n                        key: \"deleteAt\",\n                        value: function deleteAt(index, length) {\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"deleteAt\", this).call(this, index, length);\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, name, value) {\n                            if (length <= 0) return;\n                            if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {\n                                if (index + length === this.length()) {\n                                    this.format(name, value);\n                                }\n                            } else {\n                                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"formatAt\", this).call(this, index, Math.min(length, this.length() - index - 1), name, value);\n                            }\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"insertAt\",\n                        value: function insertAt(index, value, def) {\n                            if (def != null) return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"insertAt\", this).call(this, index, value, def);\n                            if (value.length === 0) return;\n                            var lines = value.split(\"\\n\");\n                            var text = lines.shift();\n                            if (text.length > 0) {\n                                if (index < this.length() - 1 || this.children.tail == null) {\n                                    _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"insertAt\", this).call(this, Math.min(index, this.length() - 1), text);\n                                } else {\n                                    this.children.tail.insertAt(this.children.tail.length(), text);\n                                }\n                                this.cache = {};\n                            }\n                            var block = this;\n                            lines.reduce(function(index, line) {\n                                block = block.split(index, true);\n                                block.insertAt(0, line);\n                                return line.length;\n                            }, index + text.length);\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(blot, ref) {\n                            var head = this.children.head;\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"insertBefore\", this).call(this, blot, ref);\n                            if (head instanceof _break2.default) {\n                                head.remove();\n                            }\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"length\",\n                        value: function length() {\n                            if (this.cache.length == null) {\n                                this.cache.length = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"length\", this).call(this) + NEWLINE_LENGTH;\n                            }\n                            return this.cache.length;\n                        }\n                    },\n                    {\n                        key: \"moveChildren\",\n                        value: function moveChildren(target, ref) {\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"moveChildren\", this).call(this, target, ref);\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"optimize\", this).call(this, context);\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"path\",\n                        value: function path(index) {\n                            return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"path\", this).call(this, index, true);\n                        }\n                    },\n                    {\n                        key: \"removeChild\",\n                        value: function removeChild(child) {\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"removeChild\", this).call(this, child);\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"split\",\n                        value: function split(index) {\n                            var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                            if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {\n                                var clone = this.clone();\n                                if (index === 0) {\n                                    this.parent.insertBefore(clone, this);\n                                    return this;\n                                } else {\n                                    this.parent.insertBefore(clone, this.next);\n                                    return clone;\n                                }\n                            } else {\n                                var next = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"split\", this).call(this, index, force);\n                                this.cache = {};\n                                return next;\n                            }\n                        }\n                    }\n                ]);\n                return Block;\n            }(_parchment2.default.Block);\n            Block.blotName = \"block\";\n            Block.tagName = \"P\";\n            Block.defaultChild = \"break\";\n            Block.allowedChildren = [\n                _inline2.default,\n                _parchment2.default.Embed,\n                _text2.default\n            ];\n            function bubbleFormats(blot) {\n                var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                if (blot == null) return formats;\n                if (typeof blot.formats === \"function\") {\n                    formats = (0, _extend2.default)(formats, blot.formats());\n                }\n                if (blot.parent == null || blot.parent.blotName == \"scroll\" || blot.parent.statics.scope !== blot.statics.scope) {\n                    return formats;\n                }\n                return bubbleFormats(blot.parent, formats);\n            }\n            exports1.bubbleFormats = bubbleFormats;\n            exports1.BlockEmbed = BlockEmbed;\n            exports1.default = Block;\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __nested_webpack_require_49250__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.overload = exports1.expandConfig = undefined;\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            __nested_webpack_require_49250__(50);\n            var _quillDelta = __nested_webpack_require_49250__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _editor = __nested_webpack_require_49250__(14);\n            var _editor2 = _interopRequireDefault(_editor);\n            var _emitter3 = __nested_webpack_require_49250__(8);\n            var _emitter4 = _interopRequireDefault(_emitter3);\n            var _module = __nested_webpack_require_49250__(9);\n            var _module2 = _interopRequireDefault(_module);\n            var _parchment = __nested_webpack_require_49250__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _selection = __nested_webpack_require_49250__(15);\n            var _selection2 = _interopRequireDefault(_selection);\n            var _extend = __nested_webpack_require_49250__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _logger = __nested_webpack_require_49250__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            var _theme = __nested_webpack_require_49250__(34);\n            var _theme2 = _interopRequireDefault(_theme);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var debug = (0, _logger2.default)(\"quill\");\n            var Quill = function() {\n                _createClass(Quill, null, [\n                    {\n                        key: \"debug\",\n                        value: function debug(limit) {\n                            if (limit === true) {\n                                limit = \"log\";\n                            }\n                            _logger2.default.level(limit);\n                        }\n                    },\n                    {\n                        key: \"find\",\n                        value: function find(node) {\n                            return node.__quill || _parchment2.default.find(node);\n                        }\n                    },\n                    {\n                        key: \"import\",\n                        value: function _import(name) {\n                            if (this.imports[name] == null) {\n                                debug.error(\"Cannot import \" + name + \". Are you sure it was registered?\");\n                            }\n                            return this.imports[name];\n                        }\n                    },\n                    {\n                        key: \"register\",\n                        value: function register(path, target) {\n                            var _this = this;\n                            var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                            if (typeof path !== \"string\") {\n                                var name = path.attrName || path.blotName;\n                                if (typeof name === \"string\") {\n                                    // register(Blot | Attributor, overwrite)\n                                    this.register(\"formats/\" + name, path, target);\n                                } else {\n                                    Object.keys(path).forEach(function(key) {\n                                        _this.register(key, path[key], target);\n                                    });\n                                }\n                            } else {\n                                if (this.imports[path] != null && !overwrite) {\n                                    debug.warn(\"Overwriting \" + path + \" with\", target);\n                                }\n                                this.imports[path] = target;\n                                if ((path.startsWith(\"blots/\") || path.startsWith(\"formats/\")) && target.blotName !== \"abstract\") {\n                                    _parchment2.default.register(target);\n                                } else if (path.startsWith(\"modules\") && typeof target.register === \"function\") {\n                                    target.register();\n                                }\n                            }\n                        }\n                    }\n                ]);\n                function Quill(container) {\n                    var _this2 = this;\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    _classCallCheck(this, Quill);\n                    this.options = expandConfig(container, options);\n                    this.container = this.options.container;\n                    if (this.container == null) {\n                        return debug.error(\"Invalid Quill container\", container);\n                    }\n                    if (this.options.debug) {\n                        Quill.debug(this.options.debug);\n                    }\n                    var html = this.container.innerHTML.trim();\n                    this.container.classList.add(\"ql-container\");\n                    this.container.innerHTML = \"\";\n                    this.container.__quill = this;\n                    this.root = this.addContainer(\"ql-editor\");\n                    this.root.classList.add(\"ql-blank\");\n                    this.root.setAttribute(\"data-gramm\", false);\n                    this.scrollingContainer = this.options.scrollingContainer || this.root;\n                    this.emitter = new _emitter4.default();\n                    this.scroll = _parchment2.default.create(this.root, {\n                        emitter: this.emitter,\n                        whitelist: this.options.formats\n                    });\n                    this.editor = new _editor2.default(this.scroll);\n                    this.selection = new _selection2.default(this.scroll, this.emitter);\n                    this.theme = new this.options.theme(this, this.options);\n                    this.keyboard = this.theme.addModule(\"keyboard\");\n                    this.clipboard = this.theme.addModule(\"clipboard\");\n                    this.history = this.theme.addModule(\"history\");\n                    this.theme.init();\n                    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type) {\n                        if (type === _emitter4.default.events.TEXT_CHANGE) {\n                            _this2.root.classList.toggle(\"ql-blank\", _this2.editor.isBlank());\n                        }\n                    });\n                    this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function(source, mutations) {\n                        var range = _this2.selection.lastRange;\n                        var index = range && range.length === 0 ? range.index : undefined;\n                        modify.call(_this2, function() {\n                            return _this2.editor.update(null, mutations, index);\n                        }, source);\n                    });\n                    var contents = this.clipboard.convert(\"<div class='ql-editor' style=\\\"white-space: normal;\\\">\" + html + \"<p><br></p></div>\");\n                    this.setContents(contents);\n                    this.history.clear();\n                    if (this.options.placeholder) {\n                        this.root.setAttribute(\"data-placeholder\", this.options.placeholder);\n                    }\n                    if (this.options.readOnly) {\n                        this.disable();\n                    }\n                }\n                _createClass(Quill, [\n                    {\n                        key: \"addContainer\",\n                        value: function addContainer(container) {\n                            var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n                            if (typeof container === \"string\") {\n                                var className = container;\n                                container = document.createElement(\"div\");\n                                container.classList.add(className);\n                            }\n                            this.container.insertBefore(container, refNode);\n                            return container;\n                        }\n                    },\n                    {\n                        key: \"blur\",\n                        value: function blur() {\n                            this.selection.setRange(null);\n                        }\n                    },\n                    {\n                        key: \"deleteText\",\n                        value: function deleteText(index, length, source) {\n                            var _this3 = this;\n                            var _overload = overload(index, length, source);\n                            var _overload2 = _slicedToArray(_overload, 4);\n                            index = _overload2[0];\n                            length = _overload2[1];\n                            source = _overload2[3];\n                            return modify.call(this, function() {\n                                return _this3.editor.deleteText(index, length);\n                            }, source, index, -1 * length);\n                        }\n                    },\n                    {\n                        key: \"disable\",\n                        value: function disable() {\n                            this.enable(false);\n                        }\n                    },\n                    {\n                        key: \"enable\",\n                        value: function enable() {\n                            var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                            this.scroll.enable(enabled);\n                            this.container.classList.toggle(\"ql-disabled\", !enabled);\n                        }\n                    },\n                    {\n                        key: \"focus\",\n                        value: function focus() {\n                            var scrollTop = this.scrollingContainer.scrollTop;\n                            this.selection.focus();\n                            this.scrollingContainer.scrollTop = scrollTop;\n                            this.scrollIntoView();\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            var _this4 = this;\n                            var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;\n                            return modify.call(this, function() {\n                                var range = _this4.getSelection(true);\n                                var change = new _quillDelta2.default();\n                                if (range == null) {\n                                    return change;\n                                } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {\n                                    change = _this4.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));\n                                } else if (range.length === 0) {\n                                    _this4.selection.format(name, value);\n                                    return change;\n                                } else {\n                                    change = _this4.editor.formatText(range.index, range.length, _defineProperty({}, name, value));\n                                }\n                                _this4.setSelection(range, _emitter4.default.sources.SILENT);\n                                return change;\n                            }, source);\n                        }\n                    },\n                    {\n                        key: \"formatLine\",\n                        value: function formatLine(index, length, name, value, source) {\n                            var _this5 = this;\n                            var formats = void 0;\n                            var _overload3 = overload(index, length, name, value, source);\n                            var _overload4 = _slicedToArray(_overload3, 4);\n                            index = _overload4[0];\n                            length = _overload4[1];\n                            formats = _overload4[2];\n                            source = _overload4[3];\n                            return modify.call(this, function() {\n                                return _this5.editor.formatLine(index, length, formats);\n                            }, source, index, 0);\n                        }\n                    },\n                    {\n                        key: \"formatText\",\n                        value: function formatText(index, length, name, value, source) {\n                            var _this6 = this;\n                            var formats = void 0;\n                            var _overload5 = overload(index, length, name, value, source);\n                            var _overload6 = _slicedToArray(_overload5, 4);\n                            index = _overload6[0];\n                            length = _overload6[1];\n                            formats = _overload6[2];\n                            source = _overload6[3];\n                            return modify.call(this, function() {\n                                return _this6.editor.formatText(index, length, formats);\n                            }, source, index, 0);\n                        }\n                    },\n                    {\n                        key: \"getBounds\",\n                        value: function getBounds(index) {\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                            var bounds = void 0;\n                            if (typeof index === \"number\") {\n                                bounds = this.selection.getBounds(index, length);\n                            } else {\n                                bounds = this.selection.getBounds(index.index, index.length);\n                            }\n                            var containerBounds = this.container.getBoundingClientRect();\n                            return {\n                                bottom: bounds.bottom - containerBounds.top,\n                                height: bounds.height,\n                                left: bounds.left - containerBounds.left,\n                                right: bounds.right - containerBounds.left,\n                                top: bounds.top - containerBounds.top,\n                                width: bounds.width\n                            };\n                        }\n                    },\n                    {\n                        key: \"getContents\",\n                        value: function getContents() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;\n                            var _overload7 = overload(index, length);\n                            var _overload8 = _slicedToArray(_overload7, 2);\n                            index = _overload8[0];\n                            length = _overload8[1];\n                            return this.editor.getContents(index, length);\n                        }\n                    },\n                    {\n                        key: \"getFormat\",\n                        value: function getFormat() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                            if (typeof index === \"number\") {\n                                return this.editor.getFormat(index, length);\n                            } else {\n                                return this.editor.getFormat(index.index, index.length);\n                            }\n                        }\n                    },\n                    {\n                        key: \"getIndex\",\n                        value: function getIndex(blot) {\n                            return blot.offset(this.scroll);\n                        }\n                    },\n                    {\n                        key: \"getLength\",\n                        value: function getLength() {\n                            return this.scroll.length();\n                        }\n                    },\n                    {\n                        key: \"getLeaf\",\n                        value: function getLeaf(index) {\n                            return this.scroll.leaf(index);\n                        }\n                    },\n                    {\n                        key: \"getLine\",\n                        value: function getLine(index) {\n                            return this.scroll.line(index);\n                        }\n                    },\n                    {\n                        key: \"getLines\",\n                        value: function getLines() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n                            if (typeof index !== \"number\") {\n                                return this.scroll.lines(index.index, index.length);\n                            } else {\n                                return this.scroll.lines(index, length);\n                            }\n                        }\n                    },\n                    {\n                        key: \"getModule\",\n                        value: function getModule(name) {\n                            return this.theme.modules[name];\n                        }\n                    },\n                    {\n                        key: \"getSelection\",\n                        value: function getSelection() {\n                            var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n                            if (focus) this.focus();\n                            this.update(); // Make sure we access getRange with editor in consistent state\n                            return this.selection.getRange()[0];\n                        }\n                    },\n                    {\n                        key: \"getText\",\n                        value: function getText() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;\n                            var _overload9 = overload(index, length);\n                            var _overload10 = _slicedToArray(_overload9, 2);\n                            index = _overload10[0];\n                            length = _overload10[1];\n                            return this.editor.getText(index, length);\n                        }\n                    },\n                    {\n                        key: \"hasFocus\",\n                        value: function hasFocus() {\n                            return this.selection.hasFocus();\n                        }\n                    },\n                    {\n                        key: \"insertEmbed\",\n                        value: function insertEmbed(index, embed, value) {\n                            var _this7 = this;\n                            var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;\n                            return modify.call(this, function() {\n                                return _this7.editor.insertEmbed(index, embed, value);\n                            }, source, index);\n                        }\n                    },\n                    {\n                        key: \"insertText\",\n                        value: function insertText(index, text, name, value, source) {\n                            var _this8 = this;\n                            var formats = void 0;\n                            var _overload11 = overload(index, 0, name, value, source);\n                            var _overload12 = _slicedToArray(_overload11, 4);\n                            index = _overload12[0];\n                            formats = _overload12[2];\n                            source = _overload12[3];\n                            return modify.call(this, function() {\n                                return _this8.editor.insertText(index, text, formats);\n                            }, source, index, text.length);\n                        }\n                    },\n                    {\n                        key: \"isEnabled\",\n                        value: function isEnabled() {\n                            return !this.container.classList.contains(\"ql-disabled\");\n                        }\n                    },\n                    {\n                        key: \"off\",\n                        value: function off() {\n                            return this.emitter.off.apply(this.emitter, arguments);\n                        }\n                    },\n                    {\n                        key: \"on\",\n                        value: function on() {\n                            return this.emitter.on.apply(this.emitter, arguments);\n                        }\n                    },\n                    {\n                        key: \"once\",\n                        value: function once() {\n                            return this.emitter.once.apply(this.emitter, arguments);\n                        }\n                    },\n                    {\n                        key: \"pasteHTML\",\n                        value: function pasteHTML(index, html, source) {\n                            this.clipboard.dangerouslyPasteHTML(index, html, source);\n                        }\n                    },\n                    {\n                        key: \"removeFormat\",\n                        value: function removeFormat(index, length, source) {\n                            var _this9 = this;\n                            var _overload13 = overload(index, length, source);\n                            var _overload14 = _slicedToArray(_overload13, 4);\n                            index = _overload14[0];\n                            length = _overload14[1];\n                            source = _overload14[3];\n                            return modify.call(this, function() {\n                                return _this9.editor.removeFormat(index, length);\n                            }, source, index);\n                        }\n                    },\n                    {\n                        key: \"scrollIntoView\",\n                        value: function scrollIntoView() {\n                            this.selection.scrollIntoView(this.scrollingContainer);\n                        }\n                    },\n                    {\n                        key: \"setContents\",\n                        value: function setContents(delta) {\n                            var _this10 = this;\n                            var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;\n                            return modify.call(this, function() {\n                                delta = new _quillDelta2.default(delta);\n                                var length = _this10.getLength();\n                                var deleted = _this10.editor.deleteText(0, length);\n                                var applied = _this10.editor.applyDelta(delta);\n                                var lastOp = applied.ops[applied.ops.length - 1];\n                                if (lastOp != null && typeof lastOp.insert === \"string\" && lastOp.insert[lastOp.insert.length - 1] === \"\\n\") {\n                                    _this10.editor.deleteText(_this10.getLength() - 1, 1);\n                                    applied.delete(1);\n                                }\n                                var ret = deleted.compose(applied);\n                                return ret;\n                            }, source);\n                        }\n                    },\n                    {\n                        key: \"setSelection\",\n                        value: function setSelection(index, length, source) {\n                            if (index == null) {\n                                this.selection.setRange(null, length || Quill.sources.API);\n                            } else {\n                                var _overload15 = overload(index, length, source);\n                                var _overload16 = _slicedToArray(_overload15, 4);\n                                index = _overload16[0];\n                                length = _overload16[1];\n                                source = _overload16[3];\n                                this.selection.setRange(new _selection.Range(index, length), source);\n                                if (source !== _emitter4.default.sources.SILENT) {\n                                    this.selection.scrollIntoView(this.scrollingContainer);\n                                }\n                            }\n                        }\n                    },\n                    {\n                        key: \"setText\",\n                        value: function setText(text) {\n                            var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;\n                            var delta = new _quillDelta2.default().insert(text);\n                            return this.setContents(delta, source);\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update() {\n                            var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;\n                            var change = this.scroll.update(source); // Will update selection before selection.update() does if text changes\n                            this.selection.update(source);\n                            return change;\n                        }\n                    },\n                    {\n                        key: \"updateContents\",\n                        value: function updateContents(delta) {\n                            var _this11 = this;\n                            var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;\n                            return modify.call(this, function() {\n                                delta = new _quillDelta2.default(delta);\n                                return _this11.editor.applyDelta(delta, source);\n                            }, source, true);\n                        }\n                    }\n                ]);\n                return Quill;\n            }();\n            Quill.DEFAULTS = {\n                bounds: null,\n                formats: null,\n                modules: {},\n                placeholder: \"\",\n                readOnly: false,\n                scrollingContainer: null,\n                strict: true,\n                theme: \"default\"\n            };\n            Quill.events = _emitter4.default.events;\n            Quill.sources = _emitter4.default.sources;\n            // eslint-disable-next-line no-undef\n            Quill.version =  false ? 0 : \"1.3.7\";\n            Quill.imports = {\n                \"delta\": _quillDelta2.default,\n                \"parchment\": _parchment2.default,\n                \"core/module\": _module2.default,\n                \"core/theme\": _theme2.default\n            };\n            function expandConfig(container, userConfig) {\n                userConfig = (0, _extend2.default)(true, {\n                    container: container,\n                    modules: {\n                        clipboard: true,\n                        keyboard: true,\n                        history: true\n                    }\n                }, userConfig);\n                if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {\n                    userConfig.theme = _theme2.default;\n                } else {\n                    userConfig.theme = Quill.import(\"themes/\" + userConfig.theme);\n                    if (userConfig.theme == null) {\n                        throw new Error(\"Invalid theme \" + userConfig.theme + \". Did you register it?\");\n                    }\n                }\n                var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);\n                [\n                    themeConfig,\n                    userConfig\n                ].forEach(function(config) {\n                    config.modules = config.modules || {};\n                    Object.keys(config.modules).forEach(function(module1) {\n                        if (config.modules[module1] === true) {\n                            config.modules[module1] = {};\n                        }\n                    });\n                });\n                var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));\n                var moduleConfig = moduleNames.reduce(function(config, name) {\n                    var moduleClass = Quill.import(\"modules/\" + name);\n                    if (moduleClass == null) {\n                        debug.error(\"Cannot load \" + name + \" module. Are you sure you registered it?\");\n                    } else {\n                        config[name] = moduleClass.DEFAULTS || {};\n                    }\n                    return config;\n                }, {});\n                // Special case toolbar shorthand\n                if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {\n                    userConfig.modules.toolbar = {\n                        container: userConfig.modules.toolbar\n                    };\n                }\n                userConfig = (0, _extend2.default)(true, {}, Quill.DEFAULTS, {\n                    modules: moduleConfig\n                }, themeConfig, userConfig);\n                [\n                    \"bounds\",\n                    \"container\",\n                    \"scrollingContainer\"\n                ].forEach(function(key) {\n                    if (typeof userConfig[key] === \"string\") {\n                        userConfig[key] = document.querySelector(userConfig[key]);\n                    }\n                });\n                userConfig.modules = Object.keys(userConfig.modules).reduce(function(config, name) {\n                    if (userConfig.modules[name]) {\n                        config[name] = userConfig.modules[name];\n                    }\n                    return config;\n                }, {});\n                return userConfig;\n            }\n            // Handle selection preservation and TEXT_CHANGE emission\n            // common to modification APIs\n            function modify(modifier, source, index, shift) {\n                if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {\n                    return new _quillDelta2.default();\n                }\n                var range = index == null ? null : this.getSelection();\n                var oldDelta = this.editor.delta;\n                var change = modifier();\n                if (range != null) {\n                    if (index === true) index = range.index;\n                    if (shift == null) {\n                        range = shiftRange(range, change, source);\n                    } else if (shift !== 0) {\n                        range = shiftRange(range, index, shift, source);\n                    }\n                    this.setSelection(range, _emitter4.default.sources.SILENT);\n                }\n                if (change.length() > 0) {\n                    var _emitter;\n                    var args = [\n                        _emitter4.default.events.TEXT_CHANGE,\n                        change,\n                        oldDelta,\n                        source\n                    ];\n                    (_emitter = this.emitter).emit.apply(_emitter, [\n                        _emitter4.default.events.EDITOR_CHANGE\n                    ].concat(args));\n                    if (source !== _emitter4.default.sources.SILENT) {\n                        var _emitter2;\n                        (_emitter2 = this.emitter).emit.apply(_emitter2, args);\n                    }\n                }\n                return change;\n            }\n            function overload(index, length, name, value, source) {\n                var formats = {};\n                if (typeof index.index === \"number\" && typeof index.length === \"number\") {\n                    // Allow for throwaway end (used by insertText/insertEmbed)\n                    if (typeof length !== \"number\") {\n                        source = value, value = name, name = length, length = index.length, index = index.index;\n                    } else {\n                        length = index.length, index = index.index;\n                    }\n                } else if (typeof length !== \"number\") {\n                    source = value, value = name, name = length, length = 0;\n                }\n                // Handle format being object, two format name/value strings or excluded\n                if ((typeof name === \"undefined\" ? \"undefined\" : _typeof(name)) === \"object\") {\n                    formats = name;\n                    source = value;\n                } else if (typeof name === \"string\") {\n                    if (value != null) {\n                        formats[name] = value;\n                    } else {\n                        source = name;\n                    }\n                }\n                // Handle optional source\n                source = source || _emitter4.default.sources.API;\n                return [\n                    index,\n                    length,\n                    formats,\n                    source\n                ];\n            }\n            function shiftRange(range, index, length, source) {\n                if (range == null) return null;\n                var start = void 0, end = void 0;\n                if (index instanceof _quillDelta2.default) {\n                    var _map = [\n                        range.index,\n                        range.index + range.length\n                    ].map(function(pos) {\n                        return index.transformPosition(pos, source !== _emitter4.default.sources.USER);\n                    });\n                    var _map2 = _slicedToArray(_map, 2);\n                    start = _map2[0];\n                    end = _map2[1];\n                } else {\n                    var _map3 = [\n                        range.index,\n                        range.index + range.length\n                    ].map(function(pos) {\n                        if (pos < index || pos === index && source === _emitter4.default.sources.USER) return pos;\n                        if (length >= 0) {\n                            return pos + length;\n                        } else {\n                            return Math.max(index, pos + length);\n                        }\n                    });\n                    var _map4 = _slicedToArray(_map3, 2);\n                    start = _map4[0];\n                    end = _map4[1];\n                }\n                return new _selection.Range(start, end - start);\n            }\n            exports1.expandConfig = expandConfig;\n            exports1.overload = overload;\n            exports1.default = Quill;\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_88453__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _text = __nested_webpack_require_88453__(7);\n            var _text2 = _interopRequireDefault(_text);\n            var _parchment = __nested_webpack_require_88453__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Inline = function(_Parchment$Inline) {\n                _inherits(Inline, _Parchment$Inline);\n                function Inline() {\n                    _classCallCheck(this, Inline);\n                    return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));\n                }\n                _createClass(Inline, [\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, name, value) {\n                            if (Inline.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {\n                                var blot = this.isolate(index, length);\n                                if (value) {\n                                    blot.wrap(name, value);\n                                }\n                            } else {\n                                _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), \"formatAt\", this).call(this, index, length, name, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), \"optimize\", this).call(this, context);\n                            if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {\n                                var parent = this.parent.isolate(this.offset(), this.length());\n                                this.moveChildren(parent);\n                                parent.wrap(this);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"compare\",\n                        value: function compare(self1, other) {\n                            var selfIndex = Inline.order.indexOf(self1);\n                            var otherIndex = Inline.order.indexOf(other);\n                            if (selfIndex >= 0 || otherIndex >= 0) {\n                                return selfIndex - otherIndex;\n                            } else if (self1 === other) {\n                                return 0;\n                            } else if (self1 < other) {\n                                return -1;\n                            } else {\n                                return 1;\n                            }\n                        }\n                    }\n                ]);\n                return Inline;\n            }(_parchment2.default.Inline);\n            Inline.allowedChildren = [\n                Inline,\n                _parchment2.default.Embed,\n                _text2.default\n            ];\n            // Lower index means deeper in the DOM tree, since not found (-1) is for embeds\n            Inline.order = [\n                \"cursor\",\n                \"inline\",\n                \"underline\",\n                \"strike\",\n                \"italic\",\n                \"bold\",\n                \"script\",\n                \"link\",\n                \"code\" // Must be higher\n            ];\n            exports1.default = Inline;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_95438__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _parchment = __nested_webpack_require_95438__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var TextBlot = function(_Parchment$Text) {\n                _inherits(TextBlot, _Parchment$Text);\n                function TextBlot() {\n                    _classCallCheck(this, TextBlot);\n                    return _possibleConstructorReturn(this, (TextBlot.__proto__ || Object.getPrototypeOf(TextBlot)).apply(this, arguments));\n                }\n                return TextBlot;\n            }(_parchment2.default.Text);\n            exports1.default = TextBlot;\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_97744__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _eventemitter = __nested_webpack_require_97744__(54);\n            var _eventemitter2 = _interopRequireDefault(_eventemitter);\n            var _logger = __nested_webpack_require_97744__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var debug = (0, _logger2.default)(\"quill:events\");\n            var EVENTS = [\n                \"selectionchange\",\n                \"mousedown\",\n                \"mouseup\",\n                \"click\"\n            ];\n            EVENTS.forEach(function(eventName) {\n                document.addEventListener(eventName, function() {\n                    for(var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    [].slice.call(document.querySelectorAll(\".ql-container\")).forEach(function(node) {\n                        // TODO use WeakMap\n                        if (node.__quill && node.__quill.emitter) {\n                            var _node$__quill$emitter;\n                            (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);\n                        }\n                    });\n                });\n            });\n            var Emitter = function(_EventEmitter) {\n                _inherits(Emitter, _EventEmitter);\n                function Emitter() {\n                    _classCallCheck(this, Emitter);\n                    var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));\n                    _this.listeners = {};\n                    _this.on(\"error\", debug.error);\n                    return _this;\n                }\n                _createClass(Emitter, [\n                    {\n                        key: \"emit\",\n                        value: function emit() {\n                            debug.log.apply(debug, arguments);\n                            _get(Emitter.prototype.__proto__ || Object.getPrototypeOf(Emitter.prototype), \"emit\", this).apply(this, arguments);\n                        }\n                    },\n                    {\n                        key: \"handleDOM\",\n                        value: function handleDOM(event) {\n                            for(var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                                args[_key2 - 1] = arguments[_key2];\n                            }\n                            (this.listeners[event.type] || []).forEach(function(_ref) {\n                                var node = _ref.node, handler = _ref.handler;\n                                if (event.target === node || node.contains(event.target)) {\n                                    handler.apply(undefined, [\n                                        event\n                                    ].concat(args));\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"listenDOM\",\n                        value: function listenDOM(eventName, node, handler) {\n                            if (!this.listeners[eventName]) {\n                                this.listeners[eventName] = [];\n                            }\n                            this.listeners[eventName].push({\n                                node: node,\n                                handler: handler\n                            });\n                        }\n                    }\n                ]);\n                return Emitter;\n            }(_eventemitter2.default);\n            Emitter.events = {\n                EDITOR_CHANGE: \"editor-change\",\n                SCROLL_BEFORE_UPDATE: \"scroll-before-update\",\n                SCROLL_OPTIMIZE: \"scroll-optimize\",\n                SCROLL_UPDATE: \"scroll-update\",\n                SELECTION_CHANGE: \"selection-change\",\n                TEXT_CHANGE: \"text-change\"\n            };\n            Emitter.sources = {\n                API: \"api\",\n                SILENT: \"silent\",\n                USER: \"user\"\n            };\n            exports1.default = Emitter;\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var Module = function Module(quill) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                _classCallCheck(this, Module);\n                this.quill = quill;\n                this.options = options;\n            };\n            Module.DEFAULTS = {};\n            exports1.default = Module;\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var levels = [\n                \"error\",\n                \"warn\",\n                \"log\",\n                \"info\"\n            ];\n            var level = \"warn\";\n            function debug(method) {\n                if (levels.indexOf(method) <= levels.indexOf(level)) {\n                    var _console;\n                    for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    (_console = console)[method].apply(_console, args); // eslint-disable-line no-console\n                }\n            }\n            function namespace(ns) {\n                return levels.reduce(function(logger, method) {\n                    logger[method] = debug.bind(console, method, ns);\n                    return logger;\n                }, {});\n            }\n            debug.level = namespace.level = function(newLevel) {\n                level = newLevel;\n            };\n            exports1.default = namespace;\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1, __nested_webpack_require_107434__) {\n            var pSlice = Array.prototype.slice;\n            var objectKeys = __nested_webpack_require_107434__(52);\n            var isArguments = __nested_webpack_require_107434__(53);\n            var deepEqual = module1.exports = function(actual, expected, opts) {\n                if (!opts) opts = {};\n                // 7.1. All identical values are equivalent, as determined by ===.\n                if (actual === expected) {\n                    return true;\n                } else if (actual instanceof Date && expected instanceof Date) {\n                    return actual.getTime() === expected.getTime();\n                // 7.3. Other pairs that do not both pass typeof value == 'object',\n                // equivalence is determined by ==.\n                } else if (!actual || !expected || typeof actual != \"object\" && typeof expected != \"object\") {\n                    return opts.strict ? actual === expected : actual == expected;\n                // 7.4. For all other Object pairs, including Array objects, equivalence is\n                // determined by having the same number of owned properties (as verified\n                // with Object.prototype.hasOwnProperty.call), the same set of keys\n                // (although not necessarily the same order), equivalent values for every\n                // corresponding key, and an identical 'prototype' property. Note: this\n                // accounts for both named and indexed properties on Arrays.\n                } else {\n                    return objEquiv(actual, expected, opts);\n                }\n            };\n            function isUndefinedOrNull(value) {\n                return value === null || value === undefined;\n            }\n            function isBuffer(x) {\n                if (!x || typeof x !== \"object\" || typeof x.length !== \"number\") return false;\n                if (typeof x.copy !== \"function\" || typeof x.slice !== \"function\") {\n                    return false;\n                }\n                if (x.length > 0 && typeof x[0] !== \"number\") return false;\n                return true;\n            }\n            function objEquiv(a, b, opts) {\n                var i, key;\n                if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;\n                // an identical 'prototype' property.\n                if (a.prototype !== b.prototype) return false;\n                //~~~I've managed to break Object.keys through screwy arguments passing.\n                //   Converting to array solves the problem.\n                if (isArguments(a)) {\n                    if (!isArguments(b)) {\n                        return false;\n                    }\n                    a = pSlice.call(a);\n                    b = pSlice.call(b);\n                    return deepEqual(a, b, opts);\n                }\n                if (isBuffer(a)) {\n                    if (!isBuffer(b)) {\n                        return false;\n                    }\n                    if (a.length !== b.length) return false;\n                    for(i = 0; i < a.length; i++){\n                        if (a[i] !== b[i]) return false;\n                    }\n                    return true;\n                }\n                try {\n                    var ka = objectKeys(a), kb = objectKeys(b);\n                } catch (e) {\n                    return false;\n                }\n                // having the same number of owned properties (keys incorporates\n                // hasOwnProperty)\n                if (ka.length != kb.length) return false;\n                //the same set of keys (although not necessarily the same order),\n                ka.sort();\n                kb.sort();\n                //~~~cheap key test\n                for(i = ka.length - 1; i >= 0; i--){\n                    if (ka[i] != kb[i]) return false;\n                }\n                //equivalent values for every corresponding key, and\n                //~~~possibly expensive deep test\n                for(i = ka.length - 1; i >= 0; i--){\n                    key = ka[i];\n                    if (!deepEqual(a[key], b[key], opts)) return false;\n                }\n                return typeof a === typeof b;\n            }\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1, __nested_webpack_require_111667__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var Registry = __nested_webpack_require_111667__(1);\n            var Attributor = /** @class */ function() {\n                function Attributor(attrName, keyName, options) {\n                    if (options === void 0) {\n                        options = {};\n                    }\n                    this.attrName = attrName;\n                    this.keyName = keyName;\n                    var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;\n                    if (options.scope != null) {\n                        // Ignore type bits, force attribute bit\n                        this.scope = options.scope & Registry.Scope.LEVEL | attributeBit;\n                    } else {\n                        this.scope = Registry.Scope.ATTRIBUTE;\n                    }\n                    if (options.whitelist != null) this.whitelist = options.whitelist;\n                }\n                Attributor.keys = function(node) {\n                    return [].map.call(node.attributes, function(item) {\n                        return item.name;\n                    });\n                };\n                Attributor.prototype.add = function(node, value) {\n                    if (!this.canAdd(node, value)) return false;\n                    node.setAttribute(this.keyName, value);\n                    return true;\n                };\n                Attributor.prototype.canAdd = function(node, value) {\n                    var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));\n                    if (match == null) return false;\n                    if (this.whitelist == null) return true;\n                    if (typeof value === \"string\") {\n                        return this.whitelist.indexOf(value.replace(/[\"']/g, \"\")) > -1;\n                    } else {\n                        return this.whitelist.indexOf(value) > -1;\n                    }\n                };\n                Attributor.prototype.remove = function(node) {\n                    node.removeAttribute(this.keyName);\n                };\n                Attributor.prototype.value = function(node) {\n                    var value = node.getAttribute(this.keyName);\n                    if (this.canAdd(node, value) && value) {\n                        return value;\n                    }\n                    return \"\";\n                };\n                return Attributor;\n            }();\n            exports1.default = Attributor;\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1, __nested_webpack_require_114325__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.Code = undefined;\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _quillDelta = __nested_webpack_require_114325__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _parchment = __nested_webpack_require_114325__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _block = __nested_webpack_require_114325__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _inline = __nested_webpack_require_114325__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            var _text = __nested_webpack_require_114325__(7);\n            var _text2 = _interopRequireDefault(_text);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Code = function(_Inline) {\n                _inherits(Code, _Inline);\n                function Code() {\n                    _classCallCheck(this, Code);\n                    return _possibleConstructorReturn(this, (Code.__proto__ || Object.getPrototypeOf(Code)).apply(this, arguments));\n                }\n                return Code;\n            }(_inline2.default);\n            Code.blotName = \"code\";\n            Code.tagName = \"CODE\";\n            var CodeBlock = function(_Block) {\n                _inherits(CodeBlock, _Block);\n                function CodeBlock() {\n                    _classCallCheck(this, CodeBlock);\n                    return _possibleConstructorReturn(this, (CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock)).apply(this, arguments));\n                }\n                _createClass(CodeBlock, [\n                    {\n                        key: \"delta\",\n                        value: function delta() {\n                            var _this3 = this;\n                            var text = this.domNode.textContent;\n                            if (text.endsWith(\"\\n\")) {\n                                // Should always be true\n                                text = text.slice(0, -1);\n                            }\n                            return text.split(\"\\n\").reduce(function(delta, frag) {\n                                return delta.insert(frag).insert(\"\\n\", _this3.formats());\n                            }, new _quillDelta2.default());\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (name === this.statics.blotName && value) return;\n                            var _descendant = this.descendant(_text2.default, this.length() - 1), _descendant2 = _slicedToArray(_descendant, 1), text = _descendant2[0];\n                            if (text != null) {\n                                text.deleteAt(text.length() - 1, 1);\n                            }\n                            _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), \"format\", this).call(this, name, value);\n                        }\n                    },\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, name, value) {\n                            if (length === 0) return;\n                            if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {\n                                return;\n                            }\n                            var nextNewline = this.newlineIndex(index);\n                            if (nextNewline < 0 || nextNewline >= index + length) return;\n                            var prevNewline = this.newlineIndex(index, true) + 1;\n                            var isolateLength = nextNewline - prevNewline + 1;\n                            var blot = this.isolate(prevNewline, isolateLength);\n                            var next = blot.next;\n                            blot.format(name, value);\n                            if (next instanceof CodeBlock) {\n                                next.formatAt(0, index - prevNewline + length - isolateLength, name, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"insertAt\",\n                        value: function insertAt(index, value, def) {\n                            if (def != null) return;\n                            var _descendant3 = this.descendant(_text2.default, index), _descendant4 = _slicedToArray(_descendant3, 2), text = _descendant4[0], offset = _descendant4[1];\n                            text.insertAt(offset, value);\n                        }\n                    },\n                    {\n                        key: \"length\",\n                        value: function length() {\n                            var length = this.domNode.textContent.length;\n                            if (!this.domNode.textContent.endsWith(\"\\n\")) {\n                                return length + 1;\n                            }\n                            return length;\n                        }\n                    },\n                    {\n                        key: \"newlineIndex\",\n                        value: function newlineIndex(searchIndex) {\n                            var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                            if (!reverse) {\n                                var offset = this.domNode.textContent.slice(searchIndex).indexOf(\"\\n\");\n                                return offset > -1 ? searchIndex + offset : -1;\n                            } else {\n                                return this.domNode.textContent.slice(0, searchIndex).lastIndexOf(\"\\n\");\n                            }\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            if (!this.domNode.textContent.endsWith(\"\\n\")) {\n                                this.appendChild(_parchment2.default.create(\"text\", \"\\n\"));\n                            }\n                            _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), \"optimize\", this).call(this, context);\n                            var next = this.next;\n                            if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {\n                                next.optimize(context);\n                                next.moveChildren(this);\n                                next.remove();\n                            }\n                        }\n                    },\n                    {\n                        key: \"replace\",\n                        value: function replace(target) {\n                            _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), \"replace\", this).call(this, target);\n                            [].slice.call(this.domNode.querySelectorAll(\"*\")).forEach(function(node) {\n                                var blot = _parchment2.default.find(node);\n                                if (blot == null) {\n                                    node.parentNode.removeChild(node);\n                                } else if (blot instanceof _parchment2.default.Embed) {\n                                    blot.remove();\n                                } else {\n                                    blot.unwrap();\n                                }\n                            });\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var domNode = _get(CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock), \"create\", this).call(this, value);\n                            domNode.setAttribute(\"spellcheck\", false);\n                            return domNode;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats() {\n                            return true;\n                        }\n                    }\n                ]);\n                return CodeBlock;\n            }(_block2.default);\n            CodeBlock.blotName = \"code-block\";\n            CodeBlock.tagName = \"PRE\";\n            CodeBlock.TAB = \"  \";\n            exports1.Code = Code;\n            exports1.default = CodeBlock;\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1, __nested_webpack_require_127639__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _quillDelta = __nested_webpack_require_127639__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _op = __nested_webpack_require_127639__(20);\n            var _op2 = _interopRequireDefault(_op);\n            var _parchment = __nested_webpack_require_127639__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _code = __nested_webpack_require_127639__(13);\n            var _code2 = _interopRequireDefault(_code);\n            var _cursor = __nested_webpack_require_127639__(24);\n            var _cursor2 = _interopRequireDefault(_cursor);\n            var _block = __nested_webpack_require_127639__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _break = __nested_webpack_require_127639__(16);\n            var _break2 = _interopRequireDefault(_break);\n            var _clone = __nested_webpack_require_127639__(21);\n            var _clone2 = _interopRequireDefault(_clone);\n            var _deepEqual = __nested_webpack_require_127639__(11);\n            var _deepEqual2 = _interopRequireDefault(_deepEqual);\n            var _extend = __nested_webpack_require_127639__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var ASCII = /^[ -~]*$/;\n            var Editor = function() {\n                function Editor(scroll) {\n                    _classCallCheck(this, Editor);\n                    this.scroll = scroll;\n                    this.delta = this.getDelta();\n                }\n                _createClass(Editor, [\n                    {\n                        key: \"applyDelta\",\n                        value: function applyDelta(delta) {\n                            var _this = this;\n                            var consumeNextNewline = false;\n                            this.scroll.update();\n                            var scrollLength = this.scroll.length();\n                            this.scroll.batchStart();\n                            delta = normalizeDelta(delta);\n                            delta.reduce(function(index, op) {\n                                var length = op.retain || op.delete || op.insert.length || 1;\n                                var attributes = op.attributes || {};\n                                if (op.insert != null) {\n                                    if (typeof op.insert === \"string\") {\n                                        var text = op.insert;\n                                        if (text.endsWith(\"\\n\") && consumeNextNewline) {\n                                            consumeNextNewline = false;\n                                            text = text.slice(0, -1);\n                                        }\n                                        if (index >= scrollLength && !text.endsWith(\"\\n\")) {\n                                            consumeNextNewline = true;\n                                        }\n                                        _this.scroll.insertAt(index, text);\n                                        var _scroll$line = _this.scroll.line(index), _scroll$line2 = _slicedToArray(_scroll$line, 2), line = _scroll$line2[0], offset = _scroll$line2[1];\n                                        var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));\n                                        if (line instanceof _block2.default) {\n                                            var _line$descendant = line.descendant(_parchment2.default.Leaf, offset), _line$descendant2 = _slicedToArray(_line$descendant, 1), leaf = _line$descendant2[0];\n                                            formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));\n                                        }\n                                        attributes = _op2.default.attributes.diff(formats, attributes) || {};\n                                    } else if (_typeof(op.insert) === \"object\") {\n                                        var key = Object.keys(op.insert)[0]; // There should only be one key\n                                        if (key == null) return index;\n                                        _this.scroll.insertAt(index, key, op.insert[key]);\n                                    }\n                                    scrollLength += length;\n                                }\n                                Object.keys(attributes).forEach(function(name) {\n                                    _this.scroll.formatAt(index, length, name, attributes[name]);\n                                });\n                                return index + length;\n                            }, 0);\n                            delta.reduce(function(index, op) {\n                                if (typeof op.delete === \"number\") {\n                                    _this.scroll.deleteAt(index, op.delete);\n                                    return index;\n                                }\n                                return index + (op.retain || op.insert.length || 1);\n                            }, 0);\n                            this.scroll.batchEnd();\n                            return this.update(delta);\n                        }\n                    },\n                    {\n                        key: \"deleteText\",\n                        value: function deleteText(index, length) {\n                            this.scroll.deleteAt(index, length);\n                            return this.update(new _quillDelta2.default().retain(index).delete(length));\n                        }\n                    },\n                    {\n                        key: \"formatLine\",\n                        value: function formatLine(index, length) {\n                            var _this2 = this;\n                            var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            this.scroll.update();\n                            Object.keys(formats).forEach(function(format) {\n                                if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format]) return;\n                                var lines = _this2.scroll.lines(index, Math.max(length, 1));\n                                var lengthRemaining = length;\n                                lines.forEach(function(line) {\n                                    var lineLength = line.length();\n                                    if (!(line instanceof _code2.default)) {\n                                        line.format(format, formats[format]);\n                                    } else {\n                                        var codeIndex = index - line.offset(_this2.scroll);\n                                        var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;\n                                        line.formatAt(codeIndex, codeLength, format, formats[format]);\n                                    }\n                                    lengthRemaining -= lineLength;\n                                });\n                            });\n                            this.scroll.optimize();\n                            return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));\n                        }\n                    },\n                    {\n                        key: \"formatText\",\n                        value: function formatText(index, length) {\n                            var _this3 = this;\n                            var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            Object.keys(formats).forEach(function(format) {\n                                _this3.scroll.formatAt(index, length, format, formats[format]);\n                            });\n                            return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));\n                        }\n                    },\n                    {\n                        key: \"getContents\",\n                        value: function getContents(index, length) {\n                            return this.delta.slice(index, index + length);\n                        }\n                    },\n                    {\n                        key: \"getDelta\",\n                        value: function getDelta() {\n                            return this.scroll.lines().reduce(function(delta, line) {\n                                return delta.concat(line.delta());\n                            }, new _quillDelta2.default());\n                        }\n                    },\n                    {\n                        key: \"getFormat\",\n                        value: function getFormat(index) {\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                            var lines = [], leaves = [];\n                            if (length === 0) {\n                                this.scroll.path(index).forEach(function(path) {\n                                    var _path = _slicedToArray(path, 1), blot = _path[0];\n                                    if (blot instanceof _block2.default) {\n                                        lines.push(blot);\n                                    } else if (blot instanceof _parchment2.default.Leaf) {\n                                        leaves.push(blot);\n                                    }\n                                });\n                            } else {\n                                lines = this.scroll.lines(index, length);\n                                leaves = this.scroll.descendants(_parchment2.default.Leaf, index, length);\n                            }\n                            var formatsArr = [\n                                lines,\n                                leaves\n                            ].map(function(blots) {\n                                if (blots.length === 0) return {};\n                                var formats = (0, _block.bubbleFormats)(blots.shift());\n                                while(Object.keys(formats).length > 0){\n                                    var blot = blots.shift();\n                                    if (blot == null) return formats;\n                                    formats = combineFormats((0, _block.bubbleFormats)(blot), formats);\n                                }\n                                return formats;\n                            });\n                            return _extend2.default.apply(_extend2.default, formatsArr);\n                        }\n                    },\n                    {\n                        key: \"getText\",\n                        value: function getText(index, length) {\n                            return this.getContents(index, length).filter(function(op) {\n                                return typeof op.insert === \"string\";\n                            }).map(function(op) {\n                                return op.insert;\n                            }).join(\"\");\n                        }\n                    },\n                    {\n                        key: \"insertEmbed\",\n                        value: function insertEmbed(index, embed, value) {\n                            this.scroll.insertAt(index, embed, value);\n                            return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({}, embed, value)));\n                        }\n                    },\n                    {\n                        key: \"insertText\",\n                        value: function insertText(index, text) {\n                            var _this4 = this;\n                            var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            text = text.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                            this.scroll.insertAt(index, text);\n                            Object.keys(formats).forEach(function(format) {\n                                _this4.scroll.formatAt(index, text.length, format, formats[format]);\n                            });\n                            return this.update(new _quillDelta2.default().retain(index).insert(text, (0, _clone2.default)(formats)));\n                        }\n                    },\n                    {\n                        key: \"isBlank\",\n                        value: function isBlank() {\n                            if (this.scroll.children.length == 0) return true;\n                            if (this.scroll.children.length > 1) return false;\n                            var block = this.scroll.children.head;\n                            if (block.statics.blotName !== _block2.default.blotName) return false;\n                            if (block.children.length > 1) return false;\n                            return block.children.head instanceof _break2.default;\n                        }\n                    },\n                    {\n                        key: \"removeFormat\",\n                        value: function removeFormat(index, length) {\n                            var text = this.getText(index, length);\n                            var _scroll$line3 = this.scroll.line(index + length), _scroll$line4 = _slicedToArray(_scroll$line3, 2), line = _scroll$line4[0], offset = _scroll$line4[1];\n                            var suffixLength = 0, suffix = new _quillDelta2.default();\n                            if (line != null) {\n                                if (!(line instanceof _code2.default)) {\n                                    suffixLength = line.length() - offset;\n                                } else {\n                                    suffixLength = line.newlineIndex(offset) - offset + 1;\n                                }\n                                suffix = line.delta().slice(offset, offset + suffixLength - 1).insert(\"\\n\");\n                            }\n                            var contents = this.getContents(index, length + suffixLength);\n                            var diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));\n                            var delta = new _quillDelta2.default().retain(index).concat(diff);\n                            return this.applyDelta(delta);\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(change) {\n                            var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n                            var cursorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n                            var oldDelta = this.delta;\n                            if (mutations.length === 1 && mutations[0].type === \"characterData\" && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {\n                                // Optimization for character changes\n                                var textBlot = _parchment2.default.find(mutations[0].target);\n                                var formats = (0, _block.bubbleFormats)(textBlot);\n                                var index = textBlot.offset(this.scroll);\n                                var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, \"\");\n                                var oldText = new _quillDelta2.default().insert(oldValue);\n                                var newText = new _quillDelta2.default().insert(textBlot.value());\n                                var diffDelta = new _quillDelta2.default().retain(index).concat(oldText.diff(newText, cursorIndex));\n                                change = diffDelta.reduce(function(delta, op) {\n                                    if (op.insert) {\n                                        return delta.insert(op.insert, formats);\n                                    } else {\n                                        return delta.push(op);\n                                    }\n                                }, new _quillDelta2.default());\n                                this.delta = oldDelta.compose(change);\n                            } else {\n                                this.delta = this.getDelta();\n                                if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {\n                                    change = oldDelta.diff(this.delta, cursorIndex);\n                                }\n                            }\n                            return change;\n                        }\n                    }\n                ]);\n                return Editor;\n            }();\n            function combineFormats(formats, combined) {\n                return Object.keys(combined).reduce(function(merged, name) {\n                    if (formats[name] == null) return merged;\n                    if (combined[name] === formats[name]) {\n                        merged[name] = combined[name];\n                    } else if (Array.isArray(combined[name])) {\n                        if (combined[name].indexOf(formats[name]) < 0) {\n                            merged[name] = combined[name].concat([\n                                formats[name]\n                            ]);\n                        }\n                    } else {\n                        merged[name] = [\n                            combined[name],\n                            formats[name]\n                        ];\n                    }\n                    return merged;\n                }, {});\n            }\n            function normalizeDelta(delta) {\n                return delta.reduce(function(delta, op) {\n                    if (op.insert === 1) {\n                        var attributes = (0, _clone2.default)(op.attributes);\n                        delete attributes[\"image\"];\n                        return delta.insert({\n                            image: op.attributes.image\n                        }, attributes);\n                    }\n                    if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {\n                        op = (0, _clone2.default)(op);\n                        if (op.attributes.list) {\n                            op.attributes.list = \"ordered\";\n                        } else {\n                            op.attributes.list = \"bullet\";\n                            delete op.attributes.bullet;\n                        }\n                    }\n                    if (typeof op.insert === \"string\") {\n                        var text = op.insert.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                        return delta.insert(text, op.attributes);\n                    }\n                    return delta.push(op);\n                }, new _quillDelta2.default());\n            }\n            exports1.default = Editor;\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1, __nested_webpack_require_150070__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.Range = undefined;\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _parchment = __nested_webpack_require_150070__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _clone = __nested_webpack_require_150070__(21);\n            var _clone2 = _interopRequireDefault(_clone);\n            var _deepEqual = __nested_webpack_require_150070__(11);\n            var _deepEqual2 = _interopRequireDefault(_deepEqual);\n            var _emitter3 = __nested_webpack_require_150070__(8);\n            var _emitter4 = _interopRequireDefault(_emitter3);\n            var _logger = __nested_webpack_require_150070__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                        arr2[i] = arr[i];\n                    }\n                    return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var debug = (0, _logger2.default)(\"quill:selection\");\n            var Range = function Range(index) {\n                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                _classCallCheck(this, Range);\n                this.index = index;\n                this.length = length;\n            };\n            var Selection = function() {\n                function Selection(scroll, emitter) {\n                    var _this = this;\n                    _classCallCheck(this, Selection);\n                    this.emitter = emitter;\n                    this.scroll = scroll;\n                    this.composing = false;\n                    this.mouseDown = false;\n                    this.root = this.scroll.domNode;\n                    this.cursor = _parchment2.default.create(\"cursor\", this);\n                    // savedRange is last non-null range\n                    this.lastRange = this.savedRange = new Range(0, 0);\n                    this.handleComposition();\n                    this.handleDragging();\n                    this.emitter.listenDOM(\"selectionchange\", document, function() {\n                        if (!_this.mouseDown) {\n                            setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);\n                        }\n                    });\n                    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type, delta) {\n                        if (type === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {\n                            _this.update(_emitter4.default.sources.SILENT);\n                        }\n                    });\n                    this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function() {\n                        if (!_this.hasFocus()) return;\n                        var native = _this.getNativeRange();\n                        if (native == null) return;\n                        if (native.start.node === _this.cursor.textNode) return; // cursor.restore() will handle\n                        // TODO unclear if this has negative side effects\n                        _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function() {\n                            try {\n                                _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);\n                            } catch (ignored) {}\n                        });\n                    });\n                    this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function(mutations, context) {\n                        if (context.range) {\n                            var _context$range = context.range, startNode = _context$range.startNode, startOffset = _context$range.startOffset, endNode = _context$range.endNode, endOffset = _context$range.endOffset;\n                            _this.setNativeRange(startNode, startOffset, endNode, endOffset);\n                        }\n                    });\n                    this.update(_emitter4.default.sources.SILENT);\n                }\n                _createClass(Selection, [\n                    {\n                        key: \"handleComposition\",\n                        value: function handleComposition() {\n                            var _this2 = this;\n                            this.root.addEventListener(\"compositionstart\", function() {\n                                _this2.composing = true;\n                            });\n                            this.root.addEventListener(\"compositionend\", function() {\n                                _this2.composing = false;\n                                if (_this2.cursor.parent) {\n                                    var range = _this2.cursor.restore();\n                                    if (!range) return;\n                                    setTimeout(function() {\n                                        _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);\n                                    }, 1);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"handleDragging\",\n                        value: function handleDragging() {\n                            var _this3 = this;\n                            this.emitter.listenDOM(\"mousedown\", document.body, function() {\n                                _this3.mouseDown = true;\n                            });\n                            this.emitter.listenDOM(\"mouseup\", document.body, function() {\n                                _this3.mouseDown = false;\n                                _this3.update(_emitter4.default.sources.USER);\n                            });\n                        }\n                    },\n                    {\n                        key: \"focus\",\n                        value: function focus() {\n                            if (this.hasFocus()) return;\n                            this.root.focus();\n                            this.setRange(this.savedRange);\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(_format, value) {\n                            if (this.scroll.whitelist != null && !this.scroll.whitelist[_format]) return;\n                            this.scroll.update();\n                            var nativeRange = this.getNativeRange();\n                            if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK)) return;\n                            if (nativeRange.start.node !== this.cursor.textNode) {\n                                var blot = _parchment2.default.find(nativeRange.start.node, false);\n                                if (blot == null) return;\n                                // TODO Give blot ability to not split\n                                if (blot instanceof _parchment2.default.Leaf) {\n                                    var after = blot.split(nativeRange.start.offset);\n                                    blot.parent.insertBefore(this.cursor, after);\n                                } else {\n                                    blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen\n                                }\n                                this.cursor.attach();\n                            }\n                            this.cursor.format(_format, value);\n                            this.scroll.optimize();\n                            this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);\n                            this.update();\n                        }\n                    },\n                    {\n                        key: \"getBounds\",\n                        value: function getBounds(index) {\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                            var scrollLength = this.scroll.length();\n                            index = Math.min(index, scrollLength - 1);\n                            length = Math.min(index + length, scrollLength - 1) - index;\n                            var node = void 0, _scroll$leaf = this.scroll.leaf(index), _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2), leaf = _scroll$leaf2[0], offset = _scroll$leaf2[1];\n                            if (leaf == null) return null;\n                            var _leaf$position = leaf.position(offset, true);\n                            var _leaf$position2 = _slicedToArray(_leaf$position, 2);\n                            node = _leaf$position2[0];\n                            offset = _leaf$position2[1];\n                            var range = document.createRange();\n                            if (length > 0) {\n                                range.setStart(node, offset);\n                                var _scroll$leaf3 = this.scroll.leaf(index + length);\n                                var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);\n                                leaf = _scroll$leaf4[0];\n                                offset = _scroll$leaf4[1];\n                                if (leaf == null) return null;\n                                var _leaf$position3 = leaf.position(offset, true);\n                                var _leaf$position4 = _slicedToArray(_leaf$position3, 2);\n                                node = _leaf$position4[0];\n                                offset = _leaf$position4[1];\n                                range.setEnd(node, offset);\n                                return range.getBoundingClientRect();\n                            } else {\n                                var side = \"left\";\n                                var rect = void 0;\n                                if (node instanceof Text) {\n                                    if (offset < node.data.length) {\n                                        range.setStart(node, offset);\n                                        range.setEnd(node, offset + 1);\n                                    } else {\n                                        range.setStart(node, offset - 1);\n                                        range.setEnd(node, offset);\n                                        side = \"right\";\n                                    }\n                                    rect = range.getBoundingClientRect();\n                                } else {\n                                    rect = leaf.domNode.getBoundingClientRect();\n                                    if (offset > 0) side = \"right\";\n                                }\n                                return {\n                                    bottom: rect.top + rect.height,\n                                    height: rect.height,\n                                    left: rect[side],\n                                    right: rect[side],\n                                    top: rect.top,\n                                    width: 0\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"getNativeRange\",\n                        value: function getNativeRange() {\n                            var selection = document.getSelection();\n                            if (selection == null || selection.rangeCount <= 0) return null;\n                            var nativeRange = selection.getRangeAt(0);\n                            if (nativeRange == null) return null;\n                            var range = this.normalizeNative(nativeRange);\n                            debug.info(\"getNativeRange\", range);\n                            return range;\n                        }\n                    },\n                    {\n                        key: \"getRange\",\n                        value: function getRange() {\n                            var normalized = this.getNativeRange();\n                            if (normalized == null) return [\n                                null,\n                                null\n                            ];\n                            var range = this.normalizedToRange(normalized);\n                            return [\n                                range,\n                                normalized\n                            ];\n                        }\n                    },\n                    {\n                        key: \"hasFocus\",\n                        value: function hasFocus() {\n                            return document.activeElement === this.root;\n                        }\n                    },\n                    {\n                        key: \"normalizedToRange\",\n                        value: function normalizedToRange(range) {\n                            var _this4 = this;\n                            var positions = [\n                                [\n                                    range.start.node,\n                                    range.start.offset\n                                ]\n                            ];\n                            if (!range.native.collapsed) {\n                                positions.push([\n                                    range.end.node,\n                                    range.end.offset\n                                ]);\n                            }\n                            var indexes = positions.map(function(position) {\n                                var _position = _slicedToArray(position, 2), node = _position[0], offset = _position[1];\n                                var blot = _parchment2.default.find(node, true);\n                                var index = blot.offset(_this4.scroll);\n                                if (offset === 0) {\n                                    return index;\n                                } else if (blot instanceof _parchment2.default.Container) {\n                                    return index + blot.length();\n                                } else {\n                                    return index + blot.index(node, offset);\n                                }\n                            });\n                            var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);\n                            var start = Math.min.apply(Math, [\n                                end\n                            ].concat(_toConsumableArray(indexes)));\n                            return new Range(start, end - start);\n                        }\n                    },\n                    {\n                        key: \"normalizeNative\",\n                        value: function normalizeNative(nativeRange) {\n                            if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {\n                                return null;\n                            }\n                            var range = {\n                                start: {\n                                    node: nativeRange.startContainer,\n                                    offset: nativeRange.startOffset\n                                },\n                                end: {\n                                    node: nativeRange.endContainer,\n                                    offset: nativeRange.endOffset\n                                },\n                                native: nativeRange\n                            };\n                            [\n                                range.start,\n                                range.end\n                            ].forEach(function(position) {\n                                var node = position.node, offset = position.offset;\n                                while(!(node instanceof Text) && node.childNodes.length > 0){\n                                    if (node.childNodes.length > offset) {\n                                        node = node.childNodes[offset];\n                                        offset = 0;\n                                    } else if (node.childNodes.length === offset) {\n                                        node = node.lastChild;\n                                        offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                                position.node = node, position.offset = offset;\n                            });\n                            return range;\n                        }\n                    },\n                    {\n                        key: \"rangeToNative\",\n                        value: function rangeToNative(range) {\n                            var _this5 = this;\n                            var indexes = range.collapsed ? [\n                                range.index\n                            ] : [\n                                range.index,\n                                range.index + range.length\n                            ];\n                            var args = [];\n                            var scrollLength = this.scroll.length();\n                            indexes.forEach(function(index, i) {\n                                index = Math.min(scrollLength - 1, index);\n                                var node = void 0, _scroll$leaf5 = _this5.scroll.leaf(index), _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2), leaf = _scroll$leaf6[0], offset = _scroll$leaf6[1];\n                                var _leaf$position5 = leaf.position(offset, i !== 0);\n                                var _leaf$position6 = _slicedToArray(_leaf$position5, 2);\n                                node = _leaf$position6[0];\n                                offset = _leaf$position6[1];\n                                args.push(node, offset);\n                            });\n                            if (args.length < 2) {\n                                args = args.concat(args);\n                            }\n                            return args;\n                        }\n                    },\n                    {\n                        key: \"scrollIntoView\",\n                        value: function scrollIntoView(scrollingContainer) {\n                            var range = this.lastRange;\n                            if (range == null) return;\n                            var bounds = this.getBounds(range.index, range.length);\n                            if (bounds == null) return;\n                            var limit = this.scroll.length() - 1;\n                            var _scroll$line = this.scroll.line(Math.min(range.index, limit)), _scroll$line2 = _slicedToArray(_scroll$line, 1), first = _scroll$line2[0];\n                            var last = first;\n                            if (range.length > 0) {\n                                var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));\n                                var _scroll$line4 = _slicedToArray(_scroll$line3, 1);\n                                last = _scroll$line4[0];\n                            }\n                            if (first == null || last == null) return;\n                            var scrollBounds = scrollingContainer.getBoundingClientRect();\n                            if (bounds.top < scrollBounds.top) {\n                                scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;\n                            } else if (bounds.bottom > scrollBounds.bottom) {\n                                scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;\n                            }\n                        }\n                    },\n                    {\n                        key: \"setNativeRange\",\n                        value: function setNativeRange(startNode, startOffset) {\n                            var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;\n                            var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;\n                            var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n                            debug.info(\"setNativeRange\", startNode, startOffset, endNode, endOffset);\n                            if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {\n                                return;\n                            }\n                            var selection = document.getSelection();\n                            if (selection == null) return;\n                            if (startNode != null) {\n                                if (!this.hasFocus()) this.root.focus();\n                                var native = (this.getNativeRange() || {}).native;\n                                if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {\n                                    if (startNode.tagName == \"BR\") {\n                                        startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);\n                                        startNode = startNode.parentNode;\n                                    }\n                                    if (endNode.tagName == \"BR\") {\n                                        endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);\n                                        endNode = endNode.parentNode;\n                                    }\n                                    var range = document.createRange();\n                                    range.setStart(startNode, startOffset);\n                                    range.setEnd(endNode, endOffset);\n                                    selection.removeAllRanges();\n                                    selection.addRange(range);\n                                }\n                            } else {\n                                selection.removeAllRanges();\n                                this.root.blur();\n                                document.body.focus(); // root.blur() not enough on IE11+Travis+SauceLabs (but not local VMs)\n                            }\n                        }\n                    },\n                    {\n                        key: \"setRange\",\n                        value: function setRange(range) {\n                            var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                            var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;\n                            if (typeof force === \"string\") {\n                                source = force;\n                                force = false;\n                            }\n                            debug.info(\"setRange\", range);\n                            if (range != null) {\n                                var args = this.rangeToNative(range);\n                                this.setNativeRange.apply(this, _toConsumableArray(args).concat([\n                                    force\n                                ]));\n                            } else {\n                                this.setNativeRange(null);\n                            }\n                            this.update(source);\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update() {\n                            var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;\n                            var oldRange = this.lastRange;\n                            var _getRange = this.getRange(), _getRange2 = _slicedToArray(_getRange, 2), lastRange = _getRange2[0], nativeRange = _getRange2[1];\n                            this.lastRange = lastRange;\n                            if (this.lastRange != null) {\n                                this.savedRange = this.lastRange;\n                            }\n                            if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {\n                                var _emitter;\n                                if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {\n                                    this.cursor.restore();\n                                }\n                                var args = [\n                                    _emitter4.default.events.SELECTION_CHANGE,\n                                    (0, _clone2.default)(this.lastRange),\n                                    (0, _clone2.default)(oldRange),\n                                    source\n                                ];\n                                (_emitter = this.emitter).emit.apply(_emitter, [\n                                    _emitter4.default.events.EDITOR_CHANGE\n                                ].concat(args));\n                                if (source !== _emitter4.default.sources.SILENT) {\n                                    var _emitter2;\n                                    (_emitter2 = this.emitter).emit.apply(_emitter2, args);\n                                }\n                            }\n                        }\n                    }\n                ]);\n                return Selection;\n            }();\n            function contains(parent, descendant) {\n                try {\n                    // Firefox inserts inaccessible nodes around video elements\n                    descendant.parentNode;\n                } catch (e) {\n                    return false;\n                }\n                // IE11 has bug with Text nodes\n                // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect\n                if (descendant instanceof Text) {\n                    descendant = descendant.parentNode;\n                }\n                return parent.contains(descendant);\n            }\n            exports1.Range = Range;\n            exports1.default = Selection;\n        /***/ },\n        /* 16 */ /***/ function(module1, exports1, __nested_webpack_require_179363__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_179363__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Break = function(_Parchment$Embed) {\n                _inherits(Break, _Parchment$Embed);\n                function Break() {\n                    _classCallCheck(this, Break);\n                    return _possibleConstructorReturn(this, (Break.__proto__ || Object.getPrototypeOf(Break)).apply(this, arguments));\n                }\n                _createClass(Break, [\n                    {\n                        key: \"insertInto\",\n                        value: function insertInto(parent, ref) {\n                            if (parent.children.length === 0) {\n                                _get(Break.prototype.__proto__ || Object.getPrototypeOf(Break.prototype), \"insertInto\", this).call(this, parent, ref);\n                            } else {\n                                this.remove();\n                            }\n                        }\n                    },\n                    {\n                        key: \"length\",\n                        value: function length() {\n                            return 0;\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return \"\";\n                        }\n                    }\n                ], [\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return undefined;\n                        }\n                    }\n                ]);\n                return Break;\n            }(_parchment2.default.Embed);\n            Break.blotName = \"break\";\n            Break.tagName = \"BR\";\n            exports1.default = Break;\n        /***/ },\n        /* 17 */ /***/ function(module1, exports1, __nested_webpack_require_184642__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var linked_list_1 = __nested_webpack_require_184642__(44);\n            var shadow_1 = __nested_webpack_require_184642__(30);\n            var Registry = __nested_webpack_require_184642__(1);\n            var ContainerBlot = /** @class */ function(_super) {\n                __extends(ContainerBlot, _super);\n                function ContainerBlot(domNode) {\n                    var _this = _super.call(this, domNode) || this;\n                    _this.build();\n                    return _this;\n                }\n                ContainerBlot.prototype.appendChild = function(other) {\n                    this.insertBefore(other);\n                };\n                ContainerBlot.prototype.attach = function() {\n                    _super.prototype.attach.call(this);\n                    this.children.forEach(function(child) {\n                        child.attach();\n                    });\n                };\n                ContainerBlot.prototype.build = function() {\n                    var _this = this;\n                    this.children = new linked_list_1.default();\n                    // Need to be reversed for if DOM nodes already in order\n                    [].slice.call(this.domNode.childNodes).reverse().forEach(function(node) {\n                        try {\n                            var child = makeBlot(node);\n                            _this.insertBefore(child, _this.children.head || undefined);\n                        } catch (err) {\n                            if (err instanceof Registry.ParchmentError) return;\n                            else throw err;\n                        }\n                    });\n                };\n                ContainerBlot.prototype.deleteAt = function(index, length) {\n                    if (index === 0 && length === this.length()) {\n                        return this.remove();\n                    }\n                    this.children.forEachAt(index, length, function(child, offset, length) {\n                        child.deleteAt(offset, length);\n                    });\n                };\n                ContainerBlot.prototype.descendant = function(criteria, index) {\n                    var _a = this.children.find(index), child = _a[0], offset = _a[1];\n                    if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {\n                        return [\n                            child,\n                            offset\n                        ];\n                    } else if (child instanceof ContainerBlot) {\n                        return child.descendant(criteria, offset);\n                    } else {\n                        return [\n                            null,\n                            -1\n                        ];\n                    }\n                };\n                ContainerBlot.prototype.descendants = function(criteria, index, length) {\n                    if (index === void 0) {\n                        index = 0;\n                    }\n                    if (length === void 0) {\n                        length = Number.MAX_VALUE;\n                    }\n                    var descendants = [];\n                    var lengthLeft = length;\n                    this.children.forEachAt(index, length, function(child, index, length) {\n                        if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {\n                            descendants.push(child);\n                        }\n                        if (child instanceof ContainerBlot) {\n                            descendants = descendants.concat(child.descendants(criteria, index, lengthLeft));\n                        }\n                        lengthLeft -= length;\n                    });\n                    return descendants;\n                };\n                ContainerBlot.prototype.detach = function() {\n                    this.children.forEach(function(child) {\n                        child.detach();\n                    });\n                    _super.prototype.detach.call(this);\n                };\n                ContainerBlot.prototype.formatAt = function(index, length, name, value) {\n                    this.children.forEachAt(index, length, function(child, offset, length) {\n                        child.formatAt(offset, length, name, value);\n                    });\n                };\n                ContainerBlot.prototype.insertAt = function(index, value, def) {\n                    var _a = this.children.find(index), child = _a[0], offset = _a[1];\n                    if (child) {\n                        child.insertAt(offset, value, def);\n                    } else {\n                        var blot = def == null ? Registry.create(\"text\", value) : Registry.create(value, def);\n                        this.appendChild(blot);\n                    }\n                };\n                ContainerBlot.prototype.insertBefore = function(childBlot, refBlot) {\n                    if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function(child) {\n                        return childBlot instanceof child;\n                    })) {\n                        throw new Registry.ParchmentError(\"Cannot insert \" + childBlot.statics.blotName + \" into \" + this.statics.blotName);\n                    }\n                    childBlot.insertInto(this, refBlot);\n                };\n                ContainerBlot.prototype.length = function() {\n                    return this.children.reduce(function(memo, child) {\n                        return memo + child.length();\n                    }, 0);\n                };\n                ContainerBlot.prototype.moveChildren = function(targetParent, refNode) {\n                    this.children.forEach(function(child) {\n                        targetParent.insertBefore(child, refNode);\n                    });\n                };\n                ContainerBlot.prototype.optimize = function(context) {\n                    _super.prototype.optimize.call(this, context);\n                    if (this.children.length === 0) {\n                        if (this.statics.defaultChild != null) {\n                            var child = Registry.create(this.statics.defaultChild);\n                            this.appendChild(child);\n                            child.optimize(context);\n                        } else {\n                            this.remove();\n                        }\n                    }\n                };\n                ContainerBlot.prototype.path = function(index, inclusive) {\n                    if (inclusive === void 0) {\n                        inclusive = false;\n                    }\n                    var _a = this.children.find(index, inclusive), child = _a[0], offset = _a[1];\n                    var position = [\n                        [\n                            this,\n                            index\n                        ]\n                    ];\n                    if (child instanceof ContainerBlot) {\n                        return position.concat(child.path(offset, inclusive));\n                    } else if (child != null) {\n                        position.push([\n                            child,\n                            offset\n                        ]);\n                    }\n                    return position;\n                };\n                ContainerBlot.prototype.removeChild = function(child) {\n                    this.children.remove(child);\n                };\n                ContainerBlot.prototype.replace = function(target) {\n                    if (target instanceof ContainerBlot) {\n                        target.moveChildren(this);\n                    }\n                    _super.prototype.replace.call(this, target);\n                };\n                ContainerBlot.prototype.split = function(index, force) {\n                    if (force === void 0) {\n                        force = false;\n                    }\n                    if (!force) {\n                        if (index === 0) return this;\n                        if (index === this.length()) return this.next;\n                    }\n                    var after = this.clone();\n                    this.parent.insertBefore(after, this.next);\n                    this.children.forEachAt(index, this.length(), function(child, offset, length) {\n                        child = child.split(offset, force);\n                        after.appendChild(child);\n                    });\n                    return after;\n                };\n                ContainerBlot.prototype.unwrap = function() {\n                    this.moveChildren(this.parent, this.next);\n                    this.remove();\n                };\n                ContainerBlot.prototype.update = function(mutations, context) {\n                    var _this = this;\n                    var addedNodes = [];\n                    var removedNodes = [];\n                    mutations.forEach(function(mutation) {\n                        if (mutation.target === _this.domNode && mutation.type === \"childList\") {\n                            addedNodes.push.apply(addedNodes, mutation.addedNodes);\n                            removedNodes.push.apply(removedNodes, mutation.removedNodes);\n                        }\n                    });\n                    removedNodes.forEach(function(node) {\n                        // Check node has actually been removed\n                        // One exception is Chrome does not immediately remove IFRAMEs\n                        // from DOM but MutationRecord is correct in its reported removal\n                        if (node.parentNode != null && // @ts-ignore\n                        node.tagName !== \"IFRAME\" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n                            return;\n                        }\n                        var blot = Registry.find(node);\n                        if (blot == null) return;\n                        if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {\n                            blot.detach();\n                        }\n                    });\n                    addedNodes.filter(function(node) {\n                        return node.parentNode == _this.domNode;\n                    }).sort(function(a, b) {\n                        if (a === b) return 0;\n                        if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n                            return 1;\n                        }\n                        return -1;\n                    }).forEach(function(node) {\n                        var refBlot = null;\n                        if (node.nextSibling != null) {\n                            refBlot = Registry.find(node.nextSibling);\n                        }\n                        var blot = makeBlot(node);\n                        if (blot.next != refBlot || blot.next == null) {\n                            if (blot.parent != null) {\n                                blot.parent.removeChild(_this);\n                            }\n                            _this.insertBefore(blot, refBlot || undefined);\n                        }\n                    });\n                };\n                return ContainerBlot;\n            }(shadow_1.default);\n            function makeBlot(node) {\n                var blot = Registry.find(node);\n                if (blot == null) {\n                    try {\n                        blot = Registry.create(node);\n                    } catch (e) {\n                        blot = Registry.create(Registry.Scope.INLINE);\n                        [].slice.call(node.childNodes).forEach(function(child) {\n                            // @ts-ignore\n                            blot.domNode.appendChild(child);\n                        });\n                        if (node.parentNode) {\n                            node.parentNode.replaceChild(blot.domNode, node);\n                        }\n                        blot.attach();\n                    }\n                }\n                return blot;\n            }\n            exports1.default = ContainerBlot;\n        /***/ },\n        /* 18 */ /***/ function(module1, exports1, __nested_webpack_require_197706__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var attributor_1 = __nested_webpack_require_197706__(12);\n            var store_1 = __nested_webpack_require_197706__(31);\n            var container_1 = __nested_webpack_require_197706__(17);\n            var Registry = __nested_webpack_require_197706__(1);\n            var FormatBlot = /** @class */ function(_super) {\n                __extends(FormatBlot, _super);\n                function FormatBlot(domNode) {\n                    var _this = _super.call(this, domNode) || this;\n                    _this.attributes = new store_1.default(_this.domNode);\n                    return _this;\n                }\n                FormatBlot.formats = function(domNode) {\n                    if (typeof this.tagName === \"string\") {\n                        return true;\n                    } else if (Array.isArray(this.tagName)) {\n                        return domNode.tagName.toLowerCase();\n                    }\n                    return undefined;\n                };\n                FormatBlot.prototype.format = function(name, value) {\n                    var format = Registry.query(name);\n                    if (format instanceof attributor_1.default) {\n                        this.attributes.attribute(format, value);\n                    } else if (value) {\n                        if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {\n                            this.replaceWith(name, value);\n                        }\n                    }\n                };\n                FormatBlot.prototype.formats = function() {\n                    var formats = this.attributes.values();\n                    var format = this.statics.formats(this.domNode);\n                    if (format != null) {\n                        formats[this.statics.blotName] = format;\n                    }\n                    return formats;\n                };\n                FormatBlot.prototype.replaceWith = function(name, value) {\n                    var replacement = _super.prototype.replaceWith.call(this, name, value);\n                    this.attributes.copy(replacement);\n                    return replacement;\n                };\n                FormatBlot.prototype.update = function(mutations, context) {\n                    var _this = this;\n                    _super.prototype.update.call(this, mutations, context);\n                    if (mutations.some(function(mutation) {\n                        return mutation.target === _this.domNode && mutation.type === \"attributes\";\n                    })) {\n                        this.attributes.build();\n                    }\n                };\n                FormatBlot.prototype.wrap = function(name, value) {\n                    var wrapper = _super.prototype.wrap.call(this, name, value);\n                    if (wrapper instanceof FormatBlot && wrapper.statics.scope === this.statics.scope) {\n                        this.attributes.move(wrapper);\n                    }\n                    return wrapper;\n                };\n                return FormatBlot;\n            }(container_1.default);\n            exports1.default = FormatBlot;\n        /***/ },\n        /* 19 */ /***/ function(module1, exports1, __nested_webpack_require_201723__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var shadow_1 = __nested_webpack_require_201723__(30);\n            var Registry = __nested_webpack_require_201723__(1);\n            var LeafBlot = /** @class */ function(_super) {\n                __extends(LeafBlot, _super);\n                function LeafBlot() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                LeafBlot.value = function(domNode) {\n                    return true;\n                };\n                LeafBlot.prototype.index = function(node, offset) {\n                    if (this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n                        return Math.min(offset, 1);\n                    }\n                    return -1;\n                };\n                LeafBlot.prototype.position = function(index, inclusive) {\n                    var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);\n                    if (index > 0) offset += 1;\n                    return [\n                        this.parent.domNode,\n                        offset\n                    ];\n                };\n                LeafBlot.prototype.value = function() {\n                    var _a;\n                    return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;\n                };\n                LeafBlot.scope = Registry.Scope.INLINE_BLOT;\n                return LeafBlot;\n            }(shadow_1.default);\n            exports1.default = LeafBlot;\n        /***/ },\n        /* 20 */ /***/ function(module1, exports1, __nested_webpack_require_204185__) {\n            var equal = __nested_webpack_require_204185__(11);\n            var extend = __nested_webpack_require_204185__(3);\n            var lib = {\n                attributes: {\n                    compose: function(a, b, keepNull) {\n                        if (typeof a !== \"object\") a = {};\n                        if (typeof b !== \"object\") b = {};\n                        var attributes = extend(true, {}, b);\n                        if (!keepNull) {\n                            attributes = Object.keys(attributes).reduce(function(copy, key) {\n                                if (attributes[key] != null) {\n                                    copy[key] = attributes[key];\n                                }\n                                return copy;\n                            }, {});\n                        }\n                        for(var key in a){\n                            if (a[key] !== undefined && b[key] === undefined) {\n                                attributes[key] = a[key];\n                            }\n                        }\n                        return Object.keys(attributes).length > 0 ? attributes : undefined;\n                    },\n                    diff: function(a, b) {\n                        if (typeof a !== \"object\") a = {};\n                        if (typeof b !== \"object\") b = {};\n                        var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function(attributes, key) {\n                            if (!equal(a[key], b[key])) {\n                                attributes[key] = b[key] === undefined ? null : b[key];\n                            }\n                            return attributes;\n                        }, {});\n                        return Object.keys(attributes).length > 0 ? attributes : undefined;\n                    },\n                    transform: function(a, b, priority) {\n                        if (typeof a !== \"object\") return b;\n                        if (typeof b !== \"object\") return undefined;\n                        if (!priority) return b; // b simply overwrites us without priority\n                        var attributes = Object.keys(b).reduce(function(attributes, key) {\n                            if (a[key] === undefined) attributes[key] = b[key]; // null is a valid value\n                            return attributes;\n                        }, {});\n                        return Object.keys(attributes).length > 0 ? attributes : undefined;\n                    }\n                },\n                iterator: function(ops) {\n                    return new Iterator(ops);\n                },\n                length: function(op) {\n                    if (typeof op[\"delete\"] === \"number\") {\n                        return op[\"delete\"];\n                    } else if (typeof op.retain === \"number\") {\n                        return op.retain;\n                    } else {\n                        return typeof op.insert === \"string\" ? op.insert.length : 1;\n                    }\n                }\n            };\n            function Iterator(ops) {\n                this.ops = ops;\n                this.index = 0;\n                this.offset = 0;\n            }\n            ;\n            Iterator.prototype.hasNext = function() {\n                return this.peekLength() < Infinity;\n            };\n            Iterator.prototype.next = function(length) {\n                if (!length) length = Infinity;\n                var nextOp = this.ops[this.index];\n                if (nextOp) {\n                    var offset = this.offset;\n                    var opLength = lib.length(nextOp);\n                    if (length >= opLength - offset) {\n                        length = opLength - offset;\n                        this.index += 1;\n                        this.offset = 0;\n                    } else {\n                        this.offset += length;\n                    }\n                    if (typeof nextOp[\"delete\"] === \"number\") {\n                        return {\n                            \"delete\": length\n                        };\n                    } else {\n                        var retOp = {};\n                        if (nextOp.attributes) {\n                            retOp.attributes = nextOp.attributes;\n                        }\n                        if (typeof nextOp.retain === \"number\") {\n                            retOp.retain = length;\n                        } else if (typeof nextOp.insert === \"string\") {\n                            retOp.insert = nextOp.insert.substr(offset, length);\n                        } else {\n                            // offset should === 0, length should === 1\n                            retOp.insert = nextOp.insert;\n                        }\n                        return retOp;\n                    }\n                } else {\n                    return {\n                        retain: Infinity\n                    };\n                }\n            };\n            Iterator.prototype.peek = function() {\n                return this.ops[this.index];\n            };\n            Iterator.prototype.peekLength = function() {\n                if (this.ops[this.index]) {\n                    // Should never return 0 if our index is being managed correctly\n                    return lib.length(this.ops[this.index]) - this.offset;\n                } else {\n                    return Infinity;\n                }\n            };\n            Iterator.prototype.peekType = function() {\n                if (this.ops[this.index]) {\n                    if (typeof this.ops[this.index][\"delete\"] === \"number\") {\n                        return \"delete\";\n                    } else if (typeof this.ops[this.index].retain === \"number\") {\n                        return \"retain\";\n                    } else {\n                        return \"insert\";\n                    }\n                }\n                return \"retain\";\n            };\n            Iterator.prototype.rest = function() {\n                if (!this.hasNext()) {\n                    return [];\n                } else if (this.offset === 0) {\n                    return this.ops.slice(this.index);\n                } else {\n                    var offset = this.offset;\n                    var index = this.index;\n                    var next = this.next();\n                    var rest = this.ops.slice(this.index);\n                    this.offset = offset;\n                    this.index = index;\n                    return [\n                        next\n                    ].concat(rest);\n                }\n            };\n            module1.exports = lib;\n        /***/ },\n        /* 21 */ /***/ function(module1, exports1) {\n            var clone = function() {\n                \"use strict\";\n                function _instanceof(obj, type) {\n                    return type != null && obj instanceof type;\n                }\n                var nativeMap;\n                try {\n                    nativeMap = Map;\n                } catch (_) {\n                    // maybe a reference error because no `Map`. Give it a dummy value that no\n                    // value will ever be an instanceof.\n                    nativeMap = function() {};\n                }\n                var nativeSet;\n                try {\n                    nativeSet = Set;\n                } catch (_) {\n                    nativeSet = function() {};\n                }\n                var nativePromise;\n                try {\n                    nativePromise = Promise;\n                } catch (_) {\n                    nativePromise = function() {};\n                }\n                /**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/ function clone(parent, circular, depth, prototype, includeNonEnumerable) {\n                    if (typeof circular === \"object\") {\n                        depth = circular.depth;\n                        prototype = circular.prototype;\n                        includeNonEnumerable = circular.includeNonEnumerable;\n                        circular = circular.circular;\n                    }\n                    // maintain two arrays for circular references, where corresponding parents\n                    // and children have the same index\n                    var allParents = [];\n                    var allChildren = [];\n                    var useBuffer = typeof Buffer != \"undefined\";\n                    if (typeof circular == \"undefined\") circular = true;\n                    if (typeof depth == \"undefined\") depth = Infinity;\n                    // recurse this function so we don't reset allParents and allChildren\n                    function _clone(parent, depth) {\n                        // cloning null always returns null\n                        if (parent === null) return null;\n                        if (depth === 0) return parent;\n                        var child;\n                        var proto;\n                        if (typeof parent != \"object\") {\n                            return parent;\n                        }\n                        if (_instanceof(parent, nativeMap)) {\n                            child = new nativeMap();\n                        } else if (_instanceof(parent, nativeSet)) {\n                            child = new nativeSet();\n                        } else if (_instanceof(parent, nativePromise)) {\n                            child = new nativePromise(function(resolve, reject) {\n                                parent.then(function(value) {\n                                    resolve(_clone(value, depth - 1));\n                                }, function(err) {\n                                    reject(_clone(err, depth - 1));\n                                });\n                            });\n                        } else if (clone.__isArray(parent)) {\n                            child = [];\n                        } else if (clone.__isRegExp(parent)) {\n                            child = new RegExp(parent.source, __getRegExpFlags(parent));\n                            if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n                        } else if (clone.__isDate(parent)) {\n                            child = new Date(parent.getTime());\n                        } else if (useBuffer && Buffer.isBuffer(parent)) {\n                            if (Buffer.allocUnsafe) {\n                                // Node.js >= 4.5.0\n                                child = Buffer.allocUnsafe(parent.length);\n                            } else {\n                                // Older Node.js versions\n                                child = new Buffer(parent.length);\n                            }\n                            parent.copy(child);\n                            return child;\n                        } else if (_instanceof(parent, Error)) {\n                            child = Object.create(parent);\n                        } else {\n                            if (typeof prototype == \"undefined\") {\n                                proto = Object.getPrototypeOf(parent);\n                                child = Object.create(proto);\n                            } else {\n                                child = Object.create(prototype);\n                                proto = prototype;\n                            }\n                        }\n                        if (circular) {\n                            var index = allParents.indexOf(parent);\n                            if (index != -1) {\n                                return allChildren[index];\n                            }\n                            allParents.push(parent);\n                            allChildren.push(child);\n                        }\n                        if (_instanceof(parent, nativeMap)) {\n                            parent.forEach(function(value, key) {\n                                var keyChild = _clone(key, depth - 1);\n                                var valueChild = _clone(value, depth - 1);\n                                child.set(keyChild, valueChild);\n                            });\n                        }\n                        if (_instanceof(parent, nativeSet)) {\n                            parent.forEach(function(value) {\n                                var entryChild = _clone(value, depth - 1);\n                                child.add(entryChild);\n                            });\n                        }\n                        for(var i in parent){\n                            var attrs;\n                            if (proto) {\n                                attrs = Object.getOwnPropertyDescriptor(proto, i);\n                            }\n                            if (attrs && attrs.set == null) {\n                                continue;\n                            }\n                            child[i] = _clone(parent[i], depth - 1);\n                        }\n                        if (Object.getOwnPropertySymbols) {\n                            var symbols = Object.getOwnPropertySymbols(parent);\n                            for(var i = 0; i < symbols.length; i++){\n                                // Don't need to worry about cloning a symbol because it is a primitive,\n                                // like a number or string.\n                                var symbol = symbols[i];\n                                var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n                                if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n                                    continue;\n                                }\n                                child[symbol] = _clone(parent[symbol], depth - 1);\n                                if (!descriptor.enumerable) {\n                                    Object.defineProperty(child, symbol, {\n                                        enumerable: false\n                                    });\n                                }\n                            }\n                        }\n                        if (includeNonEnumerable) {\n                            var allPropertyNames = Object.getOwnPropertyNames(parent);\n                            for(var i = 0; i < allPropertyNames.length; i++){\n                                var propertyName = allPropertyNames[i];\n                                var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n                                if (descriptor && descriptor.enumerable) {\n                                    continue;\n                                }\n                                child[propertyName] = _clone(parent[propertyName], depth - 1);\n                                Object.defineProperty(child, propertyName, {\n                                    enumerable: false\n                                });\n                            }\n                        }\n                        return child;\n                    }\n                    return _clone(parent, depth);\n                }\n                /**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */ clone.clonePrototype = function clonePrototype(parent) {\n                    if (parent === null) return null;\n                    var c = function() {};\n                    c.prototype = parent;\n                    return new c();\n                };\n                // private utility functions\n                function __objToStr(o) {\n                    return Object.prototype.toString.call(o);\n                }\n                clone.__objToStr = __objToStr;\n                function __isDate(o) {\n                    return typeof o === \"object\" && __objToStr(o) === \"[object Date]\";\n                }\n                clone.__isDate = __isDate;\n                function __isArray(o) {\n                    return typeof o === \"object\" && __objToStr(o) === \"[object Array]\";\n                }\n                clone.__isArray = __isArray;\n                function __isRegExp(o) {\n                    return typeof o === \"object\" && __objToStr(o) === \"[object RegExp]\";\n                }\n                clone.__isRegExp = __isRegExp;\n                function __getRegExpFlags(re) {\n                    var flags = \"\";\n                    if (re.global) flags += \"g\";\n                    if (re.ignoreCase) flags += \"i\";\n                    if (re.multiline) flags += \"m\";\n                    return flags;\n                }\n                clone.__getRegExpFlags = __getRegExpFlags;\n                return clone;\n            }();\n            if (typeof module1 === \"object\" && module1.exports) {\n                module1.exports = clone;\n            }\n        /***/ },\n        /* 22 */ /***/ function(module1, exports1, __nested_webpack_require_221991__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_221991__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _emitter = __nested_webpack_require_221991__(8);\n            var _emitter2 = _interopRequireDefault(_emitter);\n            var _block = __nested_webpack_require_221991__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _break = __nested_webpack_require_221991__(16);\n            var _break2 = _interopRequireDefault(_break);\n            var _code = __nested_webpack_require_221991__(13);\n            var _code2 = _interopRequireDefault(_code);\n            var _container = __nested_webpack_require_221991__(25);\n            var _container2 = _interopRequireDefault(_container);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            function isLine(blot) {\n                return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;\n            }\n            var Scroll = function(_Parchment$Scroll) {\n                _inherits(Scroll, _Parchment$Scroll);\n                function Scroll(domNode, config) {\n                    _classCallCheck(this, Scroll);\n                    var _this = _possibleConstructorReturn(this, (Scroll.__proto__ || Object.getPrototypeOf(Scroll)).call(this, domNode));\n                    _this.emitter = config.emitter;\n                    if (Array.isArray(config.whitelist)) {\n                        _this.whitelist = config.whitelist.reduce(function(whitelist, format) {\n                            whitelist[format] = true;\n                            return whitelist;\n                        }, {});\n                    }\n                    // Some reason fixes composition issues with character languages in Windows/Chrome, Safari\n                    _this.domNode.addEventListener(\"DOMNodeInserted\", function() {});\n                    _this.optimize();\n                    _this.enable();\n                    return _this;\n                }\n                _createClass(Scroll, [\n                    {\n                        key: \"batchStart\",\n                        value: function batchStart() {\n                            this.batch = true;\n                        }\n                    },\n                    {\n                        key: \"batchEnd\",\n                        value: function batchEnd() {\n                            this.batch = false;\n                            this.optimize();\n                        }\n                    },\n                    {\n                        key: \"deleteAt\",\n                        value: function deleteAt(index, length) {\n                            var _line = this.line(index), _line2 = _slicedToArray(_line, 2), first = _line2[0], offset = _line2[1];\n                            var _line3 = this.line(index + length), _line4 = _slicedToArray(_line3, 1), last = _line4[0];\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"deleteAt\", this).call(this, index, length);\n                            if (last != null && first !== last && offset > 0) {\n                                if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {\n                                    this.optimize();\n                                    return;\n                                }\n                                if (first instanceof _code2.default) {\n                                    var newlineIndex = first.newlineIndex(first.length(), true);\n                                    if (newlineIndex > -1) {\n                                        first = first.split(newlineIndex + 1);\n                                        if (first === last) {\n                                            this.optimize();\n                                            return;\n                                        }\n                                    }\n                                } else if (last instanceof _code2.default) {\n                                    var _newlineIndex = last.newlineIndex(0);\n                                    if (_newlineIndex > -1) {\n                                        last.split(_newlineIndex + 1);\n                                    }\n                                }\n                                var ref = last.children.head instanceof _break2.default ? null : last.children.head;\n                                first.moveChildren(last, ref);\n                                first.remove();\n                            }\n                            this.optimize();\n                        }\n                    },\n                    {\n                        key: \"enable\",\n                        value: function enable() {\n                            var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                            this.domNode.setAttribute(\"contenteditable\", enabled);\n                        }\n                    },\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, format, value) {\n                            if (this.whitelist != null && !this.whitelist[format]) return;\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"formatAt\", this).call(this, index, length, format, value);\n                            this.optimize();\n                        }\n                    },\n                    {\n                        key: \"insertAt\",\n                        value: function insertAt(index, value, def) {\n                            if (def != null && this.whitelist != null && !this.whitelist[value]) return;\n                            if (index >= this.length()) {\n                                if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {\n                                    var blot = _parchment2.default.create(this.statics.defaultChild);\n                                    this.appendChild(blot);\n                                    if (def == null && value.endsWith(\"\\n\")) {\n                                        value = value.slice(0, -1);\n                                    }\n                                    blot.insertAt(0, value, def);\n                                } else {\n                                    var embed = _parchment2.default.create(value, def);\n                                    this.appendChild(embed);\n                                }\n                            } else {\n                                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"insertAt\", this).call(this, index, value, def);\n                            }\n                            this.optimize();\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(blot, ref) {\n                            if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {\n                                var wrapper = _parchment2.default.create(this.statics.defaultChild);\n                                wrapper.appendChild(blot);\n                                blot = wrapper;\n                            }\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"insertBefore\", this).call(this, blot, ref);\n                        }\n                    },\n                    {\n                        key: \"leaf\",\n                        value: function leaf(index) {\n                            return this.path(index).pop() || [\n                                null,\n                                -1\n                            ];\n                        }\n                    },\n                    {\n                        key: \"line\",\n                        value: function line(index) {\n                            if (index === this.length()) {\n                                return this.line(index - 1);\n                            }\n                            return this.descendant(isLine, index);\n                        }\n                    },\n                    {\n                        key: \"lines\",\n                        value: function lines() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n                            var getLines = function getLines(blot, index, length) {\n                                var lines = [], lengthLeft = length;\n                                blot.children.forEachAt(index, length, function(child, index, length) {\n                                    if (isLine(child)) {\n                                        lines.push(child);\n                                    } else if (child instanceof _parchment2.default.Container) {\n                                        lines = lines.concat(getLines(child, index, lengthLeft));\n                                    }\n                                    lengthLeft -= length;\n                                });\n                                return lines;\n                            };\n                            return getLines(this, index, length);\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize() {\n                            var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n                            var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            if (this.batch === true) return;\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"optimize\", this).call(this, mutations, context);\n                            if (mutations.length > 0) {\n                                this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);\n                            }\n                        }\n                    },\n                    {\n                        key: \"path\",\n                        value: function path(index) {\n                            return _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"path\", this).call(this, index).slice(1); // Exclude self\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(mutations) {\n                            if (this.batch === true) return;\n                            var source = _emitter2.default.sources.USER;\n                            if (typeof mutations === \"string\") {\n                                source = mutations;\n                            }\n                            if (!Array.isArray(mutations)) {\n                                mutations = this.observer.takeRecords();\n                            }\n                            if (mutations.length > 0) {\n                                this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);\n                            }\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"update\", this).call(this, mutations.concat([])); // pass copy\n                            if (mutations.length > 0) {\n                                this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);\n                            }\n                        }\n                    }\n                ]);\n                return Scroll;\n            }(_parchment2.default.Scroll);\n            Scroll.blotName = \"scroll\";\n            Scroll.className = \"ql-editor\";\n            Scroll.tagName = \"DIV\";\n            Scroll.defaultChild = \"block\";\n            Scroll.allowedChildren = [\n                _block2.default,\n                _block.BlockEmbed,\n                _container2.default\n            ];\n            exports1.default = Scroll;\n        /***/ },\n        /* 23 */ /***/ function(module1, exports1, __nested_webpack_require_238907__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.SHORTKEY = exports1.default = undefined;\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _clone = __nested_webpack_require_238907__(21);\n            var _clone2 = _interopRequireDefault(_clone);\n            var _deepEqual = __nested_webpack_require_238907__(11);\n            var _deepEqual2 = _interopRequireDefault(_deepEqual);\n            var _extend = __nested_webpack_require_238907__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _quillDelta = __nested_webpack_require_238907__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _op = __nested_webpack_require_238907__(20);\n            var _op2 = _interopRequireDefault(_op);\n            var _parchment = __nested_webpack_require_238907__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_238907__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _logger = __nested_webpack_require_238907__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            var _module = __nested_webpack_require_238907__(9);\n            var _module2 = _interopRequireDefault(_module);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var debug = (0, _logger2.default)(\"quill:keyboard\");\n            var SHORTKEY = /Mac/i.test(navigator.platform) ? \"metaKey\" : \"ctrlKey\";\n            var Keyboard = function(_Module) {\n                _inherits(Keyboard, _Module);\n                _createClass(Keyboard, null, [\n                    {\n                        key: \"match\",\n                        value: function match(evt, binding) {\n                            binding = normalize(binding);\n                            if ([\n                                \"altKey\",\n                                \"ctrlKey\",\n                                \"metaKey\",\n                                \"shiftKey\"\n                            ].some(function(key) {\n                                return !!binding[key] !== evt[key] && binding[key] !== null;\n                            })) {\n                                return false;\n                            }\n                            return binding.key === (evt.which || evt.keyCode);\n                        }\n                    }\n                ]);\n                function Keyboard(quill, options) {\n                    _classCallCheck(this, Keyboard);\n                    var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this, quill, options));\n                    _this.bindings = {};\n                    Object.keys(_this.options.bindings).forEach(function(name) {\n                        if (name === \"list autofill\" && quill.scroll.whitelist != null && !quill.scroll.whitelist[\"list\"]) {\n                            return;\n                        }\n                        if (_this.options.bindings[name]) {\n                            _this.addBinding(_this.options.bindings[name]);\n                        }\n                    });\n                    _this.addBinding({\n                        key: Keyboard.keys.ENTER,\n                        shiftKey: null\n                    }, handleEnter);\n                    _this.addBinding({\n                        key: Keyboard.keys.ENTER,\n                        metaKey: null,\n                        ctrlKey: null,\n                        altKey: null\n                    }, function() {});\n                    if (/Firefox/i.test(navigator.userAgent)) {\n                        // Need to handle delete and backspace for Firefox in the general case #1171\n                        _this.addBinding({\n                            key: Keyboard.keys.BACKSPACE\n                        }, {\n                            collapsed: true\n                        }, handleBackspace);\n                        _this.addBinding({\n                            key: Keyboard.keys.DELETE\n                        }, {\n                            collapsed: true\n                        }, handleDelete);\n                    } else {\n                        _this.addBinding({\n                            key: Keyboard.keys.BACKSPACE\n                        }, {\n                            collapsed: true,\n                            prefix: /^.?$/\n                        }, handleBackspace);\n                        _this.addBinding({\n                            key: Keyboard.keys.DELETE\n                        }, {\n                            collapsed: true,\n                            suffix: /^.?$/\n                        }, handleDelete);\n                    }\n                    _this.addBinding({\n                        key: Keyboard.keys.BACKSPACE\n                    }, {\n                        collapsed: false\n                    }, handleDeleteRange);\n                    _this.addBinding({\n                        key: Keyboard.keys.DELETE\n                    }, {\n                        collapsed: false\n                    }, handleDeleteRange);\n                    _this.addBinding({\n                        key: Keyboard.keys.BACKSPACE,\n                        altKey: null,\n                        ctrlKey: null,\n                        metaKey: null,\n                        shiftKey: null\n                    }, {\n                        collapsed: true,\n                        offset: 0\n                    }, handleBackspace);\n                    _this.listen();\n                    return _this;\n                }\n                _createClass(Keyboard, [\n                    {\n                        key: \"addBinding\",\n                        value: function addBinding(key) {\n                            var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            var binding = normalize(key);\n                            if (binding == null || binding.key == null) {\n                                return debug.warn(\"Attempted to add invalid keyboard binding\", binding);\n                            }\n                            if (typeof context === \"function\") {\n                                context = {\n                                    handler: context\n                                };\n                            }\n                            if (typeof handler === \"function\") {\n                                handler = {\n                                    handler: handler\n                                };\n                            }\n                            binding = (0, _extend2.default)(binding, context, handler);\n                            this.bindings[binding.key] = this.bindings[binding.key] || [];\n                            this.bindings[binding.key].push(binding);\n                        }\n                    },\n                    {\n                        key: \"listen\",\n                        value: function listen() {\n                            var _this2 = this;\n                            this.quill.root.addEventListener(\"keydown\", function(evt) {\n                                if (evt.defaultPrevented) return;\n                                var which = evt.which || evt.keyCode;\n                                var bindings = (_this2.bindings[which] || []).filter(function(binding) {\n                                    return Keyboard.match(evt, binding);\n                                });\n                                if (bindings.length === 0) return;\n                                var range = _this2.quill.getSelection();\n                                if (range == null || !_this2.quill.hasFocus()) return;\n                                var _quill$getLine = _this2.quill.getLine(range.index), _quill$getLine2 = _slicedToArray(_quill$getLine, 2), line = _quill$getLine2[0], offset = _quill$getLine2[1];\n                                var _quill$getLeaf = _this2.quill.getLeaf(range.index), _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2), leafStart = _quill$getLeaf2[0], offsetStart = _quill$getLeaf2[1];\n                                var _ref = range.length === 0 ? [\n                                    leafStart,\n                                    offsetStart\n                                ] : _this2.quill.getLeaf(range.index + range.length), _ref2 = _slicedToArray(_ref, 2), leafEnd = _ref2[0], offsetEnd = _ref2[1];\n                                var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : \"\";\n                                var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : \"\";\n                                var curContext = {\n                                    collapsed: range.length === 0,\n                                    empty: range.length === 0 && line.length() <= 1,\n                                    format: _this2.quill.getFormat(range),\n                                    offset: offset,\n                                    prefix: prefixText,\n                                    suffix: suffixText\n                                };\n                                var prevented = bindings.some(function(binding) {\n                                    if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;\n                                    if (binding.empty != null && binding.empty !== curContext.empty) return false;\n                                    if (binding.offset != null && binding.offset !== curContext.offset) return false;\n                                    if (Array.isArray(binding.format)) {\n                                        // any format is present\n                                        if (binding.format.every(function(name) {\n                                            return curContext.format[name] == null;\n                                        })) {\n                                            return false;\n                                        }\n                                    } else if (_typeof(binding.format) === \"object\") {\n                                        // all formats must match\n                                        if (!Object.keys(binding.format).every(function(name) {\n                                            if (binding.format[name] === true) return curContext.format[name] != null;\n                                            if (binding.format[name] === false) return curContext.format[name] == null;\n                                            return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);\n                                        })) {\n                                            return false;\n                                        }\n                                    }\n                                    if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;\n                                    if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;\n                                    return binding.handler.call(_this2, range, curContext) !== true;\n                                });\n                                if (prevented) {\n                                    evt.preventDefault();\n                                }\n                            });\n                        }\n                    }\n                ]);\n                return Keyboard;\n            }(_module2.default);\n            Keyboard.keys = {\n                BACKSPACE: 8,\n                TAB: 9,\n                ENTER: 13,\n                ESCAPE: 27,\n                LEFT: 37,\n                UP: 38,\n                RIGHT: 39,\n                DOWN: 40,\n                DELETE: 46\n            };\n            Keyboard.DEFAULTS = {\n                bindings: {\n                    \"bold\": makeFormatHandler(\"bold\"),\n                    \"italic\": makeFormatHandler(\"italic\"),\n                    \"underline\": makeFormatHandler(\"underline\"),\n                    \"indent\": {\n                        // highlight tab or tab at beginning of list, indent or blockquote\n                        key: Keyboard.keys.TAB,\n                        format: [\n                            \"blockquote\",\n                            \"indent\",\n                            \"list\"\n                        ],\n                        handler: function handler(range, context) {\n                            if (context.collapsed && context.offset !== 0) return true;\n                            this.quill.format(\"indent\", \"+1\", _quill2.default.sources.USER);\n                        }\n                    },\n                    \"outdent\": {\n                        key: Keyboard.keys.TAB,\n                        shiftKey: true,\n                        format: [\n                            \"blockquote\",\n                            \"indent\",\n                            \"list\"\n                        ],\n                        // highlight tab or tab at beginning of list, indent or blockquote\n                        handler: function handler(range, context) {\n                            if (context.collapsed && context.offset !== 0) return true;\n                            this.quill.format(\"indent\", \"-1\", _quill2.default.sources.USER);\n                        }\n                    },\n                    \"outdent backspace\": {\n                        key: Keyboard.keys.BACKSPACE,\n                        collapsed: true,\n                        shiftKey: null,\n                        metaKey: null,\n                        ctrlKey: null,\n                        altKey: null,\n                        format: [\n                            \"indent\",\n                            \"list\"\n                        ],\n                        offset: 0,\n                        handler: function handler(range, context) {\n                            if (context.format.indent != null) {\n                                this.quill.format(\"indent\", \"-1\", _quill2.default.sources.USER);\n                            } else if (context.format.list != null) {\n                                this.quill.format(\"list\", false, _quill2.default.sources.USER);\n                            }\n                        }\n                    },\n                    \"indent code-block\": makeCodeBlockHandler(true),\n                    \"outdent code-block\": makeCodeBlockHandler(false),\n                    \"remove tab\": {\n                        key: Keyboard.keys.TAB,\n                        shiftKey: true,\n                        collapsed: true,\n                        prefix: /\\t$/,\n                        handler: function handler(range) {\n                            this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);\n                        }\n                    },\n                    \"tab\": {\n                        key: Keyboard.keys.TAB,\n                        handler: function handler(range) {\n                            this.quill.history.cutoff();\n                            var delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert(\"\t\");\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                            this.quill.history.cutoff();\n                            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n                        }\n                    },\n                    \"list empty enter\": {\n                        key: Keyboard.keys.ENTER,\n                        collapsed: true,\n                        format: [\n                            \"list\"\n                        ],\n                        empty: true,\n                        handler: function handler(range, context) {\n                            this.quill.format(\"list\", false, _quill2.default.sources.USER);\n                            if (context.format.indent) {\n                                this.quill.format(\"indent\", false, _quill2.default.sources.USER);\n                            }\n                        }\n                    },\n                    \"checklist enter\": {\n                        key: Keyboard.keys.ENTER,\n                        collapsed: true,\n                        format: {\n                            list: \"checked\"\n                        },\n                        handler: function handler(range) {\n                            var _quill$getLine3 = this.quill.getLine(range.index), _quill$getLine4 = _slicedToArray(_quill$getLine3, 2), line = _quill$getLine4[0], offset = _quill$getLine4[1];\n                            var formats = (0, _extend2.default)({}, line.formats(), {\n                                list: \"checked\"\n                            });\n                            var delta = new _quillDelta2.default().retain(range.index).insert(\"\\n\", formats).retain(line.length() - offset - 1).retain(1, {\n                                list: \"unchecked\"\n                            });\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n                            this.quill.scrollIntoView();\n                        }\n                    },\n                    \"header enter\": {\n                        key: Keyboard.keys.ENTER,\n                        collapsed: true,\n                        format: [\n                            \"header\"\n                        ],\n                        suffix: /^$/,\n                        handler: function handler(range, context) {\n                            var _quill$getLine5 = this.quill.getLine(range.index), _quill$getLine6 = _slicedToArray(_quill$getLine5, 2), line = _quill$getLine6[0], offset = _quill$getLine6[1];\n                            var delta = new _quillDelta2.default().retain(range.index).insert(\"\\n\", context.format).retain(line.length() - offset - 1).retain(1, {\n                                header: null\n                            });\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n                            this.quill.scrollIntoView();\n                        }\n                    },\n                    \"list autofill\": {\n                        key: \" \",\n                        collapsed: true,\n                        format: {\n                            list: false\n                        },\n                        prefix: /^\\s*?(\\d+\\.|-|\\*|\\[ ?\\]|\\[x\\])$/,\n                        handler: function handler(range, context) {\n                            var length = context.prefix.length;\n                            var _quill$getLine7 = this.quill.getLine(range.index), _quill$getLine8 = _slicedToArray(_quill$getLine7, 2), line = _quill$getLine8[0], offset = _quill$getLine8[1];\n                            if (offset > length) return true;\n                            var value = void 0;\n                            switch(context.prefix.trim()){\n                                case \"[]\":\n                                case \"[ ]\":\n                                    value = \"unchecked\";\n                                    break;\n                                case \"[x]\":\n                                    value = \"checked\";\n                                    break;\n                                case \"-\":\n                                case \"*\":\n                                    value = \"bullet\";\n                                    break;\n                                default:\n                                    value = \"ordered\";\n                            }\n                            this.quill.insertText(range.index, \" \", _quill2.default.sources.USER);\n                            this.quill.history.cutoff();\n                            var delta = new _quillDelta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {\n                                list: value\n                            });\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                            this.quill.history.cutoff();\n                            this.quill.setSelection(range.index - length, _quill2.default.sources.SILENT);\n                        }\n                    },\n                    \"code exit\": {\n                        key: Keyboard.keys.ENTER,\n                        collapsed: true,\n                        format: [\n                            \"code-block\"\n                        ],\n                        prefix: /\\n\\n$/,\n                        suffix: /^\\s+$/,\n                        handler: function handler(range) {\n                            var _quill$getLine9 = this.quill.getLine(range.index), _quill$getLine10 = _slicedToArray(_quill$getLine9, 2), line = _quill$getLine10[0], offset = _quill$getLine10[1];\n                            var delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, {\n                                \"code-block\": null\n                            }).delete(1);\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                        }\n                    },\n                    \"embed left\": makeEmbedArrowHandler(Keyboard.keys.LEFT, false),\n                    \"embed left shift\": makeEmbedArrowHandler(Keyboard.keys.LEFT, true),\n                    \"embed right\": makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),\n                    \"embed right shift\": makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)\n                }\n            };\n            function makeEmbedArrowHandler(key, shiftKey) {\n                var _ref3;\n                var where = key === Keyboard.keys.LEFT ? \"prefix\" : \"suffix\";\n                return _ref3 = {\n                    key: key,\n                    shiftKey: shiftKey,\n                    altKey: null\n                }, _defineProperty(_ref3, where, /^$/), _defineProperty(_ref3, \"handler\", function handler(range) {\n                    var index = range.index;\n                    if (key === Keyboard.keys.RIGHT) {\n                        index += range.length + 1;\n                    }\n                    var _quill$getLeaf3 = this.quill.getLeaf(index), _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1), leaf = _quill$getLeaf4[0];\n                    if (!(leaf instanceof _parchment2.default.Embed)) return true;\n                    if (key === Keyboard.keys.LEFT) {\n                        if (shiftKey) {\n                            this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);\n                        } else {\n                            this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);\n                        }\n                    } else {\n                        if (shiftKey) {\n                            this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);\n                        } else {\n                            this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);\n                        }\n                    }\n                    return false;\n                }), _ref3;\n            }\n            function handleBackspace(range, context) {\n                if (range.index === 0 || this.quill.getLength() <= 1) return;\n                var _quill$getLine11 = this.quill.getLine(range.index), _quill$getLine12 = _slicedToArray(_quill$getLine11, 1), line = _quill$getLine12[0];\n                var formats = {};\n                if (context.offset === 0) {\n                    var _quill$getLine13 = this.quill.getLine(range.index - 1), _quill$getLine14 = _slicedToArray(_quill$getLine13, 1), prev = _quill$getLine14[0];\n                    if (prev != null && prev.length() > 1) {\n                        var curFormats = line.formats();\n                        var prevFormats = this.quill.getFormat(range.index - 1, 1);\n                        formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};\n                    }\n                }\n                // Check for astral symbols\n                var length = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$/.test(context.prefix) ? 2 : 1;\n                this.quill.deleteText(range.index - length, length, _quill2.default.sources.USER);\n                if (Object.keys(formats).length > 0) {\n                    this.quill.formatLine(range.index - length, length, formats, _quill2.default.sources.USER);\n                }\n                this.quill.focus();\n            }\n            function handleDelete(range, context) {\n                // Check for astral symbols\n                var length = /^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/.test(context.suffix) ? 2 : 1;\n                if (range.index >= this.quill.getLength() - length) return;\n                var formats = {}, nextLength = 0;\n                var _quill$getLine15 = this.quill.getLine(range.index), _quill$getLine16 = _slicedToArray(_quill$getLine15, 1), line = _quill$getLine16[0];\n                if (context.offset >= line.length() - 1) {\n                    var _quill$getLine17 = this.quill.getLine(range.index + 1), _quill$getLine18 = _slicedToArray(_quill$getLine17, 1), next = _quill$getLine18[0];\n                    if (next) {\n                        var curFormats = line.formats();\n                        var nextFormats = this.quill.getFormat(range.index, 1);\n                        formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};\n                        nextLength = next.length();\n                    }\n                }\n                this.quill.deleteText(range.index, length, _quill2.default.sources.USER);\n                if (Object.keys(formats).length > 0) {\n                    this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2.default.sources.USER);\n                }\n            }\n            function handleDeleteRange(range) {\n                var lines = this.quill.getLines(range);\n                var formats = {};\n                if (lines.length > 1) {\n                    var firstFormats = lines[0].formats();\n                    var lastFormats = lines[lines.length - 1].formats();\n                    formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};\n                }\n                this.quill.deleteText(range, _quill2.default.sources.USER);\n                if (Object.keys(formats).length > 0) {\n                    this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);\n                }\n                this.quill.setSelection(range.index, _quill2.default.sources.SILENT);\n                this.quill.focus();\n            }\n            function handleEnter(range, context) {\n                var _this3 = this;\n                if (range.length > 0) {\n                    this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change\n                }\n                var lineFormats = Object.keys(context.format).reduce(function(lineFormats, format) {\n                    if (_parchment2.default.query(format, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format])) {\n                        lineFormats[format] = context.format[format];\n                    }\n                    return lineFormats;\n                }, {});\n                this.quill.insertText(range.index, \"\\n\", lineFormats, _quill2.default.sources.USER);\n                // Earlier scroll.deleteAt might have messed up our selection,\n                // so insertText's built in selection preservation is not reliable\n                this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n                this.quill.focus();\n                Object.keys(context.format).forEach(function(name) {\n                    if (lineFormats[name] != null) return;\n                    if (Array.isArray(context.format[name])) return;\n                    if (name === \"link\") return;\n                    _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);\n                });\n            }\n            function makeCodeBlockHandler(indent) {\n                return {\n                    key: Keyboard.keys.TAB,\n                    shiftKey: !indent,\n                    format: {\n                        \"code-block\": true\n                    },\n                    handler: function handler(range) {\n                        var CodeBlock = _parchment2.default.query(\"code-block\");\n                        var index = range.index, length = range.length;\n                        var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index), _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2), block = _quill$scroll$descend2[0], offset = _quill$scroll$descend2[1];\n                        if (block == null) return;\n                        var scrollIndex = this.quill.getIndex(block);\n                        var start = block.newlineIndex(offset, true) + 1;\n                        var end = block.newlineIndex(scrollIndex + offset + length);\n                        var lines = block.domNode.textContent.slice(start, end).split(\"\\n\");\n                        offset = 0;\n                        lines.forEach(function(line, i) {\n                            if (indent) {\n                                block.insertAt(start + offset, CodeBlock.TAB);\n                                offset += CodeBlock.TAB.length;\n                                if (i === 0) {\n                                    index += CodeBlock.TAB.length;\n                                } else {\n                                    length += CodeBlock.TAB.length;\n                                }\n                            } else if (line.startsWith(CodeBlock.TAB)) {\n                                block.deleteAt(start + offset, CodeBlock.TAB.length);\n                                offset -= CodeBlock.TAB.length;\n                                if (i === 0) {\n                                    index -= CodeBlock.TAB.length;\n                                } else {\n                                    length -= CodeBlock.TAB.length;\n                                }\n                            }\n                            offset += line.length + 1;\n                        });\n                        this.quill.update(_quill2.default.sources.USER);\n                        this.quill.setSelection(index, length, _quill2.default.sources.SILENT);\n                    }\n                };\n            }\n            function makeFormatHandler(format) {\n                return {\n                    key: format[0].toUpperCase(),\n                    shortKey: true,\n                    handler: function handler(range, context) {\n                        this.quill.format(format, !context.format[format], _quill2.default.sources.USER);\n                    }\n                };\n            }\n            function normalize(binding) {\n                if (typeof binding === \"string\" || typeof binding === \"number\") {\n                    return normalize({\n                        key: binding\n                    });\n                }\n                if ((typeof binding === \"undefined\" ? \"undefined\" : _typeof(binding)) === \"object\") {\n                    binding = (0, _clone2.default)(binding, false);\n                }\n                if (typeof binding.key === \"string\") {\n                    if (Keyboard.keys[binding.key.toUpperCase()] != null) {\n                        binding.key = Keyboard.keys[binding.key.toUpperCase()];\n                    } else if (binding.key.length === 1) {\n                        binding.key = binding.key.toUpperCase().charCodeAt(0);\n                    } else {\n                        return null;\n                    }\n                }\n                if (binding.shortKey) {\n                    binding[SHORTKEY] = binding.shortKey;\n                    delete binding.shortKey;\n                }\n                return binding;\n            }\n            exports1.default = Keyboard;\n            exports1.SHORTKEY = SHORTKEY;\n        /***/ },\n        /* 24 */ /***/ function(module1, exports1, __nested_webpack_require_275910__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _parchment = __nested_webpack_require_275910__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _text = __nested_webpack_require_275910__(7);\n            var _text2 = _interopRequireDefault(_text);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Cursor = function(_Parchment$Embed) {\n                _inherits(Cursor, _Parchment$Embed);\n                _createClass(Cursor, null, [\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return undefined;\n                        }\n                    }\n                ]);\n                function Cursor(domNode, selection) {\n                    _classCallCheck(this, Cursor);\n                    var _this = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, domNode));\n                    _this.selection = selection;\n                    _this.textNode = document.createTextNode(Cursor.CONTENTS);\n                    _this.domNode.appendChild(_this.textNode);\n                    _this._length = 0;\n                    return _this;\n                }\n                _createClass(Cursor, [\n                    {\n                        key: \"detach\",\n                        value: function detach() {\n                            // super.detach() will also clear domNode.__blot\n                            if (this.parent != null) this.parent.removeChild(this);\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (this._length !== 0) {\n                                return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), \"format\", this).call(this, name, value);\n                            }\n                            var target = this, index = 0;\n                            while(target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT){\n                                index += target.offset(target.parent);\n                                target = target.parent;\n                            }\n                            if (target != null) {\n                                this._length = Cursor.CONTENTS.length;\n                                target.optimize();\n                                target.formatAt(index, Cursor.CONTENTS.length, name, value);\n                                this._length = 0;\n                            }\n                        }\n                    },\n                    {\n                        key: \"index\",\n                        value: function index(node, offset) {\n                            if (node === this.textNode) return 0;\n                            return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), \"index\", this).call(this, node, offset);\n                        }\n                    },\n                    {\n                        key: \"length\",\n                        value: function length() {\n                            return this._length;\n                        }\n                    },\n                    {\n                        key: \"position\",\n                        value: function position() {\n                            return [\n                                this.textNode,\n                                this.textNode.data.length\n                            ];\n                        }\n                    },\n                    {\n                        key: \"remove\",\n                        value: function remove() {\n                            _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), \"remove\", this).call(this);\n                            this.parent = null;\n                        }\n                    },\n                    {\n                        key: \"restore\",\n                        value: function restore() {\n                            if (this.selection.composing || this.parent == null) return;\n                            var textNode = this.textNode;\n                            var range = this.selection.getNativeRange();\n                            var restoreText = void 0, start = void 0, end = void 0;\n                            if (range != null && range.start.node === textNode && range.end.node === textNode) {\n                                var _ref = [\n                                    textNode,\n                                    range.start.offset,\n                                    range.end.offset\n                                ];\n                                restoreText = _ref[0];\n                                start = _ref[1];\n                                end = _ref[2];\n                            }\n                            // Link format will insert text outside of anchor tag\n                            while(this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode){\n                                this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);\n                            }\n                            if (this.textNode.data !== Cursor.CONTENTS) {\n                                var text = this.textNode.data.split(Cursor.CONTENTS).join(\"\");\n                                if (this.next instanceof _text2.default) {\n                                    restoreText = this.next.domNode;\n                                    this.next.insertAt(0, text);\n                                    this.textNode.data = Cursor.CONTENTS;\n                                } else {\n                                    this.textNode.data = text;\n                                    this.parent.insertBefore(_parchment2.default.create(this.textNode), this);\n                                    this.textNode = document.createTextNode(Cursor.CONTENTS);\n                                    this.domNode.appendChild(this.textNode);\n                                }\n                            }\n                            this.remove();\n                            if (start != null) {\n                                var _map = [\n                                    start,\n                                    end\n                                ].map(function(offset) {\n                                    return Math.max(0, Math.min(restoreText.data.length, offset - 1));\n                                });\n                                var _map2 = _slicedToArray(_map, 2);\n                                start = _map2[0];\n                                end = _map2[1];\n                                return {\n                                    startNode: restoreText,\n                                    startOffset: start,\n                                    endNode: restoreText,\n                                    endOffset: end\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(mutations, context) {\n                            var _this2 = this;\n                            if (mutations.some(function(mutation) {\n                                return mutation.type === \"characterData\" && mutation.target === _this2.textNode;\n                            })) {\n                                var range = this.restore();\n                                if (range) context.range = range;\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return \"\";\n                        }\n                    }\n                ]);\n                return Cursor;\n            }(_parchment2.default.Embed);\n            Cursor.blotName = \"cursor\";\n            Cursor.className = \"ql-cursor\";\n            Cursor.tagName = \"span\";\n            Cursor.CONTENTS = \"\\uFEFF\"; // Zero width no break space\n            exports1.default = Cursor;\n        /***/ },\n        /* 25 */ /***/ function(module1, exports1, __nested_webpack_require_288827__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _parchment = __nested_webpack_require_288827__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _block = __nested_webpack_require_288827__(4);\n            var _block2 = _interopRequireDefault(_block);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Container = function(_Parchment$Container) {\n                _inherits(Container, _Parchment$Container);\n                function Container() {\n                    _classCallCheck(this, Container);\n                    return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));\n                }\n                return Container;\n            }(_parchment2.default.Container);\n            Container.allowedChildren = [\n                _block2.default,\n                _block.BlockEmbed,\n                Container\n            ];\n            exports1.default = Container;\n        /***/ },\n        /* 26 */ /***/ function(module1, exports1, __nested_webpack_require_291415__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.ColorStyle = exports1.ColorClass = exports1.ColorAttributor = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_291415__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ColorAttributor = function(_Parchment$Attributor) {\n                _inherits(ColorAttributor, _Parchment$Attributor);\n                function ColorAttributor() {\n                    _classCallCheck(this, ColorAttributor);\n                    return _possibleConstructorReturn(this, (ColorAttributor.__proto__ || Object.getPrototypeOf(ColorAttributor)).apply(this, arguments));\n                }\n                _createClass(ColorAttributor, [\n                    {\n                        key: \"value\",\n                        value: function value(domNode) {\n                            var value = _get(ColorAttributor.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor.prototype), \"value\", this).call(this, domNode);\n                            if (!value.startsWith(\"rgb(\")) return value;\n                            value = value.replace(/^[^\\d]+/, \"\").replace(/[^\\d]+$/, \"\");\n                            return \"#\" + value.split(\",\").map(function(component) {\n                                return (\"00\" + parseInt(component).toString(16)).slice(-2);\n                            }).join(\"\");\n                        }\n                    }\n                ]);\n                return ColorAttributor;\n            }(_parchment2.default.Attributor.Style);\n            var ColorClass = new _parchment2.default.Attributor.Class(\"color\", \"ql-color\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            var ColorStyle = new ColorAttributor(\"color\", \"color\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            exports1.ColorAttributor = ColorAttributor;\n            exports1.ColorClass = ColorClass;\n            exports1.ColorStyle = ColorStyle;\n        /***/ },\n        /* 27 */ /***/ function(module1, exports1, __nested_webpack_require_296817__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.sanitize = exports1.default = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _inline = __nested_webpack_require_296817__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Link = function(_Inline) {\n                _inherits(Link, _Inline);\n                function Link() {\n                    _classCallCheck(this, Link);\n                    return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));\n                }\n                _createClass(Link, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (name !== this.statics.blotName || !value) return _get(Link.prototype.__proto__ || Object.getPrototypeOf(Link.prototype), \"format\", this).call(this, name, value);\n                            value = this.constructor.sanitize(value);\n                            this.domNode.setAttribute(\"href\", value);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var node = _get(Link.__proto__ || Object.getPrototypeOf(Link), \"create\", this).call(this, value);\n                            value = this.sanitize(value);\n                            node.setAttribute(\"href\", value);\n                            node.setAttribute(\"rel\", \"noopener noreferrer\");\n                            node.setAttribute(\"target\", \"_blank\");\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return domNode.getAttribute(\"href\");\n                        }\n                    },\n                    {\n                        key: \"sanitize\",\n                        value: function sanitize(url) {\n                            return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;\n                        }\n                    }\n                ]);\n                return Link;\n            }(_inline2.default);\n            Link.blotName = \"link\";\n            Link.tagName = \"A\";\n            Link.SANITIZED_URL = \"about:blank\";\n            Link.PROTOCOL_WHITELIST = [\n                \"http\",\n                \"https\",\n                \"mailto\",\n                \"tel\"\n            ];\n            function _sanitize(url, protocols) {\n                var anchor = document.createElement(\"a\");\n                anchor.href = url;\n                var protocol = anchor.href.slice(0, anchor.href.indexOf(\":\"));\n                return protocols.indexOf(protocol) > -1;\n            }\n            exports1.default = Link;\n            exports1.sanitize = _sanitize;\n        /***/ },\n        /* 28 */ /***/ function(module1, exports1, __nested_webpack_require_303142__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _keyboard = __nested_webpack_require_303142__(23);\n            var _keyboard2 = _interopRequireDefault(_keyboard);\n            var _dropdown = __nested_webpack_require_303142__(107);\n            var _dropdown2 = _interopRequireDefault(_dropdown);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var optionsCounter = 0;\n            function toggleAriaAttribute(element, attribute) {\n                element.setAttribute(attribute, !(element.getAttribute(attribute) === \"true\"));\n            }\n            var Picker = function() {\n                function Picker(select) {\n                    var _this = this;\n                    _classCallCheck(this, Picker);\n                    this.select = select;\n                    this.container = document.createElement(\"span\");\n                    this.buildPicker();\n                    this.select.style.display = \"none\";\n                    this.select.parentNode.insertBefore(this.container, this.select);\n                    this.label.addEventListener(\"mousedown\", function() {\n                        _this.togglePicker();\n                    });\n                    this.label.addEventListener(\"keydown\", function(event) {\n                        switch(event.keyCode){\n                            // Allows the \"Enter\" key to open the picker\n                            case _keyboard2.default.keys.ENTER:\n                                _this.togglePicker();\n                                break;\n                            // Allows the \"Escape\" key to close the picker\n                            case _keyboard2.default.keys.ESCAPE:\n                                _this.escape();\n                                event.preventDefault();\n                                break;\n                            default:\n                        }\n                    });\n                    this.select.addEventListener(\"change\", this.update.bind(this));\n                }\n                _createClass(Picker, [\n                    {\n                        key: \"togglePicker\",\n                        value: function togglePicker() {\n                            this.container.classList.toggle(\"ql-expanded\");\n                            // Toggle aria-expanded and aria-hidden to make the picker accessible\n                            toggleAriaAttribute(this.label, \"aria-expanded\");\n                            toggleAriaAttribute(this.options, \"aria-hidden\");\n                        }\n                    },\n                    {\n                        key: \"buildItem\",\n                        value: function buildItem(option) {\n                            var _this2 = this;\n                            var item = document.createElement(\"span\");\n                            item.tabIndex = \"0\";\n                            item.setAttribute(\"role\", \"button\");\n                            item.classList.add(\"ql-picker-item\");\n                            if (option.hasAttribute(\"value\")) {\n                                item.setAttribute(\"data-value\", option.getAttribute(\"value\"));\n                            }\n                            if (option.textContent) {\n                                item.setAttribute(\"data-label\", option.textContent);\n                            }\n                            item.addEventListener(\"click\", function() {\n                                _this2.selectItem(item, true);\n                            });\n                            item.addEventListener(\"keydown\", function(event) {\n                                switch(event.keyCode){\n                                    // Allows the \"Enter\" key to select an item\n                                    case _keyboard2.default.keys.ENTER:\n                                        _this2.selectItem(item, true);\n                                        event.preventDefault();\n                                        break;\n                                    // Allows the \"Escape\" key to close the picker\n                                    case _keyboard2.default.keys.ESCAPE:\n                                        _this2.escape();\n                                        event.preventDefault();\n                                        break;\n                                    default:\n                                }\n                            });\n                            return item;\n                        }\n                    },\n                    {\n                        key: \"buildLabel\",\n                        value: function buildLabel() {\n                            var label = document.createElement(\"span\");\n                            label.classList.add(\"ql-picker-label\");\n                            label.innerHTML = _dropdown2.default;\n                            label.tabIndex = \"0\";\n                            label.setAttribute(\"role\", \"button\");\n                            label.setAttribute(\"aria-expanded\", \"false\");\n                            this.container.appendChild(label);\n                            return label;\n                        }\n                    },\n                    {\n                        key: \"buildOptions\",\n                        value: function buildOptions() {\n                            var _this3 = this;\n                            var options = document.createElement(\"span\");\n                            options.classList.add(\"ql-picker-options\");\n                            // Don't want screen readers to read this until options are visible\n                            options.setAttribute(\"aria-hidden\", \"true\");\n                            options.tabIndex = \"-1\";\n                            // Need a unique id for aria-controls\n                            options.id = \"ql-picker-options-\" + optionsCounter;\n                            optionsCounter += 1;\n                            this.label.setAttribute(\"aria-controls\", options.id);\n                            this.options = options;\n                            [].slice.call(this.select.options).forEach(function(option) {\n                                var item = _this3.buildItem(option);\n                                options.appendChild(item);\n                                if (option.selected === true) {\n                                    _this3.selectItem(item);\n                                }\n                            });\n                            this.container.appendChild(options);\n                        }\n                    },\n                    {\n                        key: \"buildPicker\",\n                        value: function buildPicker() {\n                            var _this4 = this;\n                            [].slice.call(this.select.attributes).forEach(function(item) {\n                                _this4.container.setAttribute(item.name, item.value);\n                            });\n                            this.container.classList.add(\"ql-picker\");\n                            this.label = this.buildLabel();\n                            this.buildOptions();\n                        }\n                    },\n                    {\n                        key: \"escape\",\n                        value: function escape() {\n                            var _this5 = this;\n                            // Close menu and return focus to trigger label\n                            this.close();\n                            // Need setTimeout for accessibility to ensure that the browser executes\n                            // focus on the next process thread and after any DOM content changes\n                            setTimeout(function() {\n                                return _this5.label.focus();\n                            }, 1);\n                        }\n                    },\n                    {\n                        key: \"close\",\n                        value: function close() {\n                            this.container.classList.remove(\"ql-expanded\");\n                            this.label.setAttribute(\"aria-expanded\", \"false\");\n                            this.options.setAttribute(\"aria-hidden\", \"true\");\n                        }\n                    },\n                    {\n                        key: \"selectItem\",\n                        value: function selectItem(item) {\n                            var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                            var selected = this.container.querySelector(\".ql-selected\");\n                            if (item === selected) return;\n                            if (selected != null) {\n                                selected.classList.remove(\"ql-selected\");\n                            }\n                            if (item == null) return;\n                            item.classList.add(\"ql-selected\");\n                            this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);\n                            if (item.hasAttribute(\"data-value\")) {\n                                this.label.setAttribute(\"data-value\", item.getAttribute(\"data-value\"));\n                            } else {\n                                this.label.removeAttribute(\"data-value\");\n                            }\n                            if (item.hasAttribute(\"data-label\")) {\n                                this.label.setAttribute(\"data-label\", item.getAttribute(\"data-label\"));\n                            } else {\n                                this.label.removeAttribute(\"data-label\");\n                            }\n                            if (trigger) {\n                                if (typeof Event === \"function\") {\n                                    this.select.dispatchEvent(new Event(\"change\"));\n                                } else if ((typeof Event === \"undefined\" ? \"undefined\" : _typeof(Event)) === \"object\") {\n                                    // IE11\n                                    var event = document.createEvent(\"Event\");\n                                    event.initEvent(\"change\", true, true);\n                                    this.select.dispatchEvent(event);\n                                }\n                                this.close();\n                            }\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update() {\n                            var option = void 0;\n                            if (this.select.selectedIndex > -1) {\n                                var item = this.container.querySelector(\".ql-picker-options\").children[this.select.selectedIndex];\n                                option = this.select.options[this.select.selectedIndex];\n                                this.selectItem(item);\n                            } else {\n                                this.selectItem(null);\n                            }\n                            var isActive = option != null && option !== this.select.querySelector(\"option[selected]\");\n                            this.label.classList.toggle(\"ql-active\", isActive);\n                        }\n                    }\n                ]);\n                return Picker;\n            }();\n            exports1.default = Picker;\n        /***/ },\n        /* 29 */ /***/ function(module1, exports1, __nested_webpack_require_316172__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _parchment = __nested_webpack_require_316172__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_316172__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _block = __nested_webpack_require_316172__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _break = __nested_webpack_require_316172__(16);\n            var _break2 = _interopRequireDefault(_break);\n            var _container = __nested_webpack_require_316172__(25);\n            var _container2 = _interopRequireDefault(_container);\n            var _cursor = __nested_webpack_require_316172__(24);\n            var _cursor2 = _interopRequireDefault(_cursor);\n            var _embed = __nested_webpack_require_316172__(35);\n            var _embed2 = _interopRequireDefault(_embed);\n            var _inline = __nested_webpack_require_316172__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            var _scroll = __nested_webpack_require_316172__(22);\n            var _scroll2 = _interopRequireDefault(_scroll);\n            var _text = __nested_webpack_require_316172__(7);\n            var _text2 = _interopRequireDefault(_text);\n            var _clipboard = __nested_webpack_require_316172__(55);\n            var _clipboard2 = _interopRequireDefault(_clipboard);\n            var _history = __nested_webpack_require_316172__(42);\n            var _history2 = _interopRequireDefault(_history);\n            var _keyboard = __nested_webpack_require_316172__(23);\n            var _keyboard2 = _interopRequireDefault(_keyboard);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            _quill2.default.register({\n                \"blots/block\": _block2.default,\n                \"blots/block/embed\": _block.BlockEmbed,\n                \"blots/break\": _break2.default,\n                \"blots/container\": _container2.default,\n                \"blots/cursor\": _cursor2.default,\n                \"blots/embed\": _embed2.default,\n                \"blots/inline\": _inline2.default,\n                \"blots/scroll\": _scroll2.default,\n                \"blots/text\": _text2.default,\n                \"modules/clipboard\": _clipboard2.default,\n                \"modules/history\": _history2.default,\n                \"modules/keyboard\": _keyboard2.default\n            });\n            _parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);\n            exports1.default = _quill2.default;\n        /***/ },\n        /* 30 */ /***/ function(module1, exports1, __nested_webpack_require_318889__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var Registry = __nested_webpack_require_318889__(1);\n            var ShadowBlot = /** @class */ function() {\n                function ShadowBlot(domNode) {\n                    this.domNode = domNode;\n                    // @ts-ignore\n                    this.domNode[Registry.DATA_KEY] = {\n                        blot: this\n                    };\n                }\n                Object.defineProperty(ShadowBlot.prototype, \"statics\", {\n                    // Hack for accessing inherited static methods\n                    get: function() {\n                        return this.constructor;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                ShadowBlot.create = function(value) {\n                    if (this.tagName == null) {\n                        throw new Registry.ParchmentError(\"Blot definition missing tagName\");\n                    }\n                    var node;\n                    if (Array.isArray(this.tagName)) {\n                        if (typeof value === \"string\") {\n                            value = value.toUpperCase();\n                            if (parseInt(value).toString() === value) {\n                                value = parseInt(value);\n                            }\n                        }\n                        if (typeof value === \"number\") {\n                            node = document.createElement(this.tagName[value - 1]);\n                        } else if (this.tagName.indexOf(value) > -1) {\n                            node = document.createElement(value);\n                        } else {\n                            node = document.createElement(this.tagName[0]);\n                        }\n                    } else {\n                        node = document.createElement(this.tagName);\n                    }\n                    if (this.className) {\n                        node.classList.add(this.className);\n                    }\n                    return node;\n                };\n                ShadowBlot.prototype.attach = function() {\n                    if (this.parent != null) {\n                        this.scroll = this.parent.scroll;\n                    }\n                };\n                ShadowBlot.prototype.clone = function() {\n                    var domNode = this.domNode.cloneNode(false);\n                    return Registry.create(domNode);\n                };\n                ShadowBlot.prototype.detach = function() {\n                    if (this.parent != null) this.parent.removeChild(this);\n                    // @ts-ignore\n                    delete this.domNode[Registry.DATA_KEY];\n                };\n                ShadowBlot.prototype.deleteAt = function(index, length) {\n                    var blot = this.isolate(index, length);\n                    blot.remove();\n                };\n                ShadowBlot.prototype.formatAt = function(index, length, name, value) {\n                    var blot = this.isolate(index, length);\n                    if (Registry.query(name, Registry.Scope.BLOT) != null && value) {\n                        blot.wrap(name, value);\n                    } else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {\n                        var parent = Registry.create(this.statics.scope);\n                        blot.wrap(parent);\n                        parent.format(name, value);\n                    }\n                };\n                ShadowBlot.prototype.insertAt = function(index, value, def) {\n                    var blot = def == null ? Registry.create(\"text\", value) : Registry.create(value, def);\n                    var ref = this.split(index);\n                    this.parent.insertBefore(blot, ref);\n                };\n                ShadowBlot.prototype.insertInto = function(parentBlot, refBlot) {\n                    if (refBlot === void 0) {\n                        refBlot = null;\n                    }\n                    if (this.parent != null) {\n                        this.parent.children.remove(this);\n                    }\n                    var refDomNode = null;\n                    parentBlot.children.insertBefore(this, refBlot);\n                    if (refBlot != null) {\n                        refDomNode = refBlot.domNode;\n                    }\n                    if (this.domNode.parentNode != parentBlot.domNode || this.domNode.nextSibling != refDomNode) {\n                        parentBlot.domNode.insertBefore(this.domNode, refDomNode);\n                    }\n                    this.parent = parentBlot;\n                    this.attach();\n                };\n                ShadowBlot.prototype.isolate = function(index, length) {\n                    var target = this.split(index);\n                    target.split(length);\n                    return target;\n                };\n                ShadowBlot.prototype.length = function() {\n                    return 1;\n                };\n                ShadowBlot.prototype.offset = function(root) {\n                    if (root === void 0) {\n                        root = this.parent;\n                    }\n                    if (this.parent == null || this == root) return 0;\n                    return this.parent.children.offset(this) + this.parent.offset(root);\n                };\n                ShadowBlot.prototype.optimize = function(context) {\n                    // TODO clean up once we use WeakMap\n                    // @ts-ignore\n                    if (this.domNode[Registry.DATA_KEY] != null) {\n                        // @ts-ignore\n                        delete this.domNode[Registry.DATA_KEY].mutations;\n                    }\n                };\n                ShadowBlot.prototype.remove = function() {\n                    if (this.domNode.parentNode != null) {\n                        this.domNode.parentNode.removeChild(this.domNode);\n                    }\n                    this.detach();\n                };\n                ShadowBlot.prototype.replace = function(target) {\n                    if (target.parent == null) return;\n                    target.parent.insertBefore(this, target.next);\n                    target.remove();\n                };\n                ShadowBlot.prototype.replaceWith = function(name, value) {\n                    var replacement = typeof name === \"string\" ? Registry.create(name, value) : name;\n                    replacement.replace(this);\n                    return replacement;\n                };\n                ShadowBlot.prototype.split = function(index, force) {\n                    return index === 0 ? this : this.next;\n                };\n                ShadowBlot.prototype.update = function(mutations, context) {\n                // Nothing to do by default\n                };\n                ShadowBlot.prototype.wrap = function(name, value) {\n                    var wrapper = typeof name === \"string\" ? Registry.create(name, value) : name;\n                    if (this.parent != null) {\n                        this.parent.insertBefore(wrapper, this.next);\n                    }\n                    wrapper.appendChild(this);\n                    return wrapper;\n                };\n                ShadowBlot.blotName = \"abstract\";\n                return ShadowBlot;\n            }();\n            exports1.default = ShadowBlot;\n        /***/ },\n        /* 31 */ /***/ function(module1, exports1, __nested_webpack_require_326422__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var attributor_1 = __nested_webpack_require_326422__(12);\n            var class_1 = __nested_webpack_require_326422__(32);\n            var style_1 = __nested_webpack_require_326422__(33);\n            var Registry = __nested_webpack_require_326422__(1);\n            var AttributorStore = /** @class */ function() {\n                function AttributorStore(domNode) {\n                    this.attributes = {};\n                    this.domNode = domNode;\n                    this.build();\n                }\n                AttributorStore.prototype.attribute = function(attribute, value) {\n                    // verb\n                    if (value) {\n                        if (attribute.add(this.domNode, value)) {\n                            if (attribute.value(this.domNode) != null) {\n                                this.attributes[attribute.attrName] = attribute;\n                            } else {\n                                delete this.attributes[attribute.attrName];\n                            }\n                        }\n                    } else {\n                        attribute.remove(this.domNode);\n                        delete this.attributes[attribute.attrName];\n                    }\n                };\n                AttributorStore.prototype.build = function() {\n                    var _this = this;\n                    this.attributes = {};\n                    var attributes = attributor_1.default.keys(this.domNode);\n                    var classes = class_1.default.keys(this.domNode);\n                    var styles = style_1.default.keys(this.domNode);\n                    attributes.concat(classes).concat(styles).forEach(function(name) {\n                        var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);\n                        if (attr instanceof attributor_1.default) {\n                            _this.attributes[attr.attrName] = attr;\n                        }\n                    });\n                };\n                AttributorStore.prototype.copy = function(target) {\n                    var _this = this;\n                    Object.keys(this.attributes).forEach(function(key) {\n                        var value = _this.attributes[key].value(_this.domNode);\n                        target.format(key, value);\n                    });\n                };\n                AttributorStore.prototype.move = function(target) {\n                    var _this = this;\n                    this.copy(target);\n                    Object.keys(this.attributes).forEach(function(key) {\n                        _this.attributes[key].remove(_this.domNode);\n                    });\n                    this.attributes = {};\n                };\n                AttributorStore.prototype.values = function() {\n                    var _this = this;\n                    return Object.keys(this.attributes).reduce(function(attributes, name) {\n                        attributes[name] = _this.attributes[name].value(_this.domNode);\n                        return attributes;\n                    }, {});\n                };\n                return AttributorStore;\n            }();\n            exports1.default = AttributorStore;\n        /***/ },\n        /* 32 */ /***/ function(module1, exports1, __nested_webpack_require_329767__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var attributor_1 = __nested_webpack_require_329767__(12);\n            function match(node, prefix) {\n                var className = node.getAttribute(\"class\") || \"\";\n                return className.split(/\\s+/).filter(function(name) {\n                    return name.indexOf(prefix + \"-\") === 0;\n                });\n            }\n            var ClassAttributor = /** @class */ function(_super) {\n                __extends(ClassAttributor, _super);\n                function ClassAttributor() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                ClassAttributor.keys = function(node) {\n                    return (node.getAttribute(\"class\") || \"\").split(/\\s+/).map(function(name) {\n                        return name.split(\"-\").slice(0, -1).join(\"-\");\n                    });\n                };\n                ClassAttributor.prototype.add = function(node, value) {\n                    if (!this.canAdd(node, value)) return false;\n                    this.remove(node);\n                    node.classList.add(this.keyName + \"-\" + value);\n                    return true;\n                };\n                ClassAttributor.prototype.remove = function(node) {\n                    var matches = match(node, this.keyName);\n                    matches.forEach(function(name) {\n                        node.classList.remove(name);\n                    });\n                    if (node.classList.length === 0) {\n                        node.removeAttribute(\"class\");\n                    }\n                };\n                ClassAttributor.prototype.value = function(node) {\n                    var result = match(node, this.keyName)[0] || \"\";\n                    var value = result.slice(this.keyName.length + 1); // +1 for hyphen\n                    return this.canAdd(node, value) ? value : \"\";\n                };\n                return ClassAttributor;\n            }(attributor_1.default);\n            exports1.default = ClassAttributor;\n        /***/ },\n        /* 33 */ /***/ function(module1, exports1, __nested_webpack_require_332706__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var attributor_1 = __nested_webpack_require_332706__(12);\n            function camelize(name) {\n                var parts = name.split(\"-\");\n                var rest = parts.slice(1).map(function(part) {\n                    return part[0].toUpperCase() + part.slice(1);\n                }).join(\"\");\n                return parts[0] + rest;\n            }\n            var StyleAttributor = /** @class */ function(_super) {\n                __extends(StyleAttributor, _super);\n                function StyleAttributor() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                StyleAttributor.keys = function(node) {\n                    return (node.getAttribute(\"style\") || \"\").split(\";\").map(function(value) {\n                        var arr = value.split(\":\");\n                        return arr[0].trim();\n                    });\n                };\n                StyleAttributor.prototype.add = function(node, value) {\n                    if (!this.canAdd(node, value)) return false;\n                    // @ts-ignore\n                    node.style[camelize(this.keyName)] = value;\n                    return true;\n                };\n                StyleAttributor.prototype.remove = function(node) {\n                    // @ts-ignore\n                    node.style[camelize(this.keyName)] = \"\";\n                    if (!node.getAttribute(\"style\")) {\n                        node.removeAttribute(\"style\");\n                    }\n                };\n                StyleAttributor.prototype.value = function(node) {\n                    // @ts-ignore\n                    var value = node.style[camelize(this.keyName)];\n                    return this.canAdd(node, value) ? value : \"\";\n                };\n                return StyleAttributor;\n            }(attributor_1.default);\n            exports1.default = StyleAttributor;\n        /***/ },\n        /* 34 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var Theme = function() {\n                function Theme(quill, options) {\n                    _classCallCheck(this, Theme);\n                    this.quill = quill;\n                    this.options = options;\n                    this.modules = {};\n                }\n                _createClass(Theme, [\n                    {\n                        key: \"init\",\n                        value: function init() {\n                            var _this = this;\n                            Object.keys(this.options.modules).forEach(function(name) {\n                                if (_this.modules[name] == null) {\n                                    _this.addModule(name);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"addModule\",\n                        value: function addModule(name) {\n                            var moduleClass = this.quill.constructor.import(\"modules/\" + name);\n                            this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});\n                            return this.modules[name];\n                        }\n                    }\n                ]);\n                return Theme;\n            }();\n            Theme.DEFAULTS = {\n                modules: {}\n            };\n            Theme.themes = {\n                \"default\": Theme\n            };\n            exports1.default = Theme;\n        /***/ },\n        /* 35 */ /***/ function(module1, exports1, __nested_webpack_require_338338__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_338338__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _text = __nested_webpack_require_338338__(7);\n            var _text2 = _interopRequireDefault(_text);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var GUARD_TEXT = \"\\uFEFF\";\n            var Embed = function(_Parchment$Embed) {\n                _inherits(Embed, _Parchment$Embed);\n                function Embed(node) {\n                    _classCallCheck(this, Embed);\n                    var _this = _possibleConstructorReturn(this, (Embed.__proto__ || Object.getPrototypeOf(Embed)).call(this, node));\n                    _this.contentNode = document.createElement(\"span\");\n                    _this.contentNode.setAttribute(\"contenteditable\", false);\n                    [].slice.call(_this.domNode.childNodes).forEach(function(childNode) {\n                        _this.contentNode.appendChild(childNode);\n                    });\n                    _this.leftGuard = document.createTextNode(GUARD_TEXT);\n                    _this.rightGuard = document.createTextNode(GUARD_TEXT);\n                    _this.domNode.appendChild(_this.leftGuard);\n                    _this.domNode.appendChild(_this.contentNode);\n                    _this.domNode.appendChild(_this.rightGuard);\n                    return _this;\n                }\n                _createClass(Embed, [\n                    {\n                        key: \"index\",\n                        value: function index(node, offset) {\n                            if (node === this.leftGuard) return 0;\n                            if (node === this.rightGuard) return 1;\n                            return _get(Embed.prototype.__proto__ || Object.getPrototypeOf(Embed.prototype), \"index\", this).call(this, node, offset);\n                        }\n                    },\n                    {\n                        key: \"restore\",\n                        value: function restore(node) {\n                            var range = void 0, textNode = void 0;\n                            var text = node.data.split(GUARD_TEXT).join(\"\");\n                            if (node === this.leftGuard) {\n                                if (this.prev instanceof _text2.default) {\n                                    var prevLength = this.prev.length();\n                                    this.prev.insertAt(prevLength, text);\n                                    range = {\n                                        startNode: this.prev.domNode,\n                                        startOffset: prevLength + text.length\n                                    };\n                                } else {\n                                    textNode = document.createTextNode(text);\n                                    this.parent.insertBefore(_parchment2.default.create(textNode), this);\n                                    range = {\n                                        startNode: textNode,\n                                        startOffset: text.length\n                                    };\n                                }\n                            } else if (node === this.rightGuard) {\n                                if (this.next instanceof _text2.default) {\n                                    this.next.insertAt(0, text);\n                                    range = {\n                                        startNode: this.next.domNode,\n                                        startOffset: text.length\n                                    };\n                                } else {\n                                    textNode = document.createTextNode(text);\n                                    this.parent.insertBefore(_parchment2.default.create(textNode), this.next);\n                                    range = {\n                                        startNode: textNode,\n                                        startOffset: text.length\n                                    };\n                                }\n                            }\n                            node.data = GUARD_TEXT;\n                            return range;\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(mutations, context) {\n                            var _this2 = this;\n                            mutations.forEach(function(mutation) {\n                                if (mutation.type === \"characterData\" && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {\n                                    var range = _this2.restore(mutation.target);\n                                    if (range) context.range = range;\n                                }\n                            });\n                        }\n                    }\n                ]);\n                return Embed;\n            }(_parchment2.default.Embed);\n            exports1.default = Embed;\n        /***/ },\n        /* 36 */ /***/ function(module1, exports1, __nested_webpack_require_346713__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.AlignStyle = exports1.AlignClass = exports1.AlignAttribute = undefined;\n            var _parchment = __nested_webpack_require_346713__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            var config = {\n                scope: _parchment2.default.Scope.BLOCK,\n                whitelist: [\n                    \"right\",\n                    \"center\",\n                    \"justify\"\n                ]\n            };\n            var AlignAttribute = new _parchment2.default.Attributor.Attribute(\"align\", \"align\", config);\n            var AlignClass = new _parchment2.default.Attributor.Class(\"align\", \"ql-align\", config);\n            var AlignStyle = new _parchment2.default.Attributor.Style(\"align\", \"text-align\", config);\n            exports1.AlignAttribute = AlignAttribute;\n            exports1.AlignClass = AlignClass;\n            exports1.AlignStyle = AlignStyle;\n        /***/ },\n        /* 37 */ /***/ function(module1, exports1, __nested_webpack_require_348005__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.BackgroundStyle = exports1.BackgroundClass = undefined;\n            var _parchment = __nested_webpack_require_348005__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _color = __nested_webpack_require_348005__(26);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            var BackgroundClass = new _parchment2.default.Attributor.Class(\"background\", \"ql-bg\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            var BackgroundStyle = new _color.ColorAttributor(\"background\", \"background-color\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            exports1.BackgroundClass = BackgroundClass;\n            exports1.BackgroundStyle = BackgroundStyle;\n        /***/ },\n        /* 38 */ /***/ function(module1, exports1, __nested_webpack_require_349097__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.DirectionStyle = exports1.DirectionClass = exports1.DirectionAttribute = undefined;\n            var _parchment = __nested_webpack_require_349097__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            var config = {\n                scope: _parchment2.default.Scope.BLOCK,\n                whitelist: [\n                    \"rtl\"\n                ]\n            };\n            var DirectionAttribute = new _parchment2.default.Attributor.Attribute(\"direction\", \"dir\", config);\n            var DirectionClass = new _parchment2.default.Attributor.Class(\"direction\", \"ql-direction\", config);\n            var DirectionStyle = new _parchment2.default.Attributor.Style(\"direction\", \"direction\", config);\n            exports1.DirectionAttribute = DirectionAttribute;\n            exports1.DirectionClass = DirectionClass;\n            exports1.DirectionStyle = DirectionStyle;\n        /***/ },\n        /* 39 */ /***/ function(module1, exports1, __nested_webpack_require_350387__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.FontClass = exports1.FontStyle = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_350387__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var config = {\n                scope: _parchment2.default.Scope.INLINE,\n                whitelist: [\n                    \"serif\",\n                    \"monospace\"\n                ]\n            };\n            var FontClass = new _parchment2.default.Attributor.Class(\"font\", \"ql-font\", config);\n            var FontStyleAttributor = function(_Parchment$Attributor) {\n                _inherits(FontStyleAttributor, _Parchment$Attributor);\n                function FontStyleAttributor() {\n                    _classCallCheck(this, FontStyleAttributor);\n                    return _possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));\n                }\n                _createClass(FontStyleAttributor, [\n                    {\n                        key: \"value\",\n                        value: function value(node) {\n                            return _get(FontStyleAttributor.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor.prototype), \"value\", this).call(this, node).replace(/[\"']/g, \"\");\n                        }\n                    }\n                ]);\n                return FontStyleAttributor;\n            }(_parchment2.default.Attributor.Style);\n            var FontStyle = new FontStyleAttributor(\"font\", \"font-family\", config);\n            exports1.FontStyle = FontStyle;\n            exports1.FontClass = FontClass;\n        /***/ },\n        /* 40 */ /***/ function(module1, exports1, __nested_webpack_require_355453__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.SizeStyle = exports1.SizeClass = undefined;\n            var _parchment = __nested_webpack_require_355453__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            var SizeClass = new _parchment2.default.Attributor.Class(\"size\", \"ql-size\", {\n                scope: _parchment2.default.Scope.INLINE,\n                whitelist: [\n                    \"small\",\n                    \"large\",\n                    \"huge\"\n                ]\n            });\n            var SizeStyle = new _parchment2.default.Attributor.Style(\"size\", \"font-size\", {\n                scope: _parchment2.default.Scope.INLINE,\n                whitelist: [\n                    \"10px\",\n                    \"18px\",\n                    \"32px\"\n                ]\n            });\n            exports1.SizeClass = SizeClass;\n            exports1.SizeStyle = SizeStyle;\n        /***/ },\n        /* 41 */ /***/ function(module1, exports1, __nested_webpack_require_356708__) {\n            \"use strict\";\n            module1.exports = {\n                \"align\": {\n                    \"\": __nested_webpack_require_356708__(76),\n                    \"center\": __nested_webpack_require_356708__(77),\n                    \"right\": __nested_webpack_require_356708__(78),\n                    \"justify\": __nested_webpack_require_356708__(79)\n                },\n                \"background\": __nested_webpack_require_356708__(80),\n                \"blockquote\": __nested_webpack_require_356708__(81),\n                \"bold\": __nested_webpack_require_356708__(82),\n                \"clean\": __nested_webpack_require_356708__(83),\n                \"code\": __nested_webpack_require_356708__(58),\n                \"code-block\": __nested_webpack_require_356708__(58),\n                \"color\": __nested_webpack_require_356708__(84),\n                \"direction\": {\n                    \"\": __nested_webpack_require_356708__(85),\n                    \"rtl\": __nested_webpack_require_356708__(86)\n                },\n                \"float\": {\n                    \"center\": __nested_webpack_require_356708__(87),\n                    \"full\": __nested_webpack_require_356708__(88),\n                    \"left\": __nested_webpack_require_356708__(89),\n                    \"right\": __nested_webpack_require_356708__(90)\n                },\n                \"formula\": __nested_webpack_require_356708__(91),\n                \"header\": {\n                    \"1\": __nested_webpack_require_356708__(92),\n                    \"2\": __nested_webpack_require_356708__(93)\n                },\n                \"italic\": __nested_webpack_require_356708__(94),\n                \"image\": __nested_webpack_require_356708__(95),\n                \"indent\": {\n                    \"+1\": __nested_webpack_require_356708__(96),\n                    \"-1\": __nested_webpack_require_356708__(97)\n                },\n                \"link\": __nested_webpack_require_356708__(98),\n                \"list\": {\n                    \"ordered\": __nested_webpack_require_356708__(99),\n                    \"bullet\": __nested_webpack_require_356708__(100),\n                    \"check\": __nested_webpack_require_356708__(101)\n                },\n                \"script\": {\n                    \"sub\": __nested_webpack_require_356708__(102),\n                    \"super\": __nested_webpack_require_356708__(103)\n                },\n                \"strike\": __nested_webpack_require_356708__(104),\n                \"underline\": __nested_webpack_require_356708__(105),\n                \"video\": __nested_webpack_require_356708__(106)\n            };\n        /***/ },\n        /* 42 */ /***/ function(module1, exports1, __nested_webpack_require_358922__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.getLastChangeIndex = exports1.default = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _parchment = __nested_webpack_require_358922__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_358922__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _module = __nested_webpack_require_358922__(9);\n            var _module2 = _interopRequireDefault(_module);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var History = function(_Module) {\n                _inherits(History, _Module);\n                function History(quill, options) {\n                    _classCallCheck(this, History);\n                    var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, quill, options));\n                    _this.lastRecorded = 0;\n                    _this.ignoreChange = false;\n                    _this.clear();\n                    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(eventName, delta, oldDelta, source) {\n                        if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange) return;\n                        if (!_this.options.userOnly || source === _quill2.default.sources.USER) {\n                            _this.record(delta, oldDelta);\n                        } else {\n                            _this.transform(delta);\n                        }\n                    });\n                    _this.quill.keyboard.addBinding({\n                        key: \"Z\",\n                        shortKey: true\n                    }, _this.undo.bind(_this));\n                    _this.quill.keyboard.addBinding({\n                        key: \"Z\",\n                        shortKey: true,\n                        shiftKey: true\n                    }, _this.redo.bind(_this));\n                    if (/Win/i.test(navigator.platform)) {\n                        _this.quill.keyboard.addBinding({\n                            key: \"Y\",\n                            shortKey: true\n                        }, _this.redo.bind(_this));\n                    }\n                    return _this;\n                }\n                _createClass(History, [\n                    {\n                        key: \"change\",\n                        value: function change(source, dest) {\n                            if (this.stack[source].length === 0) return;\n                            var delta = this.stack[source].pop();\n                            this.stack[dest].push(delta);\n                            this.lastRecorded = 0;\n                            this.ignoreChange = true;\n                            this.quill.updateContents(delta[source], _quill2.default.sources.USER);\n                            this.ignoreChange = false;\n                            var index = getLastChangeIndex(delta[source]);\n                            this.quill.setSelection(index);\n                        }\n                    },\n                    {\n                        key: \"clear\",\n                        value: function clear() {\n                            this.stack = {\n                                undo: [],\n                                redo: []\n                            };\n                        }\n                    },\n                    {\n                        key: \"cutoff\",\n                        value: function cutoff() {\n                            this.lastRecorded = 0;\n                        }\n                    },\n                    {\n                        key: \"record\",\n                        value: function record(changeDelta, oldDelta) {\n                            if (changeDelta.ops.length === 0) return;\n                            this.stack.redo = [];\n                            var undoDelta = this.quill.getContents().diff(oldDelta);\n                            var timestamp = Date.now();\n                            if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {\n                                var delta = this.stack.undo.pop();\n                                undoDelta = undoDelta.compose(delta.undo);\n                                changeDelta = delta.redo.compose(changeDelta);\n                            } else {\n                                this.lastRecorded = timestamp;\n                            }\n                            this.stack.undo.push({\n                                redo: changeDelta,\n                                undo: undoDelta\n                            });\n                            if (this.stack.undo.length > this.options.maxStack) {\n                                this.stack.undo.shift();\n                            }\n                        }\n                    },\n                    {\n                        key: \"redo\",\n                        value: function redo() {\n                            this.change(\"redo\", \"undo\");\n                        }\n                    },\n                    {\n                        key: \"transform\",\n                        value: function transform(delta) {\n                            this.stack.undo.forEach(function(change) {\n                                change.undo = delta.transform(change.undo, true);\n                                change.redo = delta.transform(change.redo, true);\n                            });\n                            this.stack.redo.forEach(function(change) {\n                                change.undo = delta.transform(change.undo, true);\n                                change.redo = delta.transform(change.redo, true);\n                            });\n                        }\n                    },\n                    {\n                        key: \"undo\",\n                        value: function undo() {\n                            this.change(\"undo\", \"redo\");\n                        }\n                    }\n                ]);\n                return History;\n            }(_module2.default);\n            History.DEFAULTS = {\n                delay: 1000,\n                maxStack: 100,\n                userOnly: false\n            };\n            function endsWithNewlineChange(delta) {\n                var lastOp = delta.ops[delta.ops.length - 1];\n                if (lastOp == null) return false;\n                if (lastOp.insert != null) {\n                    return typeof lastOp.insert === \"string\" && lastOp.insert.endsWith(\"\\n\");\n                }\n                if (lastOp.attributes != null) {\n                    return Object.keys(lastOp.attributes).some(function(attr) {\n                        return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;\n                    });\n                }\n                return false;\n            }\n            function getLastChangeIndex(delta) {\n                var deleteLength = delta.reduce(function(length, op) {\n                    length += op.delete || 0;\n                    return length;\n                }, 0);\n                var changeIndex = delta.length() - deleteLength;\n                if (endsWithNewlineChange(delta)) {\n                    changeIndex -= 1;\n                }\n                return changeIndex;\n            }\n            exports1.default = History;\n            exports1.getLastChangeIndex = getLastChangeIndex;\n        /***/ },\n        /* 43 */ /***/ function(module1, exports1, __nested_webpack_require_368758__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.BaseTooltip = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _extend = __nested_webpack_require_368758__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _quillDelta = __nested_webpack_require_368758__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _emitter = __nested_webpack_require_368758__(8);\n            var _emitter2 = _interopRequireDefault(_emitter);\n            var _keyboard = __nested_webpack_require_368758__(23);\n            var _keyboard2 = _interopRequireDefault(_keyboard);\n            var _theme = __nested_webpack_require_368758__(34);\n            var _theme2 = _interopRequireDefault(_theme);\n            var _colorPicker = __nested_webpack_require_368758__(59);\n            var _colorPicker2 = _interopRequireDefault(_colorPicker);\n            var _iconPicker = __nested_webpack_require_368758__(60);\n            var _iconPicker2 = _interopRequireDefault(_iconPicker);\n            var _picker = __nested_webpack_require_368758__(28);\n            var _picker2 = _interopRequireDefault(_picker);\n            var _tooltip = __nested_webpack_require_368758__(61);\n            var _tooltip2 = _interopRequireDefault(_tooltip);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ALIGNS = [\n                false,\n                \"center\",\n                \"right\",\n                \"justify\"\n            ];\n            var COLORS = [\n                \"#000000\",\n                \"#e60000\",\n                \"#ff9900\",\n                \"#ffff00\",\n                \"#008a00\",\n                \"#0066cc\",\n                \"#9933ff\",\n                \"#ffffff\",\n                \"#facccc\",\n                \"#ffebcc\",\n                \"#ffffcc\",\n                \"#cce8cc\",\n                \"#cce0f5\",\n                \"#ebd6ff\",\n                \"#bbbbbb\",\n                \"#f06666\",\n                \"#ffc266\",\n                \"#ffff66\",\n                \"#66b966\",\n                \"#66a3e0\",\n                \"#c285ff\",\n                \"#888888\",\n                \"#a10000\",\n                \"#b26b00\",\n                \"#b2b200\",\n                \"#006100\",\n                \"#0047b2\",\n                \"#6b24b2\",\n                \"#444444\",\n                \"#5c0000\",\n                \"#663d00\",\n                \"#666600\",\n                \"#003700\",\n                \"#002966\",\n                \"#3d1466\"\n            ];\n            var FONTS = [\n                false,\n                \"serif\",\n                \"monospace\"\n            ];\n            var HEADERS = [\n                \"1\",\n                \"2\",\n                \"3\",\n                false\n            ];\n            var SIZES = [\n                \"small\",\n                false,\n                \"large\",\n                \"huge\"\n            ];\n            var BaseTheme = function(_Theme) {\n                _inherits(BaseTheme, _Theme);\n                function BaseTheme(quill, options) {\n                    _classCallCheck(this, BaseTheme);\n                    var _this = _possibleConstructorReturn(this, (BaseTheme.__proto__ || Object.getPrototypeOf(BaseTheme)).call(this, quill, options));\n                    var listener = function listener(e) {\n                        if (!document.body.contains(quill.root)) {\n                            return document.body.removeEventListener(\"click\", listener);\n                        }\n                        if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {\n                            _this.tooltip.hide();\n                        }\n                        if (_this.pickers != null) {\n                            _this.pickers.forEach(function(picker) {\n                                if (!picker.container.contains(e.target)) {\n                                    picker.close();\n                                }\n                            });\n                        }\n                    };\n                    quill.emitter.listenDOM(\"click\", document.body, listener);\n                    return _this;\n                }\n                _createClass(BaseTheme, [\n                    {\n                        key: \"addModule\",\n                        value: function addModule(name) {\n                            var module1 = _get(BaseTheme.prototype.__proto__ || Object.getPrototypeOf(BaseTheme.prototype), \"addModule\", this).call(this, name);\n                            if (name === \"toolbar\") {\n                                this.extendToolbar(module1);\n                            }\n                            return module1;\n                        }\n                    },\n                    {\n                        key: \"buildButtons\",\n                        value: function buildButtons(buttons, icons) {\n                            buttons.forEach(function(button) {\n                                var className = button.getAttribute(\"class\") || \"\";\n                                className.split(/\\s+/).forEach(function(name) {\n                                    if (!name.startsWith(\"ql-\")) return;\n                                    name = name.slice(\"ql-\".length);\n                                    if (icons[name] == null) return;\n                                    if (name === \"direction\") {\n                                        button.innerHTML = icons[name][\"\"] + icons[name][\"rtl\"];\n                                    } else if (typeof icons[name] === \"string\") {\n                                        button.innerHTML = icons[name];\n                                    } else {\n                                        var value = button.value || \"\";\n                                        if (value != null && icons[name][value]) {\n                                            button.innerHTML = icons[name][value];\n                                        }\n                                    }\n                                });\n                            });\n                        }\n                    },\n                    {\n                        key: \"buildPickers\",\n                        value: function buildPickers(selects, icons) {\n                            var _this2 = this;\n                            this.pickers = selects.map(function(select) {\n                                if (select.classList.contains(\"ql-align\")) {\n                                    if (select.querySelector(\"option\") == null) {\n                                        fillSelect(select, ALIGNS);\n                                    }\n                                    return new _iconPicker2.default(select, icons.align);\n                                } else if (select.classList.contains(\"ql-background\") || select.classList.contains(\"ql-color\")) {\n                                    var format = select.classList.contains(\"ql-background\") ? \"background\" : \"color\";\n                                    if (select.querySelector(\"option\") == null) {\n                                        fillSelect(select, COLORS, format === \"background\" ? \"#ffffff\" : \"#000000\");\n                                    }\n                                    return new _colorPicker2.default(select, icons[format]);\n                                } else {\n                                    if (select.querySelector(\"option\") == null) {\n                                        if (select.classList.contains(\"ql-font\")) {\n                                            fillSelect(select, FONTS);\n                                        } else if (select.classList.contains(\"ql-header\")) {\n                                            fillSelect(select, HEADERS);\n                                        } else if (select.classList.contains(\"ql-size\")) {\n                                            fillSelect(select, SIZES);\n                                        }\n                                    }\n                                    return new _picker2.default(select);\n                                }\n                            });\n                            var update = function update() {\n                                _this2.pickers.forEach(function(picker) {\n                                    picker.update();\n                                });\n                            };\n                            this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);\n                        }\n                    }\n                ]);\n                return BaseTheme;\n            }(_theme2.default);\n            BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {\n                modules: {\n                    toolbar: {\n                        handlers: {\n                            formula: function formula() {\n                                this.quill.theme.tooltip.edit(\"formula\");\n                            },\n                            image: function image() {\n                                var _this3 = this;\n                                var fileInput = this.container.querySelector(\"input.ql-image[type=file]\");\n                                if (fileInput == null) {\n                                    fileInput = document.createElement(\"input\");\n                                    fileInput.setAttribute(\"type\", \"file\");\n                                    fileInput.setAttribute(\"accept\", \"image/png, image/gif, image/jpeg, image/bmp, image/x-icon\");\n                                    fileInput.classList.add(\"ql-image\");\n                                    fileInput.addEventListener(\"change\", function() {\n                                        if (fileInput.files != null && fileInput.files[0] != null) {\n                                            var reader = new FileReader();\n                                            reader.onload = function(e) {\n                                                var range = _this3.quill.getSelection(true);\n                                                _this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({\n                                                    image: e.target.result\n                                                }), _emitter2.default.sources.USER);\n                                                _this3.quill.setSelection(range.index + 1, _emitter2.default.sources.SILENT);\n                                                fileInput.value = \"\";\n                                            };\n                                            reader.readAsDataURL(fileInput.files[0]);\n                                        }\n                                    });\n                                    this.container.appendChild(fileInput);\n                                }\n                                fileInput.click();\n                            },\n                            video: function video() {\n                                this.quill.theme.tooltip.edit(\"video\");\n                            }\n                        }\n                    }\n                }\n            });\n            var BaseTooltip = function(_Tooltip) {\n                _inherits(BaseTooltip, _Tooltip);\n                function BaseTooltip(quill, boundsContainer) {\n                    _classCallCheck(this, BaseTooltip);\n                    var _this4 = _possibleConstructorReturn(this, (BaseTooltip.__proto__ || Object.getPrototypeOf(BaseTooltip)).call(this, quill, boundsContainer));\n                    _this4.textbox = _this4.root.querySelector('input[type=\"text\"]');\n                    _this4.listen();\n                    return _this4;\n                }\n                _createClass(BaseTooltip, [\n                    {\n                        key: \"listen\",\n                        value: function listen() {\n                            var _this5 = this;\n                            this.textbox.addEventListener(\"keydown\", function(event) {\n                                if (_keyboard2.default.match(event, \"enter\")) {\n                                    _this5.save();\n                                    event.preventDefault();\n                                } else if (_keyboard2.default.match(event, \"escape\")) {\n                                    _this5.cancel();\n                                    event.preventDefault();\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"cancel\",\n                        value: function cancel() {\n                            this.hide();\n                        }\n                    },\n                    {\n                        key: \"edit\",\n                        value: function edit() {\n                            var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"link\";\n                            var preview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n                            this.root.classList.remove(\"ql-hidden\");\n                            this.root.classList.add(\"ql-editing\");\n                            if (preview != null) {\n                                this.textbox.value = preview;\n                            } else if (mode !== this.root.getAttribute(\"data-mode\")) {\n                                this.textbox.value = \"\";\n                            }\n                            this.position(this.quill.getBounds(this.quill.selection.savedRange));\n                            this.textbox.select();\n                            this.textbox.setAttribute(\"placeholder\", this.textbox.getAttribute(\"data-\" + mode) || \"\");\n                            this.root.setAttribute(\"data-mode\", mode);\n                        }\n                    },\n                    {\n                        key: \"restoreFocus\",\n                        value: function restoreFocus() {\n                            var scrollTop = this.quill.scrollingContainer.scrollTop;\n                            this.quill.focus();\n                            this.quill.scrollingContainer.scrollTop = scrollTop;\n                        }\n                    },\n                    {\n                        key: \"save\",\n                        value: function save() {\n                            var value = this.textbox.value;\n                            switch(this.root.getAttribute(\"data-mode\")){\n                                case \"link\":\n                                    {\n                                        var scrollTop = this.quill.root.scrollTop;\n                                        if (this.linkRange) {\n                                            this.quill.formatText(this.linkRange, \"link\", value, _emitter2.default.sources.USER);\n                                            delete this.linkRange;\n                                        } else {\n                                            this.restoreFocus();\n                                            this.quill.format(\"link\", value, _emitter2.default.sources.USER);\n                                        }\n                                        this.quill.root.scrollTop = scrollTop;\n                                        break;\n                                    }\n                                case \"video\":\n                                    {\n                                        value = extractVideoUrl(value);\n                                    }\n                                case \"formula\":\n                                    {\n                                        if (!value) break;\n                                        var range = this.quill.getSelection(true);\n                                        if (range != null) {\n                                            var index = range.index + range.length;\n                                            this.quill.insertEmbed(index, this.root.getAttribute(\"data-mode\"), value, _emitter2.default.sources.USER);\n                                            if (this.root.getAttribute(\"data-mode\") === \"formula\") {\n                                                this.quill.insertText(index + 1, \" \", _emitter2.default.sources.USER);\n                                            }\n                                            this.quill.setSelection(index + 2, _emitter2.default.sources.USER);\n                                        }\n                                        break;\n                                    }\n                                default:\n                            }\n                            this.textbox.value = \"\";\n                            this.hide();\n                        }\n                    }\n                ]);\n                return BaseTooltip;\n            }(_tooltip2.default);\n            function extractVideoUrl(url) {\n                var match = url.match(/^(?:(https?):\\/\\/)?(?:(?:www|m)\\.)?youtube\\.com\\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\\/\\/)?(?:(?:www|m)\\.)?youtu\\.be\\/([a-zA-Z0-9_-]+)/);\n                if (match) {\n                    return (match[1] || \"https\") + \"://www.youtube.com/embed/\" + match[2] + \"?showinfo=0\";\n                }\n                if (match = url.match(/^(?:(https?):\\/\\/)?(?:www\\.)?vimeo\\.com\\/(\\d+)/)) {\n                    // eslint-disable-line no-cond-assign\n                    return (match[1] || \"https\") + \"://player.vimeo.com/video/\" + match[2] + \"/\";\n                }\n                return url;\n            }\n            function fillSelect(select, values) {\n                var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                values.forEach(function(value) {\n                    var option = document.createElement(\"option\");\n                    if (value === defaultValue) {\n                        option.setAttribute(\"selected\", \"selected\");\n                    } else {\n                        option.setAttribute(\"value\", value);\n                    }\n                    select.appendChild(option);\n                });\n            }\n            exports1.BaseTooltip = BaseTooltip;\n            exports1.default = BaseTheme;\n        /***/ },\n        /* 44 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var LinkedList = /** @class */ function() {\n                function LinkedList() {\n                    this.head = this.tail = null;\n                    this.length = 0;\n                }\n                LinkedList.prototype.append = function() {\n                    var nodes = [];\n                    for(var _i = 0; _i < arguments.length; _i++){\n                        nodes[_i] = arguments[_i];\n                    }\n                    this.insertBefore(nodes[0], null);\n                    if (nodes.length > 1) {\n                        this.append.apply(this, nodes.slice(1));\n                    }\n                };\n                LinkedList.prototype.contains = function(node) {\n                    var cur, next = this.iterator();\n                    while(cur = next()){\n                        if (cur === node) return true;\n                    }\n                    return false;\n                };\n                LinkedList.prototype.insertBefore = function(node, refNode) {\n                    if (!node) return;\n                    node.next = refNode;\n                    if (refNode != null) {\n                        node.prev = refNode.prev;\n                        if (refNode.prev != null) {\n                            refNode.prev.next = node;\n                        }\n                        refNode.prev = node;\n                        if (refNode === this.head) {\n                            this.head = node;\n                        }\n                    } else if (this.tail != null) {\n                        this.tail.next = node;\n                        node.prev = this.tail;\n                        this.tail = node;\n                    } else {\n                        node.prev = null;\n                        this.head = this.tail = node;\n                    }\n                    this.length += 1;\n                };\n                LinkedList.prototype.offset = function(target) {\n                    var index = 0, cur = this.head;\n                    while(cur != null){\n                        if (cur === target) return index;\n                        index += cur.length();\n                        cur = cur.next;\n                    }\n                    return -1;\n                };\n                LinkedList.prototype.remove = function(node) {\n                    if (!this.contains(node)) return;\n                    if (node.prev != null) node.prev.next = node.next;\n                    if (node.next != null) node.next.prev = node.prev;\n                    if (node === this.head) this.head = node.next;\n                    if (node === this.tail) this.tail = node.prev;\n                    this.length -= 1;\n                };\n                LinkedList.prototype.iterator = function(curNode) {\n                    if (curNode === void 0) {\n                        curNode = this.head;\n                    }\n                    // TODO use yield when we can\n                    return function() {\n                        var ret = curNode;\n                        if (curNode != null) curNode = curNode.next;\n                        return ret;\n                    };\n                };\n                LinkedList.prototype.find = function(index, inclusive) {\n                    if (inclusive === void 0) {\n                        inclusive = false;\n                    }\n                    var cur, next = this.iterator();\n                    while(cur = next()){\n                        var length = cur.length();\n                        if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) {\n                            return [\n                                cur,\n                                index\n                            ];\n                        }\n                        index -= length;\n                    }\n                    return [\n                        null,\n                        0\n                    ];\n                };\n                LinkedList.prototype.forEach = function(callback) {\n                    var cur, next = this.iterator();\n                    while(cur = next()){\n                        callback(cur);\n                    }\n                };\n                LinkedList.prototype.forEachAt = function(index, length, callback) {\n                    if (length <= 0) return;\n                    var _a = this.find(index), startNode = _a[0], offset = _a[1];\n                    var cur, curIndex = index - offset, next = this.iterator(startNode);\n                    while((cur = next()) && curIndex < index + length){\n                        var curLength = cur.length();\n                        if (index > curIndex) {\n                            callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));\n                        } else {\n                            callback(cur, 0, Math.min(curLength, index + length - curIndex));\n                        }\n                        curIndex += curLength;\n                    }\n                };\n                LinkedList.prototype.map = function(callback) {\n                    return this.reduce(function(memo, cur) {\n                        memo.push(callback(cur));\n                        return memo;\n                    }, []);\n                };\n                LinkedList.prototype.reduce = function(callback, memo) {\n                    var cur, next = this.iterator();\n                    while(cur = next()){\n                        memo = callback(memo, cur);\n                    }\n                    return memo;\n                };\n                return LinkedList;\n            }();\n            exports1.default = LinkedList;\n        /***/ },\n        /* 45 */ /***/ function(module1, exports1, __nested_webpack_require_396166__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var container_1 = __nested_webpack_require_396166__(17);\n            var Registry = __nested_webpack_require_396166__(1);\n            var OBSERVER_CONFIG = {\n                attributes: true,\n                characterData: true,\n                characterDataOldValue: true,\n                childList: true,\n                subtree: true\n            };\n            var MAX_OPTIMIZE_ITERATIONS = 100;\n            var ScrollBlot = /** @class */ function(_super) {\n                __extends(ScrollBlot, _super);\n                function ScrollBlot(node) {\n                    var _this = _super.call(this, node) || this;\n                    _this.scroll = _this;\n                    _this.observer = new MutationObserver(function(mutations) {\n                        _this.update(mutations);\n                    });\n                    _this.observer.observe(_this.domNode, OBSERVER_CONFIG);\n                    _this.attach();\n                    return _this;\n                }\n                ScrollBlot.prototype.detach = function() {\n                    _super.prototype.detach.call(this);\n                    this.observer.disconnect();\n                };\n                ScrollBlot.prototype.deleteAt = function(index, length) {\n                    this.update();\n                    if (index === 0 && length === this.length()) {\n                        this.children.forEach(function(child) {\n                            child.remove();\n                        });\n                    } else {\n                        _super.prototype.deleteAt.call(this, index, length);\n                    }\n                };\n                ScrollBlot.prototype.formatAt = function(index, length, name, value) {\n                    this.update();\n                    _super.prototype.formatAt.call(this, index, length, name, value);\n                };\n                ScrollBlot.prototype.insertAt = function(index, value, def) {\n                    this.update();\n                    _super.prototype.insertAt.call(this, index, value, def);\n                };\n                ScrollBlot.prototype.optimize = function(mutations, context) {\n                    var _this = this;\n                    if (mutations === void 0) {\n                        mutations = [];\n                    }\n                    if (context === void 0) {\n                        context = {};\n                    }\n                    _super.prototype.optimize.call(this, context);\n                    // We must modify mutations directly, cannot make copy and then modify\n                    var records = [].slice.call(this.observer.takeRecords());\n                    // Array.push currently seems to be implemented by a non-tail recursive function\n                    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n                    while(records.length > 0)mutations.push(records.pop());\n                    // TODO use WeakMap\n                    var mark = function(blot, markParent) {\n                        if (markParent === void 0) {\n                            markParent = true;\n                        }\n                        if (blot == null || blot === _this) return;\n                        if (blot.domNode.parentNode == null) return;\n                        // @ts-ignore\n                        if (blot.domNode[Registry.DATA_KEY].mutations == null) {\n                            // @ts-ignore\n                            blot.domNode[Registry.DATA_KEY].mutations = [];\n                        }\n                        if (markParent) mark(blot.parent);\n                    };\n                    var optimize = function(blot) {\n                        // Post-order traversal\n                        if (// @ts-ignore\n                        blot.domNode[Registry.DATA_KEY] == null || // @ts-ignore\n                        blot.domNode[Registry.DATA_KEY].mutations == null) {\n                            return;\n                        }\n                        if (blot instanceof container_1.default) {\n                            blot.children.forEach(optimize);\n                        }\n                        blot.optimize(context);\n                    };\n                    var remaining = mutations;\n                    for(var i = 0; remaining.length > 0; i += 1){\n                        if (i >= MAX_OPTIMIZE_ITERATIONS) {\n                            throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n                        }\n                        remaining.forEach(function(mutation) {\n                            var blot = Registry.find(mutation.target, true);\n                            if (blot == null) return;\n                            if (blot.domNode === mutation.target) {\n                                if (mutation.type === \"childList\") {\n                                    mark(Registry.find(mutation.previousSibling, false));\n                                    [].forEach.call(mutation.addedNodes, function(node) {\n                                        var child = Registry.find(node, false);\n                                        mark(child, false);\n                                        if (child instanceof container_1.default) {\n                                            child.children.forEach(function(grandChild) {\n                                                mark(grandChild, false);\n                                            });\n                                        }\n                                    });\n                                } else if (mutation.type === \"attributes\") {\n                                    mark(blot.prev);\n                                }\n                            }\n                            mark(blot);\n                        });\n                        this.children.forEach(optimize);\n                        remaining = [].slice.call(this.observer.takeRecords());\n                        records = remaining.slice();\n                        while(records.length > 0)mutations.push(records.pop());\n                    }\n                };\n                ScrollBlot.prototype.update = function(mutations, context) {\n                    var _this = this;\n                    if (context === void 0) {\n                        context = {};\n                    }\n                    mutations = mutations || this.observer.takeRecords();\n                    // TODO use WeakMap\n                    mutations.map(function(mutation) {\n                        var blot = Registry.find(mutation.target, true);\n                        if (blot == null) return null;\n                        // @ts-ignore\n                        if (blot.domNode[Registry.DATA_KEY].mutations == null) {\n                            // @ts-ignore\n                            blot.domNode[Registry.DATA_KEY].mutations = [\n                                mutation\n                            ];\n                            return blot;\n                        } else {\n                            // @ts-ignore\n                            blot.domNode[Registry.DATA_KEY].mutations.push(mutation);\n                            return null;\n                        }\n                    }).forEach(function(blot) {\n                        if (blot == null || blot === _this || //@ts-ignore\n                        blot.domNode[Registry.DATA_KEY] == null) return;\n                        // @ts-ignore\n                        blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);\n                    });\n                    // @ts-ignore\n                    if (this.domNode[Registry.DATA_KEY].mutations != null) {\n                        // @ts-ignore\n                        _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);\n                    }\n                    this.optimize(mutations, context);\n                };\n                ScrollBlot.blotName = \"scroll\";\n                ScrollBlot.defaultChild = \"block\";\n                ScrollBlot.scope = Registry.Scope.BLOCK_BLOT;\n                ScrollBlot.tagName = \"DIV\";\n                return ScrollBlot;\n            }(container_1.default);\n            exports1.default = ScrollBlot;\n        /***/ },\n        /* 46 */ /***/ function(module1, exports1, __nested_webpack_require_405302__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var format_1 = __nested_webpack_require_405302__(18);\n            var Registry = __nested_webpack_require_405302__(1);\n            // Shallow object comparison\n            function isEqual(obj1, obj2) {\n                if (Object.keys(obj1).length !== Object.keys(obj2).length) return false;\n                // @ts-ignore\n                for(var prop in obj1){\n                    // @ts-ignore\n                    if (obj1[prop] !== obj2[prop]) return false;\n                }\n                return true;\n            }\n            var InlineBlot = /** @class */ function(_super) {\n                __extends(InlineBlot, _super);\n                function InlineBlot() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                InlineBlot.formats = function(domNode) {\n                    if (domNode.tagName === InlineBlot.tagName) return undefined;\n                    return _super.formats.call(this, domNode);\n                };\n                InlineBlot.prototype.format = function(name, value) {\n                    var _this = this;\n                    if (name === this.statics.blotName && !value) {\n                        this.children.forEach(function(child) {\n                            if (!(child instanceof format_1.default)) {\n                                child = child.wrap(InlineBlot.blotName, true);\n                            }\n                            _this.attributes.copy(child);\n                        });\n                        this.unwrap();\n                    } else {\n                        _super.prototype.format.call(this, name, value);\n                    }\n                };\n                InlineBlot.prototype.formatAt = function(index, length, name, value) {\n                    if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {\n                        var blot = this.isolate(index, length);\n                        blot.format(name, value);\n                    } else {\n                        _super.prototype.formatAt.call(this, index, length, name, value);\n                    }\n                };\n                InlineBlot.prototype.optimize = function(context) {\n                    _super.prototype.optimize.call(this, context);\n                    var formats = this.formats();\n                    if (Object.keys(formats).length === 0) {\n                        return this.unwrap(); // unformatted span\n                    }\n                    var next = this.next;\n                    if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {\n                        next.moveChildren(this);\n                        next.remove();\n                    }\n                };\n                InlineBlot.blotName = \"inline\";\n                InlineBlot.scope = Registry.Scope.INLINE_BLOT;\n                InlineBlot.tagName = \"SPAN\";\n                return InlineBlot;\n            }(format_1.default);\n            exports1.default = InlineBlot;\n        /***/ },\n        /* 47 */ /***/ function(module1, exports1, __nested_webpack_require_409256__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var format_1 = __nested_webpack_require_409256__(18);\n            var Registry = __nested_webpack_require_409256__(1);\n            var BlockBlot = /** @class */ function(_super) {\n                __extends(BlockBlot, _super);\n                function BlockBlot() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                BlockBlot.formats = function(domNode) {\n                    var tagName = Registry.query(BlockBlot.blotName).tagName;\n                    if (domNode.tagName === tagName) return undefined;\n                    return _super.formats.call(this, domNode);\n                };\n                BlockBlot.prototype.format = function(name, value) {\n                    if (Registry.query(name, Registry.Scope.BLOCK) == null) {\n                        return;\n                    } else if (name === this.statics.blotName && !value) {\n                        this.replaceWith(BlockBlot.blotName);\n                    } else {\n                        _super.prototype.format.call(this, name, value);\n                    }\n                };\n                BlockBlot.prototype.formatAt = function(index, length, name, value) {\n                    if (Registry.query(name, Registry.Scope.BLOCK) != null) {\n                        this.format(name, value);\n                    } else {\n                        _super.prototype.formatAt.call(this, index, length, name, value);\n                    }\n                };\n                BlockBlot.prototype.insertAt = function(index, value, def) {\n                    if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {\n                        // Insert text or inline\n                        _super.prototype.insertAt.call(this, index, value, def);\n                    } else {\n                        var after = this.split(index);\n                        var blot = Registry.create(value, def);\n                        after.parent.insertBefore(blot, after);\n                    }\n                };\n                BlockBlot.prototype.update = function(mutations, context) {\n                    if (navigator.userAgent.match(/Trident/)) {\n                        this.build();\n                    } else {\n                        _super.prototype.update.call(this, mutations, context);\n                    }\n                };\n                BlockBlot.blotName = \"block\";\n                BlockBlot.scope = Registry.Scope.BLOCK_BLOT;\n                BlockBlot.tagName = \"P\";\n                return BlockBlot;\n            }(format_1.default);\n            exports1.default = BlockBlot;\n        /***/ },\n        /* 48 */ /***/ function(module1, exports1, __nested_webpack_require_412804__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var leaf_1 = __nested_webpack_require_412804__(19);\n            var EmbedBlot = /** @class */ function(_super) {\n                __extends(EmbedBlot, _super);\n                function EmbedBlot() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                EmbedBlot.formats = function(domNode) {\n                    return undefined;\n                };\n                EmbedBlot.prototype.format = function(name, value) {\n                    // super.formatAt wraps, which is what we want in general,\n                    // but this allows subclasses to overwrite for formats\n                    // that just apply to particular embeds\n                    _super.prototype.formatAt.call(this, 0, this.length(), name, value);\n                };\n                EmbedBlot.prototype.formatAt = function(index, length, name, value) {\n                    if (index === 0 && length === this.length()) {\n                        this.format(name, value);\n                    } else {\n                        _super.prototype.formatAt.call(this, index, length, name, value);\n                    }\n                };\n                EmbedBlot.prototype.formats = function() {\n                    return this.statics.formats(this.domNode);\n                };\n                return EmbedBlot;\n            }(leaf_1.default);\n            exports1.default = EmbedBlot;\n        /***/ },\n        /* 49 */ /***/ function(module1, exports1, __nested_webpack_require_415154__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var leaf_1 = __nested_webpack_require_415154__(19);\n            var Registry = __nested_webpack_require_415154__(1);\n            var TextBlot = /** @class */ function(_super) {\n                __extends(TextBlot, _super);\n                function TextBlot(node) {\n                    var _this = _super.call(this, node) || this;\n                    _this.text = _this.statics.value(_this.domNode);\n                    return _this;\n                }\n                TextBlot.create = function(value) {\n                    return document.createTextNode(value);\n                };\n                TextBlot.value = function(domNode) {\n                    var text = domNode.data;\n                    // @ts-ignore\n                    if (text[\"normalize\"]) text = text[\"normalize\"]();\n                    return text;\n                };\n                TextBlot.prototype.deleteAt = function(index, length) {\n                    this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);\n                };\n                TextBlot.prototype.index = function(node, offset) {\n                    if (this.domNode === node) {\n                        return offset;\n                    }\n                    return -1;\n                };\n                TextBlot.prototype.insertAt = function(index, value, def) {\n                    if (def == null) {\n                        this.text = this.text.slice(0, index) + value + this.text.slice(index);\n                        this.domNode.data = this.text;\n                    } else {\n                        _super.prototype.insertAt.call(this, index, value, def);\n                    }\n                };\n                TextBlot.prototype.length = function() {\n                    return this.text.length;\n                };\n                TextBlot.prototype.optimize = function(context) {\n                    _super.prototype.optimize.call(this, context);\n                    this.text = this.statics.value(this.domNode);\n                    if (this.text.length === 0) {\n                        this.remove();\n                    } else if (this.next instanceof TextBlot && this.next.prev === this) {\n                        this.insertAt(this.length(), this.next.value());\n                        this.next.remove();\n                    }\n                };\n                TextBlot.prototype.position = function(index, inclusive) {\n                    if (inclusive === void 0) {\n                        inclusive = false;\n                    }\n                    return [\n                        this.domNode,\n                        index\n                    ];\n                };\n                TextBlot.prototype.split = function(index, force) {\n                    if (force === void 0) {\n                        force = false;\n                    }\n                    if (!force) {\n                        if (index === 0) return this;\n                        if (index === this.length()) return this.next;\n                    }\n                    var after = Registry.create(this.domNode.splitText(index));\n                    this.parent.insertBefore(after, this.next);\n                    this.text = this.statics.value(this.domNode);\n                    return after;\n                };\n                TextBlot.prototype.update = function(mutations, context) {\n                    var _this = this;\n                    if (mutations.some(function(mutation) {\n                        return mutation.type === \"characterData\" && mutation.target === _this.domNode;\n                    })) {\n                        this.text = this.statics.value(this.domNode);\n                    }\n                };\n                TextBlot.prototype.value = function() {\n                    return this.text;\n                };\n                TextBlot.blotName = \"text\";\n                TextBlot.scope = Registry.Scope.INLINE_BLOT;\n                return TextBlot;\n            }(leaf_1.default);\n            exports1.default = TextBlot;\n        /***/ },\n        /* 50 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var elem = document.createElement(\"div\");\n            elem.classList.toggle(\"test-class\", false);\n            if (elem.classList.contains(\"test-class\")) {\n                var _toggle = DOMTokenList.prototype.toggle;\n                DOMTokenList.prototype.toggle = function(token, force) {\n                    if (arguments.length > 1 && !this.contains(token) === !force) {\n                        return force;\n                    } else {\n                        return _toggle.call(this, token);\n                    }\n                };\n            }\n            if (!String.prototype.startsWith) {\n                String.prototype.startsWith = function(searchString, position) {\n                    position = position || 0;\n                    return this.substr(position, searchString.length) === searchString;\n                };\n            }\n            if (!String.prototype.endsWith) {\n                String.prototype.endsWith = function(searchString, position) {\n                    var subjectString = this.toString();\n                    if (typeof position !== \"number\" || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\n                        position = subjectString.length;\n                    }\n                    position -= searchString.length;\n                    var lastIndex = subjectString.indexOf(searchString, position);\n                    return lastIndex !== -1 && lastIndex === position;\n                };\n            }\n            if (!Array.prototype.find) {\n                Object.defineProperty(Array.prototype, \"find\", {\n                    value: function value(predicate) {\n                        if (this === null) {\n                            throw new TypeError(\"Array.prototype.find called on null or undefined\");\n                        }\n                        if (typeof predicate !== \"function\") {\n                            throw new TypeError(\"predicate must be a function\");\n                        }\n                        var list = Object(this);\n                        var length = list.length >>> 0;\n                        var thisArg = arguments[1];\n                        var value;\n                        for(var i = 0; i < length; i++){\n                            value = list[i];\n                            if (predicate.call(thisArg, value, i, list)) {\n                                return value;\n                            }\n                        }\n                        return undefined;\n                    }\n                });\n            }\n            document.addEventListener(\"DOMContentLoaded\", function() {\n                // Disable resizing in Firefox\n                document.execCommand(\"enableObjectResizing\", false, false);\n                // Disable automatic linkifying in IE11\n                document.execCommand(\"autoUrlDetect\", false, false);\n            });\n        /***/ },\n        /* 51 */ /***/ function(module1, exports1) {\n            /**\n * This library modifies the diff-patch-match library by Neil Fraser\n * by removing the patch and match functionality and certain advanced\n * options in the diff function. The original license is as follows:\n *\n * ===\n *\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */ var DIFF_DELETE = -1;\n            var DIFF_INSERT = 1;\n            var DIFF_EQUAL = 0;\n            /**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {Int} cursor_pos Expected edit position in text1 (optional)\n * @return {Array} Array of diff tuples.\n */ function diff_main(text1, text2, cursor_pos) {\n                // Check for equality (speedup).\n                if (text1 == text2) {\n                    if (text1) {\n                        return [\n                            [\n                                DIFF_EQUAL,\n                                text1\n                            ]\n                        ];\n                    }\n                    return [];\n                }\n                // Check cursor_pos within bounds\n                if (cursor_pos < 0 || text1.length < cursor_pos) {\n                    cursor_pos = null;\n                }\n                // Trim off common prefix (speedup).\n                var commonlength = diff_commonPrefix(text1, text2);\n                var commonprefix = text1.substring(0, commonlength);\n                text1 = text1.substring(commonlength);\n                text2 = text2.substring(commonlength);\n                // Trim off common suffix (speedup).\n                commonlength = diff_commonSuffix(text1, text2);\n                var commonsuffix = text1.substring(text1.length - commonlength);\n                text1 = text1.substring(0, text1.length - commonlength);\n                text2 = text2.substring(0, text2.length - commonlength);\n                // Compute the diff on the middle block.\n                var diffs = diff_compute_(text1, text2);\n                // Restore the prefix and suffix.\n                if (commonprefix) {\n                    diffs.unshift([\n                        DIFF_EQUAL,\n                        commonprefix\n                    ]);\n                }\n                if (commonsuffix) {\n                    diffs.push([\n                        DIFF_EQUAL,\n                        commonsuffix\n                    ]);\n                }\n                diff_cleanupMerge(diffs);\n                if (cursor_pos != null) {\n                    diffs = fix_cursor(diffs, cursor_pos);\n                }\n                diffs = fix_emoji(diffs);\n                return diffs;\n            }\n            ;\n            /**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n */ function diff_compute_(text1, text2) {\n                var diffs;\n                if (!text1) {\n                    // Just add some text (speedup).\n                    return [\n                        [\n                            DIFF_INSERT,\n                            text2\n                        ]\n                    ];\n                }\n                if (!text2) {\n                    // Just delete some text (speedup).\n                    return [\n                        [\n                            DIFF_DELETE,\n                            text1\n                        ]\n                    ];\n                }\n                var longtext = text1.length > text2.length ? text1 : text2;\n                var shorttext = text1.length > text2.length ? text2 : text1;\n                var i = longtext.indexOf(shorttext);\n                if (i != -1) {\n                    // Shorter text is inside the longer text (speedup).\n                    diffs = [\n                        [\n                            DIFF_INSERT,\n                            longtext.substring(0, i)\n                        ],\n                        [\n                            DIFF_EQUAL,\n                            shorttext\n                        ],\n                        [\n                            DIFF_INSERT,\n                            longtext.substring(i + shorttext.length)\n                        ]\n                    ];\n                    // Swap insertions for deletions if diff is reversed.\n                    if (text1.length > text2.length) {\n                        diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n                    }\n                    return diffs;\n                }\n                if (shorttext.length == 1) {\n                    // Single character string.\n                    // After the previous speedup, the character can't be an equality.\n                    return [\n                        [\n                            DIFF_DELETE,\n                            text1\n                        ],\n                        [\n                            DIFF_INSERT,\n                            text2\n                        ]\n                    ];\n                }\n                // Check to see if the problem can be split in two.\n                var hm = diff_halfMatch_(text1, text2);\n                if (hm) {\n                    // A half-match was found, sort out the return data.\n                    var text1_a = hm[0];\n                    var text1_b = hm[1];\n                    var text2_a = hm[2];\n                    var text2_b = hm[3];\n                    var mid_common = hm[4];\n                    // Send both pairs off for separate processing.\n                    var diffs_a = diff_main(text1_a, text2_a);\n                    var diffs_b = diff_main(text1_b, text2_b);\n                    // Merge the results.\n                    return diffs_a.concat([\n                        [\n                            DIFF_EQUAL,\n                            mid_common\n                        ]\n                    ], diffs_b);\n                }\n                return diff_bisect_(text1, text2);\n            }\n            ;\n            /**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n * @private\n */ function diff_bisect_(text1, text2) {\n                // Cache the text lengths to prevent multiple calls.\n                var text1_length = text1.length;\n                var text2_length = text2.length;\n                var max_d = Math.ceil((text1_length + text2_length) / 2);\n                var v_offset = max_d;\n                var v_length = 2 * max_d;\n                var v1 = new Array(v_length);\n                var v2 = new Array(v_length);\n                // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n                // integers and undefined.\n                for(var x = 0; x < v_length; x++){\n                    v1[x] = -1;\n                    v2[x] = -1;\n                }\n                v1[v_offset + 1] = 0;\n                v2[v_offset + 1] = 0;\n                var delta = text1_length - text2_length;\n                // If the total number of characters is odd, then the front path will collide\n                // with the reverse path.\n                var front = delta % 2 != 0;\n                // Offsets for start and end of k loop.\n                // Prevents mapping of space beyond the grid.\n                var k1start = 0;\n                var k1end = 0;\n                var k2start = 0;\n                var k2end = 0;\n                for(var d = 0; d < max_d; d++){\n                    // Walk the front path one step.\n                    for(var k1 = -d + k1start; k1 <= d - k1end; k1 += 2){\n                        var k1_offset = v_offset + k1;\n                        var x1;\n                        if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {\n                            x1 = v1[k1_offset + 1];\n                        } else {\n                            x1 = v1[k1_offset - 1] + 1;\n                        }\n                        var y1 = x1 - k1;\n                        while(x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)){\n                            x1++;\n                            y1++;\n                        }\n                        v1[k1_offset] = x1;\n                        if (x1 > text1_length) {\n                            // Ran off the right of the graph.\n                            k1end += 2;\n                        } else if (y1 > text2_length) {\n                            // Ran off the bottom of the graph.\n                            k1start += 2;\n                        } else if (front) {\n                            var k2_offset = v_offset + delta - k1;\n                            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n                                // Mirror x2 onto top-left coordinate system.\n                                var x2 = text1_length - v2[k2_offset];\n                                if (x1 >= x2) {\n                                    // Overlap detected.\n                                    return diff_bisectSplit_(text1, text2, x1, y1);\n                                }\n                            }\n                        }\n                    }\n                    // Walk the reverse path one step.\n                    for(var k2 = -d + k2start; k2 <= d - k2end; k2 += 2){\n                        var k2_offset = v_offset + k2;\n                        var x2;\n                        if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {\n                            x2 = v2[k2_offset + 1];\n                        } else {\n                            x2 = v2[k2_offset - 1] + 1;\n                        }\n                        var y2 = x2 - k2;\n                        while(x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)){\n                            x2++;\n                            y2++;\n                        }\n                        v2[k2_offset] = x2;\n                        if (x2 > text1_length) {\n                            // Ran off the left of the graph.\n                            k2end += 2;\n                        } else if (y2 > text2_length) {\n                            // Ran off the top of the graph.\n                            k2start += 2;\n                        } else if (!front) {\n                            var k1_offset = v_offset + delta - k2;\n                            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n                                var x1 = v1[k1_offset];\n                                var y1 = v_offset + x1 - k1_offset;\n                                // Mirror x2 onto top-left coordinate system.\n                                x2 = text1_length - x2;\n                                if (x1 >= x2) {\n                                    // Overlap detected.\n                                    return diff_bisectSplit_(text1, text2, x1, y1);\n                                }\n                            }\n                        }\n                    }\n                }\n                // Diff took too long and hit the deadline or\n                // number of diffs equals number of characters, no commonality at all.\n                return [\n                    [\n                        DIFF_DELETE,\n                        text1\n                    ],\n                    [\n                        DIFF_INSERT,\n                        text2\n                    ]\n                ];\n            }\n            ;\n            /**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @return {Array} Array of diff tuples.\n */ function diff_bisectSplit_(text1, text2, x, y) {\n                var text1a = text1.substring(0, x);\n                var text2a = text2.substring(0, y);\n                var text1b = text1.substring(x);\n                var text2b = text2.substring(y);\n                // Compute both diffs serially.\n                var diffs = diff_main(text1a, text2a);\n                var diffsb = diff_main(text1b, text2b);\n                return diffs.concat(diffsb);\n            }\n            ;\n            /**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */ function diff_commonPrefix(text1, text2) {\n                // Quick check for common null cases.\n                if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n                    return 0;\n                }\n                // Binary search.\n                // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n                var pointermin = 0;\n                var pointermax = Math.min(text1.length, text2.length);\n                var pointermid = pointermax;\n                var pointerstart = 0;\n                while(pointermin < pointermid){\n                    if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {\n                        pointermin = pointermid;\n                        pointerstart = pointermin;\n                    } else {\n                        pointermax = pointermid;\n                    }\n                    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n                }\n                return pointermid;\n            }\n            ;\n            /**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */ function diff_commonSuffix(text1, text2) {\n                // Quick check for common null cases.\n                if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n                    return 0;\n                }\n                // Binary search.\n                // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n                var pointermin = 0;\n                var pointermax = Math.min(text1.length, text2.length);\n                var pointermid = pointermax;\n                var pointerend = 0;\n                while(pointermin < pointermid){\n                    if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n                        pointermin = pointermid;\n                        pointerend = pointermin;\n                    } else {\n                        pointermax = pointermid;\n                    }\n                    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n                }\n                return pointermid;\n            }\n            ;\n            /**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n */ function diff_halfMatch_(text1, text2) {\n                var longtext = text1.length > text2.length ? text1 : text2;\n                var shorttext = text1.length > text2.length ? text2 : text1;\n                if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n                    return null; // Pointless.\n                }\n                /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */ function diff_halfMatchI_(longtext, shorttext, i) {\n                    // Start with a 1/4 length substring at position i as a seed.\n                    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n                    var j = -1;\n                    var best_common = \"\";\n                    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n                    while((j = shorttext.indexOf(seed, j + 1)) != -1){\n                        var prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));\n                        var suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n                        if (best_common.length < suffixLength + prefixLength) {\n                            best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n                            best_longtext_a = longtext.substring(0, i - suffixLength);\n                            best_longtext_b = longtext.substring(i + prefixLength);\n                            best_shorttext_a = shorttext.substring(0, j - suffixLength);\n                            best_shorttext_b = shorttext.substring(j + prefixLength);\n                        }\n                    }\n                    if (best_common.length * 2 >= longtext.length) {\n                        return [\n                            best_longtext_a,\n                            best_longtext_b,\n                            best_shorttext_a,\n                            best_shorttext_b,\n                            best_common\n                        ];\n                    } else {\n                        return null;\n                    }\n                }\n                // First check if the second quarter is the seed for a half-match.\n                var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));\n                // Check again based on the third quarter.\n                var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));\n                var hm;\n                if (!hm1 && !hm2) {\n                    return null;\n                } else if (!hm2) {\n                    hm = hm1;\n                } else if (!hm1) {\n                    hm = hm2;\n                } else {\n                    // Both matched.  Select the longest.\n                    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n                }\n                // A half-match was found, sort out the return data.\n                var text1_a, text1_b, text2_a, text2_b;\n                if (text1.length > text2.length) {\n                    text1_a = hm[0];\n                    text1_b = hm[1];\n                    text2_a = hm[2];\n                    text2_b = hm[3];\n                } else {\n                    text2_a = hm[0];\n                    text2_b = hm[1];\n                    text1_a = hm[2];\n                    text1_b = hm[3];\n                }\n                var mid_common = hm[4];\n                return [\n                    text1_a,\n                    text1_b,\n                    text2_a,\n                    text2_b,\n                    mid_common\n                ];\n            }\n            ;\n            /**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {Array} diffs Array of diff tuples.\n */ function diff_cleanupMerge(diffs) {\n                diffs.push([\n                    DIFF_EQUAL,\n                    \"\"\n                ]); // Add a dummy entry at the end.\n                var pointer = 0;\n                var count_delete = 0;\n                var count_insert = 0;\n                var text_delete = \"\";\n                var text_insert = \"\";\n                var commonlength;\n                while(pointer < diffs.length){\n                    switch(diffs[pointer][0]){\n                        case DIFF_INSERT:\n                            count_insert++;\n                            text_insert += diffs[pointer][1];\n                            pointer++;\n                            break;\n                        case DIFF_DELETE:\n                            count_delete++;\n                            text_delete += diffs[pointer][1];\n                            pointer++;\n                            break;\n                        case DIFF_EQUAL:\n                            // Upon reaching an equality, check for prior redundancies.\n                            if (count_delete + count_insert > 1) {\n                                if (count_delete !== 0 && count_insert !== 0) {\n                                    // Factor out any common prefixies.\n                                    commonlength = diff_commonPrefix(text_insert, text_delete);\n                                    if (commonlength !== 0) {\n                                        if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {\n                                            diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);\n                                        } else {\n                                            diffs.splice(0, 0, [\n                                                DIFF_EQUAL,\n                                                text_insert.substring(0, commonlength)\n                                            ]);\n                                            pointer++;\n                                        }\n                                        text_insert = text_insert.substring(commonlength);\n                                        text_delete = text_delete.substring(commonlength);\n                                    }\n                                    // Factor out any common suffixies.\n                                    commonlength = diff_commonSuffix(text_insert, text_delete);\n                                    if (commonlength !== 0) {\n                                        diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n                                        text_insert = text_insert.substring(0, text_insert.length - commonlength);\n                                        text_delete = text_delete.substring(0, text_delete.length - commonlength);\n                                    }\n                                }\n                                // Delete the offending records and add the merged ones.\n                                if (count_delete === 0) {\n                                    diffs.splice(pointer - count_insert, count_delete + count_insert, [\n                                        DIFF_INSERT,\n                                        text_insert\n                                    ]);\n                                } else if (count_insert === 0) {\n                                    diffs.splice(pointer - count_delete, count_delete + count_insert, [\n                                        DIFF_DELETE,\n                                        text_delete\n                                    ]);\n                                } else {\n                                    diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [\n                                        DIFF_DELETE,\n                                        text_delete\n                                    ], [\n                                        DIFF_INSERT,\n                                        text_insert\n                                    ]);\n                                }\n                                pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n                            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n                                // Merge this equality with the previous one.\n                                diffs[pointer - 1][1] += diffs[pointer][1];\n                                diffs.splice(pointer, 1);\n                            } else {\n                                pointer++;\n                            }\n                            count_insert = 0;\n                            count_delete = 0;\n                            text_delete = \"\";\n                            text_insert = \"\";\n                            break;\n                    }\n                }\n                if (diffs[diffs.length - 1][1] === \"\") {\n                    diffs.pop(); // Remove the dummy entry at the end.\n                }\n                // Second pass: look for single edits surrounded on both sides by equalities\n                // which can be shifted sideways to eliminate an equality.\n                // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n                var changes = false;\n                pointer = 1;\n                // Intentionally ignore the first and last element (don't need checking).\n                while(pointer < diffs.length - 1){\n                    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {\n                        // This is a single edit surrounded by equalities.\n                        if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n                            // Shift the edit over the previous equality.\n                            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n                            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n                            diffs.splice(pointer - 1, 1);\n                            changes = true;\n                        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {\n                            // Shift the edit over the next equality.\n                            diffs[pointer - 1][1] += diffs[pointer + 1][1];\n                            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n                            diffs.splice(pointer + 1, 1);\n                            changes = true;\n                        }\n                    }\n                    pointer++;\n                }\n                // If shifts were made, the diff needs reordering and another shift sweep.\n                if (changes) {\n                    diff_cleanupMerge(diffs);\n                }\n            }\n            ;\n            var diff = diff_main;\n            diff.INSERT = DIFF_INSERT;\n            diff.DELETE = DIFF_DELETE;\n            diff.EQUAL = DIFF_EQUAL;\n            module1.exports = diff;\n            /*\n * Modify a diff such that the cursor position points to the start of a change:\n * E.g.\n *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)\n *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]\n *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)\n *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]\n *\n * @param {Array} diffs Array of diff tuples\n * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!\n * @return {Array} A tuple [cursor location in the modified diff, modified diff]\n */ function cursor_normalize_diff(diffs, cursor_pos) {\n                if (cursor_pos === 0) {\n                    return [\n                        DIFF_EQUAL,\n                        diffs\n                    ];\n                }\n                for(var current_pos = 0, i = 0; i < diffs.length; i++){\n                    var d = diffs[i];\n                    if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {\n                        var next_pos = current_pos + d[1].length;\n                        if (cursor_pos === next_pos) {\n                            return [\n                                i + 1,\n                                diffs\n                            ];\n                        } else if (cursor_pos < next_pos) {\n                            // copy to prevent side effects\n                            diffs = diffs.slice();\n                            // split d into two diff changes\n                            var split_pos = cursor_pos - current_pos;\n                            var d_left = [\n                                d[0],\n                                d[1].slice(0, split_pos)\n                            ];\n                            var d_right = [\n                                d[0],\n                                d[1].slice(split_pos)\n                            ];\n                            diffs.splice(i, 1, d_left, d_right);\n                            return [\n                                i + 1,\n                                diffs\n                            ];\n                        } else {\n                            current_pos = next_pos;\n                        }\n                    }\n                }\n                throw new Error(\"cursor_pos is out of bounds!\");\n            }\n            /*\n * Modify a diff such that the edit position is \"shifted\" to the proposed edit location (cursor_position).\n *\n * Case 1)\n *   Check if a naive shift is possible:\n *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)\n *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result\n * Case 2)\n *   Check if the following shifts are possible:\n *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']\n *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']\n *         ^            ^\n *         d          d_next\n *\n * @param {Array} diffs Array of diff tuples\n * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!\n * @return {Array} Array of diff tuples\n */ function fix_cursor(diffs, cursor_pos) {\n                var norm = cursor_normalize_diff(diffs, cursor_pos);\n                var ndiffs = norm[1];\n                var cursor_pointer = norm[0];\n                var d = ndiffs[cursor_pointer];\n                var d_next = ndiffs[cursor_pointer + 1];\n                if (d == null) {\n                    // Text was deleted from end of original string,\n                    // cursor is now out of bounds in new string\n                    return diffs;\n                } else if (d[0] !== DIFF_EQUAL) {\n                    // A modification happened at the cursor location.\n                    // This is the expected outcome, so we can return the original diff.\n                    return diffs;\n                } else {\n                    if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {\n                        // Case 1)\n                        // It is possible to perform a naive shift\n                        ndiffs.splice(cursor_pointer, 2, d_next, d);\n                        return merge_tuples(ndiffs, cursor_pointer, 2);\n                    } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {\n                        // Case 2)\n                        // d[1] is a prefix of d_next[1]\n                        // We can assume that d_next[0] !== 0, since d[0] === 0\n                        // Shift edit locations..\n                        ndiffs.splice(cursor_pointer, 2, [\n                            d_next[0],\n                            d[1]\n                        ], [\n                            0,\n                            d[1]\n                        ]);\n                        var suffix = d_next[1].slice(d[1].length);\n                        if (suffix.length > 0) {\n                            ndiffs.splice(cursor_pointer + 2, 0, [\n                                d_next[0],\n                                suffix\n                            ]);\n                        }\n                        return merge_tuples(ndiffs, cursor_pointer, 3);\n                    } else {\n                        // Not possible to perform any modification\n                        return diffs;\n                    }\n                }\n            }\n            /*\n * Check diff did not split surrogate pairs.\n * Ex. [0, '\\uD83D'], [-1, '\\uDC36'], [1, '\\uDC2F'] -> [-1, '\\uD83D\\uDC36'], [1, '\\uD83D\\uDC2F']\n *     '\\uD83D\\uDC36' === '🐶', '\\uD83D\\uDC2F' === '🐯'\n *\n * @param {Array} diffs Array of diff tuples\n * @return {Array} Array of diff tuples\n */ function fix_emoji(diffs) {\n                var compact = false;\n                var starts_with_pair_end = function(str) {\n                    return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;\n                };\n                var ends_with_pair_start = function(str) {\n                    return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;\n                };\n                for(var i = 2; i < diffs.length; i += 1){\n                    if (diffs[i - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i - 2][1]) && diffs[i - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i - 1][1]) && diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {\n                        compact = true;\n                        diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];\n                        diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];\n                        diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);\n                    }\n                }\n                if (!compact) {\n                    return diffs;\n                }\n                var fixed_diffs = [];\n                for(var i = 0; i < diffs.length; i += 1){\n                    if (diffs[i][1].length > 0) {\n                        fixed_diffs.push(diffs[i]);\n                    }\n                }\n                return fixed_diffs;\n            }\n            /*\n * Try to merge tuples with their neigbors in a given range.\n * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']\n *\n * @param {Array} diffs Array of diff tuples.\n * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).\n * @param {Int} length Number of consecutive elements to check.\n * @return {Array} Array of merged diff tuples.\n */ function merge_tuples(diffs, start, length) {\n                // Check from (start-1) to (start+length).\n                for(var i = start + length - 1; i >= 0 && i >= start - 1; i--){\n                    if (i + 1 < diffs.length) {\n                        var left_d = diffs[i];\n                        var right_d = diffs[i + 1];\n                        if (left_d[0] === right_d[1]) {\n                            diffs.splice(i, 2, [\n                                left_d[0],\n                                left_d[1] + right_d[1]\n                            ]);\n                        }\n                    }\n                }\n                return diffs;\n            }\n        /***/ },\n        /* 52 */ /***/ function(module1, exports1) {\n            exports1 = module1.exports = typeof Object.keys === \"function\" ? Object.keys : shim;\n            exports1.shim = shim;\n            function shim(obj) {\n                var keys = [];\n                for(var key in obj)keys.push(key);\n                return keys;\n            }\n        /***/ },\n        /* 53 */ /***/ function(module1, exports1) {\n            var supportsArgumentsClass = function() {\n                return Object.prototype.toString.call(arguments);\n            }() == \"[object Arguments]\";\n            exports1 = module1.exports = supportsArgumentsClass ? supported : unsupported;\n            exports1.supported = supported;\n            function supported(object) {\n                return Object.prototype.toString.call(object) == \"[object Arguments]\";\n            }\n            ;\n            exports1.unsupported = unsupported;\n            function unsupported(object) {\n                return object && typeof object == \"object\" && typeof object.length == \"number\" && Object.prototype.hasOwnProperty.call(object, \"callee\") && !Object.prototype.propertyIsEnumerable.call(object, \"callee\") || false;\n            }\n            ;\n        /***/ },\n        /* 54 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            var has = Object.prototype.hasOwnProperty, prefix = \"~\";\n            /**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @api private\n */ function Events() {}\n            //\n            // We try to not inherit from `Object.prototype`. In some engines creating an\n            // instance in this way is faster than calling `Object.create(null)` directly.\n            // If `Object.create(null)` is not supported we prefix the event names with a\n            // character to make sure that the built-in object properties are not\n            // overridden or used as an attack vector.\n            //\n            if (Object.create) {\n                Events.prototype = Object.create(null);\n                //\n                // This hack is needed because the `__proto__` property is still inherited in\n                // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n                //\n                if (!new Events().__proto__) prefix = false;\n            }\n            /**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {Mixed} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @api private\n */ function EE(fn, context, once) {\n                this.fn = fn;\n                this.context = context;\n                this.once = once || false;\n            }\n            /**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @api public\n */ function EventEmitter() {\n                this._events = new Events();\n                this._eventsCount = 0;\n            }\n            /**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */ EventEmitter.prototype.eventNames = function eventNames() {\n                var names = [], events, name;\n                if (this._eventsCount === 0) return names;\n                for(name in events = this._events){\n                    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n                }\n                if (Object.getOwnPropertySymbols) {\n                    return names.concat(Object.getOwnPropertySymbols(events));\n                }\n                return names;\n            };\n            /**\n * Return the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Boolean} exists Only check if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */ EventEmitter.prototype.listeners = function listeners(event, exists) {\n                var evt = prefix ? prefix + event : event, available = this._events[evt];\n                if (exists) return !!available;\n                if (!available) return [];\n                if (available.fn) return [\n                    available.fn\n                ];\n                for(var i = 0, l = available.length, ee = new Array(l); i < l; i++){\n                    ee[i] = available[i].fn;\n                }\n                return ee;\n            };\n            /**\n * Calls each of the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @api public\n */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n                var evt = prefix ? prefix + event : event;\n                if (!this._events[evt]) return false;\n                var listeners = this._events[evt], len = arguments.length, args, i;\n                if (listeners.fn) {\n                    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n                    switch(len){\n                        case 1:\n                            return listeners.fn.call(listeners.context), true;\n                        case 2:\n                            return listeners.fn.call(listeners.context, a1), true;\n                        case 3:\n                            return listeners.fn.call(listeners.context, a1, a2), true;\n                        case 4:\n                            return listeners.fn.call(listeners.context, a1, a2, a3), true;\n                        case 5:\n                            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n                        case 6:\n                            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n                    }\n                    for(i = 1, args = new Array(len - 1); i < len; i++){\n                        args[i - 1] = arguments[i];\n                    }\n                    listeners.fn.apply(listeners.context, args);\n                } else {\n                    var length = listeners.length, j;\n                    for(i = 0; i < length; i++){\n                        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n                        switch(len){\n                            case 1:\n                                listeners[i].fn.call(listeners[i].context);\n                                break;\n                            case 2:\n                                listeners[i].fn.call(listeners[i].context, a1);\n                                break;\n                            case 3:\n                                listeners[i].fn.call(listeners[i].context, a1, a2);\n                                break;\n                            case 4:\n                                listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                                break;\n                            default:\n                                if (!args) for(j = 1, args = new Array(len - 1); j < len; j++){\n                                    args[j - 1] = arguments[j];\n                                }\n                                listeners[i].fn.apply(listeners[i].context, args);\n                        }\n                    }\n                }\n                return true;\n            };\n            /**\n * Add a listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */ EventEmitter.prototype.on = function on(event, fn, context) {\n                var listener = new EE(fn, context || this), evt = prefix ? prefix + event : event;\n                if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n                else if (!this._events[evt].fn) this._events[evt].push(listener);\n                else this._events[evt] = [\n                    this._events[evt],\n                    listener\n                ];\n                return this;\n            };\n            /**\n * Add a one-time listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */ EventEmitter.prototype.once = function once(event, fn, context) {\n                var listener = new EE(fn, context || this, true), evt = prefix ? prefix + event : event;\n                if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n                else if (!this._events[evt].fn) this._events[evt].push(listener);\n                else this._events[evt] = [\n                    this._events[evt],\n                    listener\n                ];\n                return this;\n            };\n            /**\n * Remove the listeners of a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {Mixed} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @api public\n */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n                var evt = prefix ? prefix + event : event;\n                if (!this._events[evt]) return this;\n                if (!fn) {\n                    if (--this._eventsCount === 0) this._events = new Events();\n                    else delete this._events[evt];\n                    return this;\n                }\n                var listeners = this._events[evt];\n                if (listeners.fn) {\n                    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n                        if (--this._eventsCount === 0) this._events = new Events();\n                        else delete this._events[evt];\n                    }\n                } else {\n                    for(var i = 0, events = [], length = listeners.length; i < length; i++){\n                        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n                            events.push(listeners[i]);\n                        }\n                    }\n                    //\n                    // Reset the array, or remove it completely if we have no more listeners.\n                    //\n                    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n                    else if (--this._eventsCount === 0) this._events = new Events();\n                    else delete this._events[evt];\n                }\n                return this;\n            };\n            /**\n * Remove all listeners, or those of the specified event.\n *\n * @param {String|Symbol} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @api public\n */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n                var evt;\n                if (event) {\n                    evt = prefix ? prefix + event : event;\n                    if (this._events[evt]) {\n                        if (--this._eventsCount === 0) this._events = new Events();\n                        else delete this._events[evt];\n                    }\n                } else {\n                    this._events = new Events();\n                    this._eventsCount = 0;\n                }\n                return this;\n            };\n            //\n            // Alias methods names because people roll like that.\n            //\n            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n            EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n            //\n            // This function doesn't apply anymore.\n            //\n            EventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n                return this;\n            };\n            //\n            // Expose the prefix.\n            //\n            EventEmitter.prefixed = prefix;\n            //\n            // Allow `EventEmitter` to be imported as module namespace.\n            //\n            EventEmitter.EventEmitter = EventEmitter;\n            //\n            // Expose the module.\n            //\n            if (\"undefined\" !== typeof module1) {\n                module1.exports = EventEmitter;\n            }\n        /***/ },\n        /* 55 */ /***/ function(module1, exports1, __nested_webpack_require_472641__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.matchText = exports1.matchSpacing = exports1.matchNewline = exports1.matchBlot = exports1.matchAttributor = exports1.default = undefined;\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _extend2 = __nested_webpack_require_472641__(3);\n            var _extend3 = _interopRequireDefault(_extend2);\n            var _quillDelta = __nested_webpack_require_472641__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _parchment = __nested_webpack_require_472641__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_472641__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _logger = __nested_webpack_require_472641__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            var _module = __nested_webpack_require_472641__(9);\n            var _module2 = _interopRequireDefault(_module);\n            var _align = __nested_webpack_require_472641__(36);\n            var _background = __nested_webpack_require_472641__(37);\n            var _code = __nested_webpack_require_472641__(13);\n            var _code2 = _interopRequireDefault(_code);\n            var _color = __nested_webpack_require_472641__(26);\n            var _direction = __nested_webpack_require_472641__(38);\n            var _font = __nested_webpack_require_472641__(39);\n            var _size = __nested_webpack_require_472641__(40);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var debug = (0, _logger2.default)(\"quill:clipboard\");\n            var DOM_KEY = \"__ql-matcher\";\n            var CLIPBOARD_CONFIG = [\n                [\n                    Node.TEXT_NODE,\n                    matchText\n                ],\n                [\n                    Node.TEXT_NODE,\n                    matchNewline\n                ],\n                [\n                    \"br\",\n                    matchBreak\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchNewline\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchBlot\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchSpacing\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchAttributor\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchStyles\n                ],\n                [\n                    \"li\",\n                    matchIndent\n                ],\n                [\n                    \"b\",\n                    matchAlias.bind(matchAlias, \"bold\")\n                ],\n                [\n                    \"i\",\n                    matchAlias.bind(matchAlias, \"italic\")\n                ],\n                [\n                    \"style\",\n                    matchIgnore\n                ]\n            ];\n            var ATTRIBUTE_ATTRIBUTORS = [\n                _align.AlignAttribute,\n                _direction.DirectionAttribute\n            ].reduce(function(memo, attr) {\n                memo[attr.keyName] = attr;\n                return memo;\n            }, {});\n            var STYLE_ATTRIBUTORS = [\n                _align.AlignStyle,\n                _background.BackgroundStyle,\n                _color.ColorStyle,\n                _direction.DirectionStyle,\n                _font.FontStyle,\n                _size.SizeStyle\n            ].reduce(function(memo, attr) {\n                memo[attr.keyName] = attr;\n                return memo;\n            }, {});\n            var Clipboard = function(_Module) {\n                _inherits(Clipboard, _Module);\n                function Clipboard(quill, options) {\n                    _classCallCheck(this, Clipboard);\n                    var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this, quill, options));\n                    _this.quill.root.addEventListener(\"paste\", _this.onPaste.bind(_this));\n                    _this.container = _this.quill.addContainer(\"ql-clipboard\");\n                    _this.container.setAttribute(\"contenteditable\", true);\n                    _this.container.setAttribute(\"tabindex\", -1);\n                    _this.matchers = [];\n                    CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function(_ref) {\n                        var _ref2 = _slicedToArray(_ref, 2), selector = _ref2[0], matcher = _ref2[1];\n                        if (!options.matchVisual && matcher === matchSpacing) return;\n                        _this.addMatcher(selector, matcher);\n                    });\n                    return _this;\n                }\n                _createClass(Clipboard, [\n                    {\n                        key: \"addMatcher\",\n                        value: function addMatcher(selector, matcher) {\n                            this.matchers.push([\n                                selector,\n                                matcher\n                            ]);\n                        }\n                    },\n                    {\n                        key: \"convert\",\n                        value: function convert(html) {\n                            if (typeof html === \"string\") {\n                                this.container.innerHTML = html.replace(/\\>\\r?\\n +\\</g, \"><\"); // Remove spaces between tags\n                                return this.convert();\n                            }\n                            var formats = this.quill.getFormat(this.quill.selection.savedRange.index);\n                            if (formats[_code2.default.blotName]) {\n                                var text = this.container.innerText;\n                                this.container.innerHTML = \"\";\n                                return new _quillDelta2.default().insert(text, _defineProperty({}, _code2.default.blotName, formats[_code2.default.blotName]));\n                            }\n                            var _prepareMatching = this.prepareMatching(), _prepareMatching2 = _slicedToArray(_prepareMatching, 2), elementMatchers = _prepareMatching2[0], textMatchers = _prepareMatching2[1];\n                            var delta = traverse(this.container, elementMatchers, textMatchers);\n                            // Remove trailing newline\n                            if (deltaEndsWith(delta, \"\\n\") && delta.ops[delta.ops.length - 1].attributes == null) {\n                                delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));\n                            }\n                            debug.log(\"convert\", this.container.innerHTML, delta);\n                            this.container.innerHTML = \"\";\n                            return delta;\n                        }\n                    },\n                    {\n                        key: \"dangerouslyPasteHTML\",\n                        value: function dangerouslyPasteHTML(index, html) {\n                            var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _quill2.default.sources.API;\n                            if (typeof index === \"string\") {\n                                this.quill.setContents(this.convert(index), html);\n                                this.quill.setSelection(0, _quill2.default.sources.SILENT);\n                            } else {\n                                var paste = this.convert(html);\n                                this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste), source);\n                                this.quill.setSelection(index + paste.length(), _quill2.default.sources.SILENT);\n                            }\n                        }\n                    },\n                    {\n                        key: \"onPaste\",\n                        value: function onPaste(e) {\n                            var _this2 = this;\n                            if (e.defaultPrevented || !this.quill.isEnabled()) return;\n                            var range = this.quill.getSelection();\n                            var delta = new _quillDelta2.default().retain(range.index);\n                            var scrollTop = this.quill.scrollingContainer.scrollTop;\n                            this.container.focus();\n                            this.quill.selection.update(_quill2.default.sources.SILENT);\n                            setTimeout(function() {\n                                delta = delta.concat(_this2.convert()).delete(range.length);\n                                _this2.quill.updateContents(delta, _quill2.default.sources.USER);\n                                // range.length contributes to delta.length()\n                                _this2.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);\n                                _this2.quill.scrollingContainer.scrollTop = scrollTop;\n                                _this2.quill.focus();\n                            }, 1);\n                        }\n                    },\n                    {\n                        key: \"prepareMatching\",\n                        value: function prepareMatching() {\n                            var _this3 = this;\n                            var elementMatchers = [], textMatchers = [];\n                            this.matchers.forEach(function(pair) {\n                                var _pair = _slicedToArray(pair, 2), selector = _pair[0], matcher = _pair[1];\n                                switch(selector){\n                                    case Node.TEXT_NODE:\n                                        textMatchers.push(matcher);\n                                        break;\n                                    case Node.ELEMENT_NODE:\n                                        elementMatchers.push(matcher);\n                                        break;\n                                    default:\n                                        [].forEach.call(_this3.container.querySelectorAll(selector), function(node) {\n                                            // TODO use weakmap\n                                            node[DOM_KEY] = node[DOM_KEY] || [];\n                                            node[DOM_KEY].push(matcher);\n                                        });\n                                        break;\n                                }\n                            });\n                            return [\n                                elementMatchers,\n                                textMatchers\n                            ];\n                        }\n                    }\n                ]);\n                return Clipboard;\n            }(_module2.default);\n            Clipboard.DEFAULTS = {\n                matchers: [],\n                matchVisual: true\n            };\n            function applyFormat(delta, format, value) {\n                if ((typeof format === \"undefined\" ? \"undefined\" : _typeof(format)) === \"object\") {\n                    return Object.keys(format).reduce(function(delta, key) {\n                        return applyFormat(delta, key, format[key]);\n                    }, delta);\n                } else {\n                    return delta.reduce(function(delta, op) {\n                        if (op.attributes && op.attributes[format]) {\n                            return delta.push(op);\n                        } else {\n                            return delta.insert(op.insert, (0, _extend3.default)({}, _defineProperty({}, format, value), op.attributes));\n                        }\n                    }, new _quillDelta2.default());\n                }\n            }\n            function computeStyle(node) {\n                if (node.nodeType !== Node.ELEMENT_NODE) return {};\n                var DOM_KEY = \"__ql-computed-style\";\n                return node[DOM_KEY] || (node[DOM_KEY] = window.getComputedStyle(node));\n            }\n            function deltaEndsWith(delta, text) {\n                var endText = \"\";\n                for(var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i){\n                    var op = delta.ops[i];\n                    if (typeof op.insert !== \"string\") break;\n                    endText = op.insert + endText;\n                }\n                return endText.slice(-1 * text.length) === text;\n            }\n            function isLine(node) {\n                if (node.childNodes.length === 0) return false; // Exclude embed blocks\n                var style = computeStyle(node);\n                return [\n                    \"block\",\n                    \"list-item\"\n                ].indexOf(style.display) > -1;\n            }\n            function traverse(node, elementMatchers, textMatchers) {\n                // Post-order\n                if (node.nodeType === node.TEXT_NODE) {\n                    return textMatchers.reduce(function(delta, matcher) {\n                        return matcher(node, delta);\n                    }, new _quillDelta2.default());\n                } else if (node.nodeType === node.ELEMENT_NODE) {\n                    return [].reduce.call(node.childNodes || [], function(delta, childNode) {\n                        var childrenDelta = traverse(childNode, elementMatchers, textMatchers);\n                        if (childNode.nodeType === node.ELEMENT_NODE) {\n                            childrenDelta = elementMatchers.reduce(function(childrenDelta, matcher) {\n                                return matcher(childNode, childrenDelta);\n                            }, childrenDelta);\n                            childrenDelta = (childNode[DOM_KEY] || []).reduce(function(childrenDelta, matcher) {\n                                return matcher(childNode, childrenDelta);\n                            }, childrenDelta);\n                        }\n                        return delta.concat(childrenDelta);\n                    }, new _quillDelta2.default());\n                } else {\n                    return new _quillDelta2.default();\n                }\n            }\n            function matchAlias(format, node, delta) {\n                return applyFormat(delta, format, true);\n            }\n            function matchAttributor(node, delta) {\n                var attributes = _parchment2.default.Attributor.Attribute.keys(node);\n                var classes = _parchment2.default.Attributor.Class.keys(node);\n                var styles = _parchment2.default.Attributor.Style.keys(node);\n                var formats = {};\n                attributes.concat(classes).concat(styles).forEach(function(name) {\n                    var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);\n                    if (attr != null) {\n                        formats[attr.attrName] = attr.value(node);\n                        if (formats[attr.attrName]) return;\n                    }\n                    attr = ATTRIBUTE_ATTRIBUTORS[name];\n                    if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n                        formats[attr.attrName] = attr.value(node) || undefined;\n                    }\n                    attr = STYLE_ATTRIBUTORS[name];\n                    if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n                        attr = STYLE_ATTRIBUTORS[name];\n                        formats[attr.attrName] = attr.value(node) || undefined;\n                    }\n                });\n                if (Object.keys(formats).length > 0) {\n                    delta = applyFormat(delta, formats);\n                }\n                return delta;\n            }\n            function matchBlot(node, delta) {\n                var match = _parchment2.default.query(node);\n                if (match == null) return delta;\n                if (match.prototype instanceof _parchment2.default.Embed) {\n                    var embed = {};\n                    var value = match.value(node);\n                    if (value != null) {\n                        embed[match.blotName] = value;\n                        delta = new _quillDelta2.default().insert(embed, match.formats(node));\n                    }\n                } else if (typeof match.formats === \"function\") {\n                    delta = applyFormat(delta, match.blotName, match.formats(node));\n                }\n                return delta;\n            }\n            function matchBreak(node, delta) {\n                if (!deltaEndsWith(delta, \"\\n\")) {\n                    delta.insert(\"\\n\");\n                }\n                return delta;\n            }\n            function matchIgnore() {\n                return new _quillDelta2.default();\n            }\n            function matchIndent(node, delta) {\n                var match = _parchment2.default.query(node);\n                if (match == null || match.blotName !== \"list-item\" || !deltaEndsWith(delta, \"\\n\")) {\n                    return delta;\n                }\n                var indent = -1, parent = node.parentNode;\n                while(!parent.classList.contains(\"ql-clipboard\")){\n                    if ((_parchment2.default.query(parent) || {}).blotName === \"list\") {\n                        indent += 1;\n                    }\n                    parent = parent.parentNode;\n                }\n                if (indent <= 0) return delta;\n                return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, {\n                    indent: indent\n                }));\n            }\n            function matchNewline(node, delta) {\n                if (!deltaEndsWith(delta, \"\\n\")) {\n                    if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {\n                        delta.insert(\"\\n\");\n                    }\n                }\n                return delta;\n            }\n            function matchSpacing(node, delta) {\n                if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, \"\\n\\n\")) {\n                    var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);\n                    if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {\n                        delta.insert(\"\\n\");\n                    }\n                }\n                return delta;\n            }\n            function matchStyles(node, delta) {\n                var formats = {};\n                var style = node.style || {};\n                if (style.fontStyle && computeStyle(node).fontStyle === \"italic\") {\n                    formats.italic = true;\n                }\n                if (style.fontWeight && (computeStyle(node).fontWeight.startsWith(\"bold\") || parseInt(computeStyle(node).fontWeight) >= 700)) {\n                    formats.bold = true;\n                }\n                if (Object.keys(formats).length > 0) {\n                    delta = applyFormat(delta, formats);\n                }\n                if (parseFloat(style.textIndent || 0) > 0) {\n                    // Could be 0.5in\n                    delta = new _quillDelta2.default().insert(\"\t\").concat(delta);\n                }\n                return delta;\n            }\n            function matchText(node, delta) {\n                var text = node.data;\n                // Word represents empty line with <o:p>&nbsp;</o:p>\n                if (node.parentNode.tagName === \"O:P\") {\n                    return delta.insert(text.trim());\n                }\n                if (text.trim().length === 0 && node.parentNode.classList.contains(\"ql-clipboard\")) {\n                    return delta;\n                }\n                if (!computeStyle(node.parentNode).whiteSpace.startsWith(\"pre\")) {\n                    // eslint-disable-next-line func-style\n                    var replacer = function replacer(collapse, match) {\n                        match = match.replace(/[^\\u00a0]/g, \"\"); // \\u00a0 is nbsp;\n                        return match.length < 1 && collapse ? \" \" : match;\n                    };\n                    text = text.replace(/\\r\\n/g, \" \").replace(/\\n/g, \" \");\n                    text = text.replace(/\\s\\s+/g, replacer.bind(replacer, true)); // collapse whitespace\n                    if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {\n                        text = text.replace(/^\\s+/, replacer.bind(replacer, false));\n                    }\n                    if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {\n                        text = text.replace(/\\s+$/, replacer.bind(replacer, false));\n                    }\n                }\n                return delta.insert(text);\n            }\n            exports1.default = Clipboard;\n            exports1.matchAttributor = matchAttributor;\n            exports1.matchBlot = matchBlot;\n            exports1.matchNewline = matchNewline;\n            exports1.matchSpacing = matchSpacing;\n            exports1.matchText = matchText;\n        /***/ },\n        /* 56 */ /***/ function(module1, exports1, __nested_webpack_require_498229__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _inline = __nested_webpack_require_498229__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Bold = function(_Inline) {\n                _inherits(Bold, _Inline);\n                function Bold() {\n                    _classCallCheck(this, Bold);\n                    return _possibleConstructorReturn(this, (Bold.__proto__ || Object.getPrototypeOf(Bold)).apply(this, arguments));\n                }\n                _createClass(Bold, [\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            _get(Bold.prototype.__proto__ || Object.getPrototypeOf(Bold.prototype), \"optimize\", this).call(this, context);\n                            if (this.domNode.tagName !== this.statics.tagName[0]) {\n                                this.replaceWith(this.statics.blotName);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create() {\n                            return _get(Bold.__proto__ || Object.getPrototypeOf(Bold), \"create\", this).call(this);\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats() {\n                            return true;\n                        }\n                    }\n                ]);\n                return Bold;\n            }(_inline2.default);\n            Bold.blotName = \"bold\";\n            Bold.tagName = [\n                \"STRONG\",\n                \"B\"\n            ];\n            exports1.default = Bold;\n        /***/ },\n        /* 57 */ /***/ function(module1, exports1, __nested_webpack_require_503384__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.addControls = exports1.default = undefined;\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _quillDelta = __nested_webpack_require_503384__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _parchment = __nested_webpack_require_503384__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_503384__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _logger = __nested_webpack_require_503384__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            var _module = __nested_webpack_require_503384__(9);\n            var _module2 = _interopRequireDefault(_module);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var debug = (0, _logger2.default)(\"quill:toolbar\");\n            var Toolbar = function(_Module) {\n                _inherits(Toolbar, _Module);\n                function Toolbar(quill, options) {\n                    _classCallCheck(this, Toolbar);\n                    var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, quill, options));\n                    if (Array.isArray(_this.options.container)) {\n                        var container = document.createElement(\"div\");\n                        addControls(container, _this.options.container);\n                        quill.container.parentNode.insertBefore(container, quill.container);\n                        _this.container = container;\n                    } else if (typeof _this.options.container === \"string\") {\n                        _this.container = document.querySelector(_this.options.container);\n                    } else {\n                        _this.container = _this.options.container;\n                    }\n                    if (!(_this.container instanceof HTMLElement)) {\n                        var _ret;\n                        return _ret = debug.error(\"Container required for toolbar\", _this.options), _possibleConstructorReturn(_this, _ret);\n                    }\n                    _this.container.classList.add(\"ql-toolbar\");\n                    _this.controls = [];\n                    _this.handlers = {};\n                    Object.keys(_this.options.handlers).forEach(function(format) {\n                        _this.addHandler(format, _this.options.handlers[format]);\n                    });\n                    [].forEach.call(_this.container.querySelectorAll(\"button, select\"), function(input) {\n                        _this.attach(input);\n                    });\n                    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(type, range) {\n                        if (type === _quill2.default.events.SELECTION_CHANGE) {\n                            _this.update(range);\n                        }\n                    });\n                    _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {\n                        var _this$quill$selection = _this.quill.selection.getRange(), _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1), range = _this$quill$selection2[0]; // quill.getSelection triggers update\n                        _this.update(range);\n                    });\n                    return _this;\n                }\n                _createClass(Toolbar, [\n                    {\n                        key: \"addHandler\",\n                        value: function addHandler(format, handler) {\n                            this.handlers[format] = handler;\n                        }\n                    },\n                    {\n                        key: \"attach\",\n                        value: function attach(input) {\n                            var _this2 = this;\n                            var format = [].find.call(input.classList, function(className) {\n                                return className.indexOf(\"ql-\") === 0;\n                            });\n                            if (!format) return;\n                            format = format.slice(\"ql-\".length);\n                            if (input.tagName === \"BUTTON\") {\n                                input.setAttribute(\"type\", \"button\");\n                            }\n                            if (this.handlers[format] == null) {\n                                if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {\n                                    debug.warn(\"ignoring attaching to disabled format\", format, input);\n                                    return;\n                                }\n                                if (_parchment2.default.query(format) == null) {\n                                    debug.warn(\"ignoring attaching to nonexistent format\", format, input);\n                                    return;\n                                }\n                            }\n                            var eventName = input.tagName === \"SELECT\" ? \"change\" : \"click\";\n                            input.addEventListener(eventName, function(e) {\n                                var value = void 0;\n                                if (input.tagName === \"SELECT\") {\n                                    if (input.selectedIndex < 0) return;\n                                    var selected = input.options[input.selectedIndex];\n                                    if (selected.hasAttribute(\"selected\")) {\n                                        value = false;\n                                    } else {\n                                        value = selected.value || false;\n                                    }\n                                } else {\n                                    if (input.classList.contains(\"ql-active\")) {\n                                        value = false;\n                                    } else {\n                                        value = input.value || !input.hasAttribute(\"value\");\n                                    }\n                                    e.preventDefault();\n                                }\n                                _this2.quill.focus();\n                                var _quill$selection$getR = _this2.quill.selection.getRange(), _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1), range = _quill$selection$getR2[0];\n                                if (_this2.handlers[format] != null) {\n                                    _this2.handlers[format].call(_this2, value);\n                                } else if (_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed) {\n                                    value = prompt(\"Enter \" + format);\n                                    if (!value) return;\n                                    _this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({}, format, value)), _quill2.default.sources.USER);\n                                } else {\n                                    _this2.quill.format(format, value, _quill2.default.sources.USER);\n                                }\n                                _this2.update(range);\n                            });\n                            // TODO use weakmap\n                            this.controls.push([\n                                format,\n                                input\n                            ]);\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(range) {\n                            var formats = range == null ? {} : this.quill.getFormat(range);\n                            this.controls.forEach(function(pair) {\n                                var _pair = _slicedToArray(pair, 2), format = _pair[0], input = _pair[1];\n                                if (input.tagName === \"SELECT\") {\n                                    var option = void 0;\n                                    if (range == null) {\n                                        option = null;\n                                    } else if (formats[format] == null) {\n                                        option = input.querySelector(\"option[selected]\");\n                                    } else if (!Array.isArray(formats[format])) {\n                                        var value = formats[format];\n                                        if (typeof value === \"string\") {\n                                            value = value.replace(/\\\"/g, '\\\\\"');\n                                        }\n                                        option = input.querySelector('option[value=\"' + value + '\"]');\n                                    }\n                                    if (option == null) {\n                                        input.value = \"\"; // TODO make configurable?\n                                        input.selectedIndex = -1;\n                                    } else {\n                                        option.selected = true;\n                                    }\n                                } else {\n                                    if (range == null) {\n                                        input.classList.remove(\"ql-active\");\n                                    } else if (input.hasAttribute(\"value\")) {\n                                        // both being null should match (default values)\n                                        // '1' should match with 1 (headers)\n                                        var isActive = formats[format] === input.getAttribute(\"value\") || formats[format] != null && formats[format].toString() === input.getAttribute(\"value\") || formats[format] == null && !input.getAttribute(\"value\");\n                                        input.classList.toggle(\"ql-active\", isActive);\n                                    } else {\n                                        input.classList.toggle(\"ql-active\", formats[format] != null);\n                                    }\n                                }\n                            });\n                        }\n                    }\n                ]);\n                return Toolbar;\n            }(_module2.default);\n            Toolbar.DEFAULTS = {};\n            function addButton(container, format, value) {\n                var input = document.createElement(\"button\");\n                input.setAttribute(\"type\", \"button\");\n                input.classList.add(\"ql-\" + format);\n                if (value != null) {\n                    input.value = value;\n                }\n                container.appendChild(input);\n            }\n            function addControls(container, groups) {\n                if (!Array.isArray(groups[0])) {\n                    groups = [\n                        groups\n                    ];\n                }\n                groups.forEach(function(controls) {\n                    var group = document.createElement(\"span\");\n                    group.classList.add(\"ql-formats\");\n                    controls.forEach(function(control) {\n                        if (typeof control === \"string\") {\n                            addButton(group, control);\n                        } else {\n                            var format = Object.keys(control)[0];\n                            var value = control[format];\n                            if (Array.isArray(value)) {\n                                addSelect(group, format, value);\n                            } else {\n                                addButton(group, format, value);\n                            }\n                        }\n                    });\n                    container.appendChild(group);\n                });\n            }\n            function addSelect(container, format, values) {\n                var input = document.createElement(\"select\");\n                input.classList.add(\"ql-\" + format);\n                values.forEach(function(value) {\n                    var option = document.createElement(\"option\");\n                    if (value !== false) {\n                        option.setAttribute(\"value\", value);\n                    } else {\n                        option.setAttribute(\"selected\", \"selected\");\n                    }\n                    input.appendChild(option);\n                });\n                container.appendChild(input);\n            }\n            Toolbar.DEFAULTS = {\n                container: null,\n                handlers: {\n                    clean: function clean() {\n                        var _this3 = this;\n                        var range = this.quill.getSelection();\n                        if (range == null) return;\n                        if (range.length == 0) {\n                            var formats = this.quill.getFormat();\n                            Object.keys(formats).forEach(function(name) {\n                                // Clean functionality in existing apps only clean inline formats\n                                if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {\n                                    _this3.quill.format(name, false);\n                                }\n                            });\n                        } else {\n                            this.quill.removeFormat(range, _quill2.default.sources.USER);\n                        }\n                    },\n                    direction: function direction(value) {\n                        var align = this.quill.getFormat()[\"align\"];\n                        if (value === \"rtl\" && align == null) {\n                            this.quill.format(\"align\", \"right\", _quill2.default.sources.USER);\n                        } else if (!value && align === \"right\") {\n                            this.quill.format(\"align\", false, _quill2.default.sources.USER);\n                        }\n                        this.quill.format(\"direction\", value, _quill2.default.sources.USER);\n                    },\n                    indent: function indent(value) {\n                        var range = this.quill.getSelection();\n                        var formats = this.quill.getFormat(range);\n                        var indent = parseInt(formats.indent || 0);\n                        if (value === \"+1\" || value === \"-1\") {\n                            var modifier = value === \"+1\" ? 1 : -1;\n                            if (formats.direction === \"rtl\") modifier *= -1;\n                            this.quill.format(\"indent\", indent + modifier, _quill2.default.sources.USER);\n                        }\n                    },\n                    link: function link(value) {\n                        if (value === true) {\n                            value = prompt(\"Enter link URL:\");\n                        }\n                        this.quill.format(\"link\", value, _quill2.default.sources.USER);\n                    },\n                    list: function list(value) {\n                        var range = this.quill.getSelection();\n                        var formats = this.quill.getFormat(range);\n                        if (value === \"check\") {\n                            if (formats[\"list\"] === \"checked\" || formats[\"list\"] === \"unchecked\") {\n                                this.quill.format(\"list\", false, _quill2.default.sources.USER);\n                            } else {\n                                this.quill.format(\"list\", \"unchecked\", _quill2.default.sources.USER);\n                            }\n                        } else {\n                            this.quill.format(\"list\", value, _quill2.default.sources.USER);\n                        }\n                    }\n                }\n            };\n            exports1.default = Toolbar;\n            exports1.addControls = addControls;\n        /***/ },\n        /* 58 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>';\n        /***/ },\n        /* 59 */ /***/ function(module1, exports1, __nested_webpack_require_523738__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _picker = __nested_webpack_require_523738__(28);\n            var _picker2 = _interopRequireDefault(_picker);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ColorPicker = function(_Picker) {\n                _inherits(ColorPicker, _Picker);\n                function ColorPicker(select, label) {\n                    _classCallCheck(this, ColorPicker);\n                    var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, select));\n                    _this.label.innerHTML = label;\n                    _this.container.classList.add(\"ql-color-picker\");\n                    [].slice.call(_this.container.querySelectorAll(\".ql-picker-item\"), 0, 7).forEach(function(item) {\n                        item.classList.add(\"ql-primary\");\n                    });\n                    return _this;\n                }\n                _createClass(ColorPicker, [\n                    {\n                        key: \"buildItem\",\n                        value: function buildItem(option) {\n                            var item = _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), \"buildItem\", this).call(this, option);\n                            item.style.backgroundColor = option.getAttribute(\"value\") || \"\";\n                            return item;\n                        }\n                    },\n                    {\n                        key: \"selectItem\",\n                        value: function selectItem(item, trigger) {\n                            _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), \"selectItem\", this).call(this, item, trigger);\n                            var colorLabel = this.label.querySelector(\".ql-color-label\");\n                            var value = item ? item.getAttribute(\"data-value\") || \"\" : \"\";\n                            if (colorLabel) {\n                                if (colorLabel.tagName === \"line\") {\n                                    colorLabel.style.stroke = value;\n                                } else {\n                                    colorLabel.style.fill = value;\n                                }\n                            }\n                        }\n                    }\n                ]);\n                return ColorPicker;\n            }(_picker2.default);\n            exports1.default = ColorPicker;\n        /***/ },\n        /* 60 */ /***/ function(module1, exports1, __nested_webpack_require_529553__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _picker = __nested_webpack_require_529553__(28);\n            var _picker2 = _interopRequireDefault(_picker);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var IconPicker = function(_Picker) {\n                _inherits(IconPicker, _Picker);\n                function IconPicker(select, icons) {\n                    _classCallCheck(this, IconPicker);\n                    var _this = _possibleConstructorReturn(this, (IconPicker.__proto__ || Object.getPrototypeOf(IconPicker)).call(this, select));\n                    _this.container.classList.add(\"ql-icon-picker\");\n                    [].forEach.call(_this.container.querySelectorAll(\".ql-picker-item\"), function(item) {\n                        item.innerHTML = icons[item.getAttribute(\"data-value\") || \"\"];\n                    });\n                    _this.defaultItem = _this.container.querySelector(\".ql-selected\");\n                    _this.selectItem(_this.defaultItem);\n                    return _this;\n                }\n                _createClass(IconPicker, [\n                    {\n                        key: \"selectItem\",\n                        value: function selectItem(item, trigger) {\n                            _get(IconPicker.prototype.__proto__ || Object.getPrototypeOf(IconPicker.prototype), \"selectItem\", this).call(this, item, trigger);\n                            item = item || this.defaultItem;\n                            this.label.innerHTML = item.innerHTML;\n                        }\n                    }\n                ]);\n                return IconPicker;\n            }(_picker2.default);\n            exports1.default = IconPicker;\n        /***/ },\n        /* 61 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var Tooltip = function() {\n                function Tooltip(quill, boundsContainer) {\n                    var _this = this;\n                    _classCallCheck(this, Tooltip);\n                    this.quill = quill;\n                    this.boundsContainer = boundsContainer || document.body;\n                    this.root = quill.addContainer(\"ql-tooltip\");\n                    this.root.innerHTML = this.constructor.TEMPLATE;\n                    if (this.quill.root === this.quill.scrollingContainer) {\n                        this.quill.root.addEventListener(\"scroll\", function() {\n                            _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + \"px\";\n                        });\n                    }\n                    this.hide();\n                }\n                _createClass(Tooltip, [\n                    {\n                        key: \"hide\",\n                        value: function hide() {\n                            this.root.classList.add(\"ql-hidden\");\n                        }\n                    },\n                    {\n                        key: \"position\",\n                        value: function position(reference) {\n                            var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;\n                            // root.scrollTop should be 0 if scrollContainer !== root\n                            var top = reference.bottom + this.quill.root.scrollTop;\n                            this.root.style.left = left + \"px\";\n                            this.root.style.top = top + \"px\";\n                            this.root.classList.remove(\"ql-flip\");\n                            var containerBounds = this.boundsContainer.getBoundingClientRect();\n                            var rootBounds = this.root.getBoundingClientRect();\n                            var shift = 0;\n                            if (rootBounds.right > containerBounds.right) {\n                                shift = containerBounds.right - rootBounds.right;\n                                this.root.style.left = left + shift + \"px\";\n                            }\n                            if (rootBounds.left < containerBounds.left) {\n                                shift = containerBounds.left - rootBounds.left;\n                                this.root.style.left = left + shift + \"px\";\n                            }\n                            if (rootBounds.bottom > containerBounds.bottom) {\n                                var height = rootBounds.bottom - rootBounds.top;\n                                var verticalShift = reference.bottom - reference.top + height;\n                                this.root.style.top = top - verticalShift + \"px\";\n                                this.root.classList.add(\"ql-flip\");\n                            }\n                            return shift;\n                        }\n                    },\n                    {\n                        key: \"show\",\n                        value: function show() {\n                            this.root.classList.remove(\"ql-editing\");\n                            this.root.classList.remove(\"ql-hidden\");\n                        }\n                    }\n                ]);\n                return Tooltip;\n            }();\n            exports1.default = Tooltip;\n        /***/ },\n        /* 62 */ /***/ function(module1, exports1, __nested_webpack_require_539229__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _extend = __nested_webpack_require_539229__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _emitter = __nested_webpack_require_539229__(8);\n            var _emitter2 = _interopRequireDefault(_emitter);\n            var _base = __nested_webpack_require_539229__(43);\n            var _base2 = _interopRequireDefault(_base);\n            var _link = __nested_webpack_require_539229__(27);\n            var _link2 = _interopRequireDefault(_link);\n            var _selection = __nested_webpack_require_539229__(15);\n            var _icons = __nested_webpack_require_539229__(41);\n            var _icons2 = _interopRequireDefault(_icons);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var TOOLBAR_CONFIG = [\n                [\n                    {\n                        header: [\n                            \"1\",\n                            \"2\",\n                            \"3\",\n                            false\n                        ]\n                    }\n                ],\n                [\n                    \"bold\",\n                    \"italic\",\n                    \"underline\",\n                    \"link\"\n                ],\n                [\n                    {\n                        list: \"ordered\"\n                    },\n                    {\n                        list: \"bullet\"\n                    }\n                ],\n                [\n                    \"clean\"\n                ]\n            ];\n            var SnowTheme = function(_BaseTheme) {\n                _inherits(SnowTheme, _BaseTheme);\n                function SnowTheme(quill, options) {\n                    _classCallCheck(this, SnowTheme);\n                    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {\n                        options.modules.toolbar.container = TOOLBAR_CONFIG;\n                    }\n                    var _this = _possibleConstructorReturn(this, (SnowTheme.__proto__ || Object.getPrototypeOf(SnowTheme)).call(this, quill, options));\n                    _this.quill.container.classList.add(\"ql-snow\");\n                    return _this;\n                }\n                _createClass(SnowTheme, [\n                    {\n                        key: \"extendToolbar\",\n                        value: function extendToolbar(toolbar) {\n                            toolbar.container.classList.add(\"ql-snow\");\n                            this.buildButtons([].slice.call(toolbar.container.querySelectorAll(\"button\")), _icons2.default);\n                            this.buildPickers([].slice.call(toolbar.container.querySelectorAll(\"select\")), _icons2.default);\n                            this.tooltip = new SnowTooltip(this.quill, this.options.bounds);\n                            if (toolbar.container.querySelector(\".ql-link\")) {\n                                this.quill.keyboard.addBinding({\n                                    key: \"K\",\n                                    shortKey: true\n                                }, function(range, context) {\n                                    toolbar.handlers[\"link\"].call(toolbar, !context.format.link);\n                                });\n                            }\n                        }\n                    }\n                ]);\n                return SnowTheme;\n            }(_base2.default);\n            SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {\n                modules: {\n                    toolbar: {\n                        handlers: {\n                            link: function link(value) {\n                                if (value) {\n                                    var range = this.quill.getSelection();\n                                    if (range == null || range.length == 0) return;\n                                    var preview = this.quill.getText(range);\n                                    if (/^\\S+@\\S+\\.\\S+$/.test(preview) && preview.indexOf(\"mailto:\") !== 0) {\n                                        preview = \"mailto:\" + preview;\n                                    }\n                                    var tooltip = this.quill.theme.tooltip;\n                                    tooltip.edit(\"link\", preview);\n                                } else {\n                                    this.quill.format(\"link\", false);\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n            var SnowTooltip = function(_BaseTooltip) {\n                _inherits(SnowTooltip, _BaseTooltip);\n                function SnowTooltip(quill, bounds) {\n                    _classCallCheck(this, SnowTooltip);\n                    var _this2 = _possibleConstructorReturn(this, (SnowTooltip.__proto__ || Object.getPrototypeOf(SnowTooltip)).call(this, quill, bounds));\n                    _this2.preview = _this2.root.querySelector(\"a.ql-preview\");\n                    return _this2;\n                }\n                _createClass(SnowTooltip, [\n                    {\n                        key: \"listen\",\n                        value: function listen() {\n                            var _this3 = this;\n                            _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), \"listen\", this).call(this);\n                            this.root.querySelector(\"a.ql-action\").addEventListener(\"click\", function(event) {\n                                if (_this3.root.classList.contains(\"ql-editing\")) {\n                                    _this3.save();\n                                } else {\n                                    _this3.edit(\"link\", _this3.preview.textContent);\n                                }\n                                event.preventDefault();\n                            });\n                            this.root.querySelector(\"a.ql-remove\").addEventListener(\"click\", function(event) {\n                                if (_this3.linkRange != null) {\n                                    var range = _this3.linkRange;\n                                    _this3.restoreFocus();\n                                    _this3.quill.formatText(range, \"link\", false, _emitter2.default.sources.USER);\n                                    delete _this3.linkRange;\n                                }\n                                event.preventDefault();\n                                _this3.hide();\n                            });\n                            this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function(range, oldRange, source) {\n                                if (range == null) return;\n                                if (range.length === 0 && source === _emitter2.default.sources.USER) {\n                                    var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range.index), _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2), link = _quill$scroll$descend2[0], offset = _quill$scroll$descend2[1];\n                                    if (link != null) {\n                                        _this3.linkRange = new _selection.Range(range.index - offset, link.length());\n                                        var preview = _link2.default.formats(link.domNode);\n                                        _this3.preview.textContent = preview;\n                                        _this3.preview.setAttribute(\"href\", preview);\n                                        _this3.show();\n                                        _this3.position(_this3.quill.getBounds(_this3.linkRange));\n                                        return;\n                                    }\n                                } else {\n                                    delete _this3.linkRange;\n                                }\n                                _this3.hide();\n                            });\n                        }\n                    },\n                    {\n                        key: \"show\",\n                        value: function show() {\n                            _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), \"show\", this).call(this);\n                            this.root.removeAttribute(\"data-mode\");\n                        }\n                    }\n                ]);\n                return SnowTooltip;\n            }(_base.BaseTooltip);\n            SnowTooltip.TEMPLATE = [\n                '<a class=\"ql-preview\" rel=\"noopener noreferrer\" target=\"_blank\" href=\"about:blank\"></a>',\n                '<input type=\"text\" data-formula=\"e=mc^2\" data-link=\"https://quilljs.com\" data-video=\"Embed URL\">',\n                '<a class=\"ql-action\"></a>',\n                '<a class=\"ql-remove\"></a>'\n            ].join(\"\");\n            exports1.default = SnowTheme;\n        /***/ },\n        /* 63 */ /***/ function(module1, exports1, __nested_webpack_require_552733__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _core = __nested_webpack_require_552733__(29);\n            var _core2 = _interopRequireDefault(_core);\n            var _align = __nested_webpack_require_552733__(36);\n            var _direction = __nested_webpack_require_552733__(38);\n            var _indent = __nested_webpack_require_552733__(64);\n            var _blockquote = __nested_webpack_require_552733__(65);\n            var _blockquote2 = _interopRequireDefault(_blockquote);\n            var _header = __nested_webpack_require_552733__(66);\n            var _header2 = _interopRequireDefault(_header);\n            var _list = __nested_webpack_require_552733__(67);\n            var _list2 = _interopRequireDefault(_list);\n            var _background = __nested_webpack_require_552733__(37);\n            var _color = __nested_webpack_require_552733__(26);\n            var _font = __nested_webpack_require_552733__(39);\n            var _size = __nested_webpack_require_552733__(40);\n            var _bold = __nested_webpack_require_552733__(56);\n            var _bold2 = _interopRequireDefault(_bold);\n            var _italic = __nested_webpack_require_552733__(68);\n            var _italic2 = _interopRequireDefault(_italic);\n            var _link = __nested_webpack_require_552733__(27);\n            var _link2 = _interopRequireDefault(_link);\n            var _script = __nested_webpack_require_552733__(69);\n            var _script2 = _interopRequireDefault(_script);\n            var _strike = __nested_webpack_require_552733__(70);\n            var _strike2 = _interopRequireDefault(_strike);\n            var _underline = __nested_webpack_require_552733__(71);\n            var _underline2 = _interopRequireDefault(_underline);\n            var _image = __nested_webpack_require_552733__(72);\n            var _image2 = _interopRequireDefault(_image);\n            var _video = __nested_webpack_require_552733__(73);\n            var _video2 = _interopRequireDefault(_video);\n            var _code = __nested_webpack_require_552733__(13);\n            var _code2 = _interopRequireDefault(_code);\n            var _formula = __nested_webpack_require_552733__(74);\n            var _formula2 = _interopRequireDefault(_formula);\n            var _syntax = __nested_webpack_require_552733__(75);\n            var _syntax2 = _interopRequireDefault(_syntax);\n            var _toolbar = __nested_webpack_require_552733__(57);\n            var _toolbar2 = _interopRequireDefault(_toolbar);\n            var _icons = __nested_webpack_require_552733__(41);\n            var _icons2 = _interopRequireDefault(_icons);\n            var _picker = __nested_webpack_require_552733__(28);\n            var _picker2 = _interopRequireDefault(_picker);\n            var _colorPicker = __nested_webpack_require_552733__(59);\n            var _colorPicker2 = _interopRequireDefault(_colorPicker);\n            var _iconPicker = __nested_webpack_require_552733__(60);\n            var _iconPicker2 = _interopRequireDefault(_iconPicker);\n            var _tooltip = __nested_webpack_require_552733__(61);\n            var _tooltip2 = _interopRequireDefault(_tooltip);\n            var _bubble = __nested_webpack_require_552733__(108);\n            var _bubble2 = _interopRequireDefault(_bubble);\n            var _snow = __nested_webpack_require_552733__(62);\n            var _snow2 = _interopRequireDefault(_snow);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            _core2.default.register({\n                \"attributors/attribute/direction\": _direction.DirectionAttribute,\n                \"attributors/class/align\": _align.AlignClass,\n                \"attributors/class/background\": _background.BackgroundClass,\n                \"attributors/class/color\": _color.ColorClass,\n                \"attributors/class/direction\": _direction.DirectionClass,\n                \"attributors/class/font\": _font.FontClass,\n                \"attributors/class/size\": _size.SizeClass,\n                \"attributors/style/align\": _align.AlignStyle,\n                \"attributors/style/background\": _background.BackgroundStyle,\n                \"attributors/style/color\": _color.ColorStyle,\n                \"attributors/style/direction\": _direction.DirectionStyle,\n                \"attributors/style/font\": _font.FontStyle,\n                \"attributors/style/size\": _size.SizeStyle\n            }, true);\n            _core2.default.register({\n                \"formats/align\": _align.AlignClass,\n                \"formats/direction\": _direction.DirectionClass,\n                \"formats/indent\": _indent.IndentClass,\n                \"formats/background\": _background.BackgroundStyle,\n                \"formats/color\": _color.ColorStyle,\n                \"formats/font\": _font.FontClass,\n                \"formats/size\": _size.SizeClass,\n                \"formats/blockquote\": _blockquote2.default,\n                \"formats/code-block\": _code2.default,\n                \"formats/header\": _header2.default,\n                \"formats/list\": _list2.default,\n                \"formats/bold\": _bold2.default,\n                \"formats/code\": _code.Code,\n                \"formats/italic\": _italic2.default,\n                \"formats/link\": _link2.default,\n                \"formats/script\": _script2.default,\n                \"formats/strike\": _strike2.default,\n                \"formats/underline\": _underline2.default,\n                \"formats/image\": _image2.default,\n                \"formats/video\": _video2.default,\n                \"formats/list/item\": _list.ListItem,\n                \"modules/formula\": _formula2.default,\n                \"modules/syntax\": _syntax2.default,\n                \"modules/toolbar\": _toolbar2.default,\n                \"themes/bubble\": _bubble2.default,\n                \"themes/snow\": _snow2.default,\n                \"ui/icons\": _icons2.default,\n                \"ui/picker\": _picker2.default,\n                \"ui/icon-picker\": _iconPicker2.default,\n                \"ui/color-picker\": _colorPicker2.default,\n                \"ui/tooltip\": _tooltip2.default\n            }, true);\n            exports1.default = _core2.default;\n        /***/ },\n        /* 64 */ /***/ function(module1, exports1, __nested_webpack_require_558705__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.IndentClass = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_558705__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var IdentAttributor = function(_Parchment$Attributor) {\n                _inherits(IdentAttributor, _Parchment$Attributor);\n                function IdentAttributor() {\n                    _classCallCheck(this, IdentAttributor);\n                    return _possibleConstructorReturn(this, (IdentAttributor.__proto__ || Object.getPrototypeOf(IdentAttributor)).apply(this, arguments));\n                }\n                _createClass(IdentAttributor, [\n                    {\n                        key: \"add\",\n                        value: function add(node, value) {\n                            if (value === \"+1\" || value === \"-1\") {\n                                var indent = this.value(node) || 0;\n                                value = value === \"+1\" ? indent + 1 : indent - 1;\n                            }\n                            if (value === 0) {\n                                this.remove(node);\n                                return true;\n                            } else {\n                                return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), \"add\", this).call(this, node, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"canAdd\",\n                        value: function canAdd(node, value) {\n                            return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), \"canAdd\", this).call(this, node, value) || _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), \"canAdd\", this).call(this, node, parseInt(value));\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(node) {\n                            return parseInt(_get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), \"value\", this).call(this, node)) || undefined; // Don't return NaN\n                        }\n                    }\n                ]);\n                return IdentAttributor;\n            }(_parchment2.default.Attributor.Class);\n            var IndentClass = new IdentAttributor(\"indent\", \"ql-indent\", {\n                scope: _parchment2.default.Scope.BLOCK,\n                whitelist: [\n                    1,\n                    2,\n                    3,\n                    4,\n                    5,\n                    6,\n                    7,\n                    8\n                ]\n            });\n            exports1.IndentClass = IndentClass;\n        /***/ },\n        /* 65 */ /***/ function(module1, exports1, __nested_webpack_require_564967__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _block = __nested_webpack_require_564967__(4);\n            var _block2 = _interopRequireDefault(_block);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Blockquote = function(_Block) {\n                _inherits(Blockquote, _Block);\n                function Blockquote() {\n                    _classCallCheck(this, Blockquote);\n                    return _possibleConstructorReturn(this, (Blockquote.__proto__ || Object.getPrototypeOf(Blockquote)).apply(this, arguments));\n                }\n                return Blockquote;\n            }(_block2.default);\n            Blockquote.blotName = \"blockquote\";\n            Blockquote.tagName = \"blockquote\";\n            exports1.default = Blockquote;\n        /***/ },\n        /* 66 */ /***/ function(module1, exports1, __nested_webpack_require_567346__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _block = __nested_webpack_require_567346__(4);\n            var _block2 = _interopRequireDefault(_block);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Header = function(_Block) {\n                _inherits(Header, _Block);\n                function Header() {\n                    _classCallCheck(this, Header);\n                    return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));\n                }\n                _createClass(Header, null, [\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return this.tagName.indexOf(domNode.tagName) + 1;\n                        }\n                    }\n                ]);\n                return Header;\n            }(_block2.default);\n            Header.blotName = \"header\";\n            Header.tagName = [\n                \"H1\",\n                \"H2\",\n                \"H3\",\n                \"H4\",\n                \"H5\",\n                \"H6\"\n            ];\n            exports1.default = Header;\n        /***/ },\n        /* 67 */ /***/ function(module1, exports1, __nested_webpack_require_570996__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.ListItem = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_570996__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _block = __nested_webpack_require_570996__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _container = __nested_webpack_require_570996__(25);\n            var _container2 = _interopRequireDefault(_container);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ListItem = function(_Block) {\n                _inherits(ListItem, _Block);\n                function ListItem() {\n                    _classCallCheck(this, ListItem);\n                    return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).apply(this, arguments));\n                }\n                _createClass(ListItem, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (name === List.blotName && !value) {\n                                this.replaceWith(_parchment2.default.create(this.statics.scope));\n                            } else {\n                                _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), \"format\", this).call(this, name, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"remove\",\n                        value: function remove() {\n                            if (this.prev == null && this.next == null) {\n                                this.parent.remove();\n                            } else {\n                                _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), \"remove\", this).call(this);\n                            }\n                        }\n                    },\n                    {\n                        key: \"replaceWith\",\n                        value: function replaceWith(name, value) {\n                            this.parent.isolate(this.offset(this.parent), this.length());\n                            if (name === this.parent.statics.blotName) {\n                                this.parent.replaceWith(name, value);\n                                return this;\n                            } else {\n                                this.parent.unwrap();\n                                return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), \"replaceWith\", this).call(this, name, value);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return domNode.tagName === this.tagName ? undefined : _get(ListItem.__proto__ || Object.getPrototypeOf(ListItem), \"formats\", this).call(this, domNode);\n                        }\n                    }\n                ]);\n                return ListItem;\n            }(_block2.default);\n            ListItem.blotName = \"list-item\";\n            ListItem.tagName = \"LI\";\n            var List = function(_Container) {\n                _inherits(List, _Container);\n                _createClass(List, null, [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var tagName = value === \"ordered\" ? \"OL\" : \"UL\";\n                            var node = _get(List.__proto__ || Object.getPrototypeOf(List), \"create\", this).call(this, tagName);\n                            if (value === \"checked\" || value === \"unchecked\") {\n                                node.setAttribute(\"data-checked\", value === \"checked\");\n                            }\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            if (domNode.tagName === \"OL\") return \"ordered\";\n                            if (domNode.tagName === \"UL\") {\n                                if (domNode.hasAttribute(\"data-checked\")) {\n                                    return domNode.getAttribute(\"data-checked\") === \"true\" ? \"checked\" : \"unchecked\";\n                                } else {\n                                    return \"bullet\";\n                                }\n                            }\n                            return undefined;\n                        }\n                    }\n                ]);\n                function List(domNode) {\n                    _classCallCheck(this, List);\n                    var _this2 = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, domNode));\n                    var listEventHandler = function listEventHandler(e) {\n                        if (e.target.parentNode !== domNode) return;\n                        var format = _this2.statics.formats(domNode);\n                        var blot = _parchment2.default.find(e.target);\n                        if (format === \"checked\") {\n                            blot.format(\"list\", \"unchecked\");\n                        } else if (format === \"unchecked\") {\n                            blot.format(\"list\", \"checked\");\n                        }\n                    };\n                    domNode.addEventListener(\"touchstart\", listEventHandler);\n                    domNode.addEventListener(\"mousedown\", listEventHandler);\n                    return _this2;\n                }\n                _createClass(List, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (this.children.length > 0) {\n                                this.children.tail.format(name, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats() {\n                            // We don't inherit from FormatBlot\n                            return _defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(blot, ref) {\n                            if (blot instanceof ListItem) {\n                                _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), \"insertBefore\", this).call(this, blot, ref);\n                            } else {\n                                var index = ref == null ? this.length() : ref.offset(this);\n                                var after = this.split(index);\n                                after.parent.insertBefore(blot, after);\n                            }\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), \"optimize\", this).call(this, context);\n                            var next = this.next;\n                            if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute(\"data-checked\") === this.domNode.getAttribute(\"data-checked\")) {\n                                next.moveChildren(this);\n                                next.remove();\n                            }\n                        }\n                    },\n                    {\n                        key: \"replace\",\n                        value: function replace(target) {\n                            if (target.statics.blotName !== this.statics.blotName) {\n                                var item = _parchment2.default.create(this.statics.defaultChild);\n                                target.moveChildren(item);\n                                this.appendChild(item);\n                            }\n                            _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), \"replace\", this).call(this, target);\n                        }\n                    }\n                ]);\n                return List;\n            }(_container2.default);\n            List.blotName = \"list\";\n            List.scope = _parchment2.default.Scope.BLOCK_BLOT;\n            List.tagName = [\n                \"OL\",\n                \"UL\"\n            ];\n            List.defaultChild = \"list-item\";\n            List.allowedChildren = [\n                ListItem\n            ];\n            exports1.ListItem = ListItem;\n            exports1.default = List;\n        /***/ },\n        /* 68 */ /***/ function(module1, exports1, __nested_webpack_require_583751__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _bold = __nested_webpack_require_583751__(56);\n            var _bold2 = _interopRequireDefault(_bold);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Italic = function(_Bold) {\n                _inherits(Italic, _Bold);\n                function Italic() {\n                    _classCallCheck(this, Italic);\n                    return _possibleConstructorReturn(this, (Italic.__proto__ || Object.getPrototypeOf(Italic)).apply(this, arguments));\n                }\n                return Italic;\n            }(_bold2.default);\n            Italic.blotName = \"italic\";\n            Italic.tagName = [\n                \"EM\",\n                \"I\"\n            ];\n            exports1.default = Italic;\n        /***/ },\n        /* 69 */ /***/ function(module1, exports1, __nested_webpack_require_586126__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _inline = __nested_webpack_require_586126__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Script = function(_Inline) {\n                _inherits(Script, _Inline);\n                function Script() {\n                    _classCallCheck(this, Script);\n                    return _possibleConstructorReturn(this, (Script.__proto__ || Object.getPrototypeOf(Script)).apply(this, arguments));\n                }\n                _createClass(Script, null, [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            if (value === \"super\") {\n                                return document.createElement(\"sup\");\n                            } else if (value === \"sub\") {\n                                return document.createElement(\"sub\");\n                            } else {\n                                return _get(Script.__proto__ || Object.getPrototypeOf(Script), \"create\", this).call(this, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            if (domNode.tagName === \"SUB\") return \"sub\";\n                            if (domNode.tagName === \"SUP\") return \"super\";\n                            return undefined;\n                        }\n                    }\n                ]);\n                return Script;\n            }(_inline2.default);\n            Script.blotName = \"script\";\n            Script.tagName = [\n                \"SUB\",\n                \"SUP\"\n            ];\n            exports1.default = Script;\n        /***/ },\n        /* 70 */ /***/ function(module1, exports1, __nested_webpack_require_591290__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _inline = __nested_webpack_require_591290__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Strike = function(_Inline) {\n                _inherits(Strike, _Inline);\n                function Strike() {\n                    _classCallCheck(this, Strike);\n                    return _possibleConstructorReturn(this, (Strike.__proto__ || Object.getPrototypeOf(Strike)).apply(this, arguments));\n                }\n                return Strike;\n            }(_inline2.default);\n            Strike.blotName = \"strike\";\n            Strike.tagName = \"S\";\n            exports1.default = Strike;\n        /***/ },\n        /* 71 */ /***/ function(module1, exports1, __nested_webpack_require_593622__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _inline = __nested_webpack_require_593622__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Underline = function(_Inline) {\n                _inherits(Underline, _Inline);\n                function Underline() {\n                    _classCallCheck(this, Underline);\n                    return _possibleConstructorReturn(this, (Underline.__proto__ || Object.getPrototypeOf(Underline)).apply(this, arguments));\n                }\n                return Underline;\n            }(_inline2.default);\n            Underline.blotName = \"underline\";\n            Underline.tagName = \"U\";\n            exports1.default = Underline;\n        /***/ },\n        /* 72 */ /***/ function(module1, exports1, __nested_webpack_require_595987__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_595987__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _link = __nested_webpack_require_595987__(27);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ATTRIBUTES = [\n                \"alt\",\n                \"height\",\n                \"width\"\n            ];\n            var Image = function(_Parchment$Embed) {\n                _inherits(Image, _Parchment$Embed);\n                function Image() {\n                    _classCallCheck(this, Image);\n                    return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));\n                }\n                _createClass(Image, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (ATTRIBUTES.indexOf(name) > -1) {\n                                if (value) {\n                                    this.domNode.setAttribute(name, value);\n                                } else {\n                                    this.domNode.removeAttribute(name);\n                                }\n                            } else {\n                                _get(Image.prototype.__proto__ || Object.getPrototypeOf(Image.prototype), \"format\", this).call(this, name, value);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var node = _get(Image.__proto__ || Object.getPrototypeOf(Image), \"create\", this).call(this, value);\n                            if (typeof value === \"string\") {\n                                node.setAttribute(\"src\", this.sanitize(value));\n                            }\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return ATTRIBUTES.reduce(function(formats, attribute) {\n                                if (domNode.hasAttribute(attribute)) {\n                                    formats[attribute] = domNode.getAttribute(attribute);\n                                }\n                                return formats;\n                            }, {});\n                        }\n                    },\n                    {\n                        key: \"match\",\n                        value: function match(url) {\n                            return /\\.(jpe?g|gif|png)$/.test(url) || /^data:image\\/.+;base64/.test(url);\n                        }\n                    },\n                    {\n                        key: \"sanitize\",\n                        value: function sanitize(url) {\n                            return (0, _link.sanitize)(url, [\n                                \"http\",\n                                \"https\",\n                                \"data\"\n                            ]) ? url : \"//:0\";\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(domNode) {\n                            return domNode.getAttribute(\"src\");\n                        }\n                    }\n                ]);\n                return Image;\n            }(_parchment2.default.Embed);\n            Image.blotName = \"image\";\n            Image.tagName = \"IMG\";\n            exports1.default = Image;\n        /***/ },\n        /* 73 */ /***/ function(module1, exports1, __nested_webpack_require_602976__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _block = __nested_webpack_require_602976__(4);\n            var _link = __nested_webpack_require_602976__(27);\n            var _link2 = _interopRequireDefault(_link);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ATTRIBUTES = [\n                \"height\",\n                \"width\"\n            ];\n            var Video = function(_BlockEmbed) {\n                _inherits(Video, _BlockEmbed);\n                function Video() {\n                    _classCallCheck(this, Video);\n                    return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));\n                }\n                _createClass(Video, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (ATTRIBUTES.indexOf(name) > -1) {\n                                if (value) {\n                                    this.domNode.setAttribute(name, value);\n                                } else {\n                                    this.domNode.removeAttribute(name);\n                                }\n                            } else {\n                                _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), \"format\", this).call(this, name, value);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var node = _get(Video.__proto__ || Object.getPrototypeOf(Video), \"create\", this).call(this, value);\n                            node.setAttribute(\"frameborder\", \"0\");\n                            node.setAttribute(\"allowfullscreen\", true);\n                            node.setAttribute(\"src\", this.sanitize(value));\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return ATTRIBUTES.reduce(function(formats, attribute) {\n                                if (domNode.hasAttribute(attribute)) {\n                                    formats[attribute] = domNode.getAttribute(attribute);\n                                }\n                                return formats;\n                            }, {});\n                        }\n                    },\n                    {\n                        key: \"sanitize\",\n                        value: function sanitize(url) {\n                            return _link2.default.sanitize(url);\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(domNode) {\n                            return domNode.getAttribute(\"src\");\n                        }\n                    }\n                ]);\n                return Video;\n            }(_block.BlockEmbed);\n            Video.blotName = \"video\";\n            Video.className = \"ql-video\";\n            Video.tagName = \"IFRAME\";\n            exports1.default = Video;\n        /***/ },\n        /* 74 */ /***/ function(module1, exports1, __nested_webpack_require_609568__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.FormulaBlot = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _embed = __nested_webpack_require_609568__(35);\n            var _embed2 = _interopRequireDefault(_embed);\n            var _quill = __nested_webpack_require_609568__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _module = __nested_webpack_require_609568__(9);\n            var _module2 = _interopRequireDefault(_module);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var FormulaBlot = function(_Embed) {\n                _inherits(FormulaBlot, _Embed);\n                function FormulaBlot() {\n                    _classCallCheck(this, FormulaBlot);\n                    return _possibleConstructorReturn(this, (FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot)).apply(this, arguments));\n                }\n                _createClass(FormulaBlot, null, [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var node = _get(FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot), \"create\", this).call(this, value);\n                            if (typeof value === \"string\") {\n                                window.katex.render(value, node, {\n                                    throwOnError: false,\n                                    errorColor: \"#f00\"\n                                });\n                                node.setAttribute(\"data-value\", value);\n                            }\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(domNode) {\n                            return domNode.getAttribute(\"data-value\");\n                        }\n                    }\n                ]);\n                return FormulaBlot;\n            }(_embed2.default);\n            FormulaBlot.blotName = \"formula\";\n            FormulaBlot.className = \"ql-formula\";\n            FormulaBlot.tagName = \"SPAN\";\n            var Formula = function(_Module) {\n                _inherits(Formula, _Module);\n                _createClass(Formula, null, [\n                    {\n                        key: \"register\",\n                        value: function register() {\n                            _quill2.default.register(FormulaBlot, true);\n                        }\n                    }\n                ]);\n                function Formula() {\n                    _classCallCheck(this, Formula);\n                    var _this2 = _possibleConstructorReturn(this, (Formula.__proto__ || Object.getPrototypeOf(Formula)).call(this));\n                    if (window.katex == null) {\n                        throw new Error(\"Formula module requires KaTeX.\");\n                    }\n                    return _this2;\n                }\n                return Formula;\n            }(_module2.default);\n            exports1.FormulaBlot = FormulaBlot;\n            exports1.default = Formula;\n        /***/ },\n        /* 75 */ /***/ function(module1, exports1, __nested_webpack_require_615968__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.CodeToken = exports1.CodeBlock = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_615968__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_615968__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _module = __nested_webpack_require_615968__(9);\n            var _module2 = _interopRequireDefault(_module);\n            var _code = __nested_webpack_require_615968__(13);\n            var _code2 = _interopRequireDefault(_code);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var SyntaxCodeBlock = function(_CodeBlock) {\n                _inherits(SyntaxCodeBlock, _CodeBlock);\n                function SyntaxCodeBlock() {\n                    _classCallCheck(this, SyntaxCodeBlock);\n                    return _possibleConstructorReturn(this, (SyntaxCodeBlock.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock)).apply(this, arguments));\n                }\n                _createClass(SyntaxCodeBlock, [\n                    {\n                        key: \"replaceWith\",\n                        value: function replaceWith(block) {\n                            this.domNode.textContent = this.domNode.textContent;\n                            this.attach();\n                            _get(SyntaxCodeBlock.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock.prototype), \"replaceWith\", this).call(this, block);\n                        }\n                    },\n                    {\n                        key: \"highlight\",\n                        value: function highlight(_highlight) {\n                            var text = this.domNode.textContent;\n                            if (this.cachedText !== text) {\n                                if (text.trim().length > 0 || this.cachedText == null) {\n                                    this.domNode.innerHTML = _highlight(text);\n                                    this.domNode.normalize();\n                                    this.attach();\n                                }\n                                this.cachedText = text;\n                            }\n                        }\n                    }\n                ]);\n                return SyntaxCodeBlock;\n            }(_code2.default);\n            SyntaxCodeBlock.className = \"ql-syntax\";\n            var CodeToken = new _parchment2.default.Attributor.Class(\"token\", \"hljs\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            var Syntax = function(_Module) {\n                _inherits(Syntax, _Module);\n                _createClass(Syntax, null, [\n                    {\n                        key: \"register\",\n                        value: function register() {\n                            _quill2.default.register(CodeToken, true);\n                            _quill2.default.register(SyntaxCodeBlock, true);\n                        }\n                    }\n                ]);\n                function Syntax(quill, options) {\n                    _classCallCheck(this, Syntax);\n                    var _this2 = _possibleConstructorReturn(this, (Syntax.__proto__ || Object.getPrototypeOf(Syntax)).call(this, quill, options));\n                    if (typeof _this2.options.highlight !== \"function\") {\n                        throw new Error(\"Syntax module requires highlight.js. Please include the library on the page before Quill.\");\n                    }\n                    var timer = null;\n                    _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {\n                        clearTimeout(timer);\n                        timer = setTimeout(function() {\n                            _this2.highlight();\n                            timer = null;\n                        }, _this2.options.interval);\n                    });\n                    _this2.highlight();\n                    return _this2;\n                }\n                _createClass(Syntax, [\n                    {\n                        key: \"highlight\",\n                        value: function highlight() {\n                            var _this3 = this;\n                            if (this.quill.selection.composing) return;\n                            this.quill.update(_quill2.default.sources.USER);\n                            var range = this.quill.getSelection();\n                            this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function(code) {\n                                code.highlight(_this3.options.highlight);\n                            });\n                            this.quill.update(_quill2.default.sources.SILENT);\n                            if (range != null) {\n                                this.quill.setSelection(range, _quill2.default.sources.SILENT);\n                            }\n                        }\n                    }\n                ]);\n                return Syntax;\n            }(_module2.default);\n            Syntax.DEFAULTS = {\n                highlight: function() {\n                    if (window.hljs == null) return null;\n                    return function(text) {\n                        var result = window.hljs.highlightAuto(text);\n                        return result.value;\n                    };\n                }(),\n                interval: 1000\n            };\n            exports1.CodeBlock = SyntaxCodeBlock;\n            exports1.CodeToken = CodeToken;\n            exports1.default = Syntax;\n        /***/ },\n        /* 76 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>';\n        /***/ },\n        /* 77 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>';\n        /***/ },\n        /* 78 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>';\n        /***/ },\n        /* 79 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>';\n        /***/ },\n        /* 80 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>';\n        /***/ },\n        /* 81 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>';\n        /***/ },\n        /* 82 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>';\n        /***/ },\n        /* 83 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>';\n        /***/ },\n        /* 84 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>';\n        /***/ },\n        /* 85 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>';\n        /***/ },\n        /* 86 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>';\n        /***/ },\n        /* 87 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>';\n        /***/ },\n        /* 88 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>';\n        /***/ },\n        /* 89 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>';\n        /***/ },\n        /* 90 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>';\n        /***/ },\n        /* 91 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>';\n        /***/ },\n        /* 92 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>';\n        /***/ },\n        /* 93 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>';\n        /***/ },\n        /* 94 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>';\n        /***/ },\n        /* 95 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>';\n        /***/ },\n        /* 96 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>';\n        /***/ },\n        /* 97 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>';\n        /***/ },\n        /* 98 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>';\n        /***/ },\n        /* 99 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>';\n        /***/ },\n        /* 100 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>';\n        /***/ },\n        /* 101 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>';\n        /***/ },\n        /* 102 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>';\n        /***/ },\n        /* 103 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>';\n        /***/ },\n        /* 104 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>';\n        /***/ },\n        /* 105 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>';\n        /***/ },\n        /* 106 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>';\n        /***/ },\n        /* 107 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>';\n        /***/ },\n        /* 108 */ /***/ function(module1, exports1, __nested_webpack_require_642520__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.BubbleTooltip = undefined;\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _extend = __nested_webpack_require_642520__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _emitter = __nested_webpack_require_642520__(8);\n            var _emitter2 = _interopRequireDefault(_emitter);\n            var _base = __nested_webpack_require_642520__(43);\n            var _base2 = _interopRequireDefault(_base);\n            var _selection = __nested_webpack_require_642520__(15);\n            var _icons = __nested_webpack_require_642520__(41);\n            var _icons2 = _interopRequireDefault(_icons);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var TOOLBAR_CONFIG = [\n                [\n                    \"bold\",\n                    \"italic\",\n                    \"link\"\n                ],\n                [\n                    {\n                        header: 1\n                    },\n                    {\n                        header: 2\n                    },\n                    \"blockquote\"\n                ]\n            ];\n            var BubbleTheme = function(_BaseTheme) {\n                _inherits(BubbleTheme, _BaseTheme);\n                function BubbleTheme(quill, options) {\n                    _classCallCheck(this, BubbleTheme);\n                    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {\n                        options.modules.toolbar.container = TOOLBAR_CONFIG;\n                    }\n                    var _this = _possibleConstructorReturn(this, (BubbleTheme.__proto__ || Object.getPrototypeOf(BubbleTheme)).call(this, quill, options));\n                    _this.quill.container.classList.add(\"ql-bubble\");\n                    return _this;\n                }\n                _createClass(BubbleTheme, [\n                    {\n                        key: \"extendToolbar\",\n                        value: function extendToolbar(toolbar) {\n                            this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);\n                            this.tooltip.root.appendChild(toolbar.container);\n                            this.buildButtons([].slice.call(toolbar.container.querySelectorAll(\"button\")), _icons2.default);\n                            this.buildPickers([].slice.call(toolbar.container.querySelectorAll(\"select\")), _icons2.default);\n                        }\n                    }\n                ]);\n                return BubbleTheme;\n            }(_base2.default);\n            BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {\n                modules: {\n                    toolbar: {\n                        handlers: {\n                            link: function link(value) {\n                                if (!value) {\n                                    this.quill.format(\"link\", false);\n                                } else {\n                                    this.quill.theme.tooltip.edit();\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n            var BubbleTooltip = function(_BaseTooltip) {\n                _inherits(BubbleTooltip, _BaseTooltip);\n                function BubbleTooltip(quill, bounds) {\n                    _classCallCheck(this, BubbleTooltip);\n                    var _this2 = _possibleConstructorReturn(this, (BubbleTooltip.__proto__ || Object.getPrototypeOf(BubbleTooltip)).call(this, quill, bounds));\n                    _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function(type, range, oldRange, source) {\n                        if (type !== _emitter2.default.events.SELECTION_CHANGE) return;\n                        if (range != null && range.length > 0 && source === _emitter2.default.sources.USER) {\n                            _this2.show();\n                            // Lock our width so we will expand beyond our offsetParent boundaries\n                            _this2.root.style.left = \"0px\";\n                            _this2.root.style.width = \"\";\n                            _this2.root.style.width = _this2.root.offsetWidth + \"px\";\n                            var lines = _this2.quill.getLines(range.index, range.length);\n                            if (lines.length === 1) {\n                                _this2.position(_this2.quill.getBounds(range));\n                            } else {\n                                var lastLine = lines[lines.length - 1];\n                                var index = _this2.quill.getIndex(lastLine);\n                                var length = Math.min(lastLine.length() - 1, range.index + range.length - index);\n                                var _bounds = _this2.quill.getBounds(new _selection.Range(index, length));\n                                _this2.position(_bounds);\n                            }\n                        } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {\n                            _this2.hide();\n                        }\n                    });\n                    return _this2;\n                }\n                _createClass(BubbleTooltip, [\n                    {\n                        key: \"listen\",\n                        value: function listen() {\n                            var _this3 = this;\n                            _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), \"listen\", this).call(this);\n                            this.root.querySelector(\".ql-close\").addEventListener(\"click\", function() {\n                                _this3.root.classList.remove(\"ql-editing\");\n                            });\n                            this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function() {\n                                // Let selection be restored by toolbar handlers before repositioning\n                                setTimeout(function() {\n                                    if (_this3.root.classList.contains(\"ql-hidden\")) return;\n                                    var range = _this3.quill.getSelection();\n                                    if (range != null) {\n                                        _this3.position(_this3.quill.getBounds(range));\n                                    }\n                                }, 1);\n                            });\n                        }\n                    },\n                    {\n                        key: \"cancel\",\n                        value: function cancel() {\n                            this.show();\n                        }\n                    },\n                    {\n                        key: \"position\",\n                        value: function position(reference) {\n                            var shift = _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), \"position\", this).call(this, reference);\n                            var arrow = this.root.querySelector(\".ql-tooltip-arrow\");\n                            arrow.style.marginLeft = \"\";\n                            if (shift === 0) return shift;\n                            arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + \"px\";\n                        }\n                    }\n                ]);\n                return BubbleTooltip;\n            }(_base.BaseTooltip);\n            BubbleTooltip.TEMPLATE = [\n                '<span class=\"ql-tooltip-arrow\"></span>',\n                '<div class=\"ql-tooltip-editor\">',\n                '<input type=\"text\" data-formula=\"e=mc^2\" data-link=\"https://quilljs.com\" data-video=\"Embed URL\">',\n                '<a class=\"ql-close\"></a>',\n                \"</div>\"\n            ].join(\"\");\n            exports1.BubbleTooltip = BubbleTooltip;\n            exports1.default = BubbleTheme;\n        /***/ },\n        /* 109 */ /***/ function(module1, exports1, __nested_webpack_require_653673__) {\n            module1.exports = __nested_webpack_require_653673__(63);\n        /***/ }\n    ])[\"default\"];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcXVpbGwvZGlzdC9xdWlsbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQyxHQUNBLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0Q7U0FDYixFQUtzQkE7QUFDNUIsR0FBRyxPQUFPSyxTQUFTLGNBQWNBLE9BQU8sSUFBSSxFQUFFO0lBQzlDLE9BQWdCLE1BQUgsR0FBSSxTQUFTQyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTQyw4QkFBbUJBLENBQUNDLFFBQVE7WUFDL0MsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLLElBQUdGLGdCQUFnQixDQUFDRSxTQUFTLEVBQUU7Z0JBQzFDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDUixPQUFPO1lBQ3JELE1BQU0sR0FBSztZQUNYLE1BQU0sR0FBSyxrREFBa0Q7WUFDN0QsTUFBTSxHQUFLLElBQUlDLFVBQVNLLGdCQUFnQixDQUFDRSxTQUFTLEdBQUc7Z0JBQ3JELE1BQU0sR0FBTUMsR0FBR0Q7Z0JBQ2YsTUFBTSxHQUFNRSxHQUFHO2dCQUNmLE1BQU0sR0FBTVYsU0FBUyxDQUFDO1lBQ1g7WUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUtLLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNWLFFBQU9ELE9BQU8sRUFBRUMsU0FBUUEsUUFBT0QsT0FBTyxFQUFFTyw4QkFBbUJBO1lBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1lBQ3ZDLE1BQU0sR0FBS04sUUFBT1MsQ0FBQyxHQUFHO1lBQ3RCLE1BQU0sR0FDTixNQUFNLEdB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QUFDLElBQUl2bEMsUUFBUXNsQyxNQUFNekYsV0FBVyxHQUFHLElBQUk7d0JBQ2hFO29CQUNGO2lCQUFFO2dCQUVGLE9BQU9xRjtZQUNULEVBQUVqRixNQUFNM1QsV0FBVztZQUVuQjRZLGNBQWN2RixRQUFRLEdBQUc7Z0JBQUM7Z0JBQTBDO2dCQUFtQztnQkFBb0c7Z0JBQTRCO2FBQVMsQ0FBQzdsQyxJQUFJLENBQUM7WUFFdFBuTCxTQUFRdTJDLGFBQWEsR0FBR0E7WUFDeEJ2MkMsU0FBUXNELE9BQU8sR0FBR2t6QztRQUVsQixHQUFHLEdBQUc7UUFDTixPQUFPLEdBQ1AsR0FBRyxHQUFJLFNBQVN2MkMsT0FBTSxFQUFFRCxRQUFPLEVBQUVPLGlDQUFtQjtZQUVwRE4sUUFBT0QsT0FBTyxHQUFHTyxpQ0FBbUJBLENBQUM7UUFHckMsR0FBRyxHQUFHO0tBQ0ksQ0FBQyxDQUFDLFVBQVU7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtMTMtcmVwbGl0Ly4vbm9kZV9tb2R1bGVzL3F1aWxsL2Rpc3QvcXVpbGwuanM/OTlmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFF1aWxsIEVkaXRvciB2MS4zLjdcbiAqIGh0dHBzOi8vcXVpbGxqcy5jb20vXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEphc29uIENoZW5cbiAqIENvcHlyaWdodCAoYykgMjAxMywgc2FsZXNmb3JjZS5jb21cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUXVpbGxcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUXVpbGxcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEwOSk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGFpbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbnZhciBmb3JtYXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIGxlYWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xudmFyIHNjcm9sbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG52YXIgaW5saW5lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcbnZhciBibG9ja18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG52YXIgZW1iZWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xudmFyIHRleHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xudmFyIGF0dHJpYnV0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIGNsYXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBzdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgc3RvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBQYXJjaG1lbnQgPSB7XG4gICAgU2NvcGU6IFJlZ2lzdHJ5LlNjb3BlLFxuICAgIGNyZWF0ZTogUmVnaXN0cnkuY3JlYXRlLFxuICAgIGZpbmQ6IFJlZ2lzdHJ5LmZpbmQsXG4gICAgcXVlcnk6IFJlZ2lzdHJ5LnF1ZXJ5LFxuICAgIHJlZ2lzdGVyOiBSZWdpc3RyeS5yZWdpc3RlcixcbiAgICBDb250YWluZXI6IGNvbnRhaW5lcl8xLmRlZmF1bHQsXG4gICAgRm9ybWF0OiBmb3JtYXRfMS5kZWZhdWx0LFxuICAgIExlYWY6IGxlYWZfMS5kZWZhdWx0LFxuICAgIEVtYmVkOiBlbWJlZF8xLmRlZmF1bHQsXG4gICAgU2Nyb2xsOiBzY3JvbGxfMS5kZWZhdWx0LFxuICAgIEJsb2NrOiBibG9ja18xLmRlZmF1bHQsXG4gICAgSW5saW5lOiBpbmxpbmVfMS5kZWZhdWx0LFxuICAgIFRleHQ6IHRleHRfMS5kZWZhdWx0LFxuICAgIEF0dHJpYnV0b3I6IHtcbiAgICAgICAgQXR0cmlidXRlOiBhdHRyaWJ1dG9yXzEuZGVmYXVsdCxcbiAgICAgICAgQ2xhc3M6IGNsYXNzXzEuZGVmYXVsdCxcbiAgICAgICAgU3R5bGU6IHN0eWxlXzEuZGVmYXVsdCxcbiAgICAgICAgU3RvcmU6IHN0b3JlXzEuZGVmYXVsdCxcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBhcmNobWVudDtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhcmNobWVudEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXJjaG1lbnRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJjaG1lbnRFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1lc3NhZ2UgPSAnW1BhcmNobWVudF0gJyArIG1lc3NhZ2U7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIF90aGlzLm5hbWUgPSBfdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYXJjaG1lbnRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuUGFyY2htZW50RXJyb3IgPSBQYXJjaG1lbnRFcnJvcjtcbnZhciBhdHRyaWJ1dGVzID0ge307XG52YXIgY2xhc3NlcyA9IHt9O1xudmFyIHRhZ3MgPSB7fTtcbnZhciB0eXBlcyA9IHt9O1xuZXhwb3J0cy5EQVRBX0tFWSA9ICdfX2Jsb3QnO1xudmFyIFNjb3BlO1xuKGZ1bmN0aW9uIChTY29wZSkge1xuICAgIFNjb3BlW1Njb3BlW1wiVFlQRVwiXSA9IDNdID0gXCJUWVBFXCI7XG4gICAgU2NvcGVbU2NvcGVbXCJMRVZFTFwiXSA9IDEyXSA9IFwiTEVWRUxcIjtcbiAgICBTY29wZVtTY29wZVtcIkFUVFJJQlVURVwiXSA9IDEzXSA9IFwiQVRUUklCVVRFXCI7XG4gICAgU2NvcGVbU2NvcGVbXCJCTE9UXCJdID0gMTRdID0gXCJCTE9UXCI7XG4gICAgU2NvcGVbU2NvcGVbXCJJTkxJTkVcIl0gPSA3XSA9IFwiSU5MSU5FXCI7XG4gICAgU2NvcGVbU2NvcGVbXCJCTE9DS1wiXSA9IDExXSA9IFwiQkxPQ0tcIjtcbiAgICBTY29wZVtTY29wZVtcIkJMT0NLX0JMT1RcIl0gPSAxMF0gPSBcIkJMT0NLX0JMT1RcIjtcbiAgICBTY29wZVtTY29wZVtcIklOTElORV9CTE9UXCJdID0gNl0gPSBcIklOTElORV9CTE9UXCI7XG4gICAgU2NvcGVbU2NvcGVbXCJCTE9DS19BVFRSSUJVVEVcIl0gPSA5XSA9IFwiQkxPQ0tfQVRUUklCVVRFXCI7XG4gICAgU2NvcGVbU2NvcGVbXCJJTkxJTkVfQVRUUklCVVRFXCJdID0gNV0gPSBcIklOTElORV9BVFRSSUJVVEVcIjtcbiAgICBTY29wZVtTY29wZVtcIkFOWVwiXSA9IDE1XSA9IFwiQU5ZXCI7XG59KShTY29wZSA9IGV4cG9ydHMuU2NvcGUgfHwgKGV4cG9ydHMuU2NvcGUgPSB7fSkpO1xuZnVuY3Rpb24gY3JlYXRlKGlucHV0LCB2YWx1ZSkge1xuICAgIHZhciBtYXRjaCA9IHF1ZXJ5KGlucHV0KTtcbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyY2htZW50RXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIFwiICsgaW5wdXQgKyBcIiBibG90XCIpO1xuICAgIH1cbiAgICB2YXIgQmxvdENsYXNzID0gbWF0Y2g7XG4gICAgdmFyIG5vZGUgPSBcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaW5wdXQgaW5zdGFuY2VvZiBOb2RlIHx8IGlucHV0Wydub2RlVHlwZSddID09PSBOb2RlLlRFWFRfTk9ERSA/IGlucHV0IDogQmxvdENsYXNzLmNyZWF0ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBCbG90Q2xhc3Mobm9kZSwgdmFsdWUpO1xufVxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5mdW5jdGlvbiBmaW5kKG5vZGUsIGJ1YmJsZSkge1xuICAgIGlmIChidWJibGUgPT09IHZvaWQgMCkgeyBidWJibGUgPSBmYWxzZTsgfVxuICAgIGlmIChub2RlID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAobm9kZVtleHBvcnRzLkRBVEFfS0VZXSAhPSBudWxsKVxuICAgICAgICByZXR1cm4gbm9kZVtleHBvcnRzLkRBVEFfS0VZXS5ibG90O1xuICAgIGlmIChidWJibGUpXG4gICAgICAgIHJldHVybiBmaW5kKG5vZGUucGFyZW50Tm9kZSwgYnViYmxlKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZmluZCA9IGZpbmQ7XG5mdW5jdGlvbiBxdWVyeShxdWVyeSwgc2NvcGUpIHtcbiAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkgeyBzY29wZSA9IFNjb3BlLkFOWTsgfVxuICAgIHZhciBtYXRjaDtcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBtYXRjaCA9IHR5cGVzW3F1ZXJ5XSB8fCBhdHRyaWJ1dGVzW3F1ZXJ5XTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgIH1cbiAgICBlbHNlIGlmIChxdWVyeSBpbnN0YW5jZW9mIFRleHQgfHwgcXVlcnlbJ25vZGVUeXBlJ10gPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIG1hdGNoID0gdHlwZXNbJ3RleHQnXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAocXVlcnkgJiBTY29wZS5MRVZFTCAmIFNjb3BlLkJMT0NLKSB7XG4gICAgICAgICAgICBtYXRjaCA9IHR5cGVzWydibG9jayddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHF1ZXJ5ICYgU2NvcGUuTEVWRUwgJiBTY29wZS5JTkxJTkUpIHtcbiAgICAgICAgICAgIG1hdGNoID0gdHlwZXNbJ2lubGluZSddO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gKHF1ZXJ5LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykuc3BsaXQoL1xccysvKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBuYW1lcykge1xuICAgICAgICAgICAgbWF0Y2ggPSBjbGFzc2VzW25hbWVzW2ldXTtcbiAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IG1hdGNoIHx8IHRhZ3NbcXVlcnkudGFnTmFtZV07XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHNjb3BlICYgU2NvcGUuTEVWRUwgJiBtYXRjaC5zY29wZSAmJiBzY29wZSAmIFNjb3BlLlRZUEUgJiBtYXRjaC5zY29wZSlcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5xdWVyeSA9IHF1ZXJ5O1xuZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgdmFyIERlZmluaXRpb25zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgRGVmaW5pdGlvbnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKERlZmluaXRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIERlZmluaXRpb25zLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyKGQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIERlZmluaXRpb24gPSBEZWZpbml0aW9uc1swXTtcbiAgICBpZiAodHlwZW9mIERlZmluaXRpb24uYmxvdE5hbWUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBEZWZpbml0aW9uLmF0dHJOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgUGFyY2htZW50RXJyb3IoJ0ludmFsaWQgZGVmaW5pdGlvbicpO1xuICAgIH1cbiAgICBlbHNlIGlmIChEZWZpbml0aW9uLmJsb3ROYW1lID09PSAnYWJzdHJhY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJjaG1lbnRFcnJvcignQ2Fubm90IHJlZ2lzdGVyIGFic3RyYWN0IGNsYXNzJyk7XG4gICAgfVxuICAgIHR5cGVzW0RlZmluaXRpb24uYmxvdE5hbWUgfHwgRGVmaW5pdGlvbi5hdHRyTmFtZV0gPSBEZWZpbml0aW9uO1xuICAgIGlmICh0eXBlb2YgRGVmaW5pdGlvbi5rZXlOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBhdHRyaWJ1dGVzW0RlZmluaXRpb24ua2V5TmFtZV0gPSBEZWZpbml0aW9uO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKERlZmluaXRpb24uY2xhc3NOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsYXNzZXNbRGVmaW5pdGlvbi5jbGFzc05hbWVdID0gRGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRGVmaW5pdGlvbi50YWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KERlZmluaXRpb24udGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBEZWZpbml0aW9uLnRhZ05hbWUgPSBEZWZpbml0aW9uLnRhZ05hbWUubWFwKGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBEZWZpbml0aW9uLnRhZ05hbWUgPSBEZWZpbml0aW9uLnRhZ05hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YWdOYW1lcyA9IEFycmF5LmlzQXJyYXkoRGVmaW5pdGlvbi50YWdOYW1lKSA/IERlZmluaXRpb24udGFnTmFtZSA6IFtEZWZpbml0aW9uLnRhZ05hbWVdO1xuICAgICAgICAgICAgdGFnTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ3NbdGFnXSA9PSBudWxsIHx8IERlZmluaXRpb24uY2xhc3NOYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnc1t0YWddID0gRGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRGVmaW5pdGlvbjtcbn1cbmV4cG9ydHMucmVnaXN0ZXIgPSByZWdpc3RlcjtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRpZmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbnZhciBlcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIGV4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgb3AgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxuXG52YXIgTlVMTF9DSEFSQUNURVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDApOyAgLy8gUGxhY2Vob2xkZXIgY2hhciBmb3IgZW1iZWQgaW4gZGlmZigpXG5cblxudmFyIERlbHRhID0gZnVuY3Rpb24gKG9wcykge1xuICAvLyBBc3N1bWUgd2UgYXJlIGdpdmVuIGEgd2VsbCBmb3JtZWQgb3BzXG4gIGlmIChBcnJheS5pc0FycmF5KG9wcykpIHtcbiAgICB0aGlzLm9wcyA9IG9wcztcbiAgfSBlbHNlIGlmIChvcHMgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KG9wcy5vcHMpKSB7XG4gICAgdGhpcy5vcHMgPSBvcHMub3BzO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3BzID0gW107XG4gIH1cbn07XG5cblxuRGVsdGEucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICh0ZXh0LCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBuZXdPcCA9IHt9O1xuICBpZiAodGV4dC5sZW5ndGggPT09IDApIHJldHVybiB0aGlzO1xuICBuZXdPcC5pbnNlcnQgPSB0ZXh0O1xuICBpZiAoYXR0cmlidXRlcyAhPSBudWxsICYmIHR5cGVvZiBhdHRyaWJ1dGVzID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgbmV3T3AuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHVzaChuZXdPcCk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoIDw9IDApIHJldHVybiB0aGlzO1xuICByZXR1cm4gdGhpcy5wdXNoKHsgJ2RlbGV0ZSc6IGxlbmd0aCB9KTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5yZXRhaW4gPSBmdW5jdGlvbiAobGVuZ3RoLCBhdHRyaWJ1dGVzKSB7XG4gIGlmIChsZW5ndGggPD0gMCkgcmV0dXJuIHRoaXM7XG4gIHZhciBuZXdPcCA9IHsgcmV0YWluOiBsZW5ndGggfTtcbiAgaWYgKGF0dHJpYnV0ZXMgIT0gbnVsbCAmJiB0eXBlb2YgYXR0cmlidXRlcyA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgIG5ld09wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICB9XG4gIHJldHVybiB0aGlzLnB1c2gobmV3T3ApO1xufTtcblxuRGVsdGEucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobmV3T3ApIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5vcHMubGVuZ3RoO1xuICB2YXIgbGFzdE9wID0gdGhpcy5vcHNbaW5kZXggLSAxXTtcbiAgbmV3T3AgPSBleHRlbmQodHJ1ZSwge30sIG5ld09wKTtcbiAgaWYgKHR5cGVvZiBsYXN0T3AgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdPcFsnZGVsZXRlJ10gPT09ICdudW1iZXInICYmIHR5cGVvZiBsYXN0T3BbJ2RlbGV0ZSddID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5vcHNbaW5kZXggLSAxXSA9IHsgJ2RlbGV0ZSc6IGxhc3RPcFsnZGVsZXRlJ10gKyBuZXdPcFsnZGVsZXRlJ10gfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBTaW5jZSBpdCBkb2VzIG5vdCBtYXR0ZXIgaWYgd2UgaW5zZXJ0IGJlZm9yZSBvciBhZnRlciBkZWxldGluZyBhdCB0aGUgc2FtZSBpbmRleCxcbiAgICAvLyBhbHdheXMgcHJlZmVyIHRvIGluc2VydCBmaXJzdFxuICAgIGlmICh0eXBlb2YgbGFzdE9wWydkZWxldGUnXSA9PT0gJ251bWJlcicgJiYgbmV3T3AuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICAgIGluZGV4IC09IDE7XG4gICAgICBsYXN0T3AgPSB0aGlzLm9wc1tpbmRleCAtIDFdO1xuICAgICAgaWYgKHR5cGVvZiBsYXN0T3AgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMub3BzLnVuc2hpZnQobmV3T3ApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVxdWFsKG5ld09wLmF0dHJpYnV0ZXMsIGxhc3RPcC5hdHRyaWJ1dGVzKSkge1xuICAgICAgaWYgKHR5cGVvZiBuZXdPcC5pbnNlcnQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBsYXN0T3AuaW5zZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9wc1tpbmRleCAtIDFdID0geyBpbnNlcnQ6IGxhc3RPcC5pbnNlcnQgKyBuZXdPcC5pbnNlcnQgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPcC5hdHRyaWJ1dGVzID09PSAnb2JqZWN0JykgdGhpcy5vcHNbaW5kZXggLSAxXS5hdHRyaWJ1dGVzID0gbmV3T3AuYXR0cmlidXRlc1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5ld09wLnJldGFpbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGxhc3RPcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMub3BzW2luZGV4IC0gMV0gPSB7IHJldGFpbjogbGFzdE9wLnJldGFpbiArIG5ld09wLnJldGFpbiB9O1xuICAgICAgICBpZiAodHlwZW9mIG5ld09wLmF0dHJpYnV0ZXMgPT09ICdvYmplY3QnKSB0aGlzLm9wc1tpbmRleCAtIDFdLmF0dHJpYnV0ZXMgPSBuZXdPcC5hdHRyaWJ1dGVzXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5kZXggPT09IHRoaXMub3BzLmxlbmd0aCkge1xuICAgIHRoaXMub3BzLnB1c2gobmV3T3ApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3BzLnNwbGljZShpbmRleCwgMCwgbmV3T3ApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuRGVsdGEucHJvdG90eXBlLmNob3AgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsYXN0T3AgPSB0aGlzLm9wc1t0aGlzLm9wcy5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RPcCAmJiBsYXN0T3AucmV0YWluICYmICFsYXN0T3AuYXR0cmlidXRlcykge1xuICAgIHRoaXMub3BzLnBvcCgpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuRGVsdGEucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIHRoaXMub3BzLmZpbHRlcihwcmVkaWNhdGUpO1xufTtcblxuRGVsdGEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gIHRoaXMub3BzLmZvckVhY2gocHJlZGljYXRlKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gIHJldHVybiB0aGlzLm9wcy5tYXAocHJlZGljYXRlKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5wYXJ0aXRpb24gPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gIHZhciBwYXNzZWQgPSBbXSwgZmFpbGVkID0gW107XG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbihvcCkge1xuICAgIHZhciB0YXJnZXQgPSBwcmVkaWNhdGUob3ApID8gcGFzc2VkIDogZmFpbGVkO1xuICAgIHRhcmdldC5wdXNoKG9wKTtcbiAgfSk7XG4gIHJldHVybiBbcGFzc2VkLCBmYWlsZWRdO1xufTtcblxuRGVsdGEucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGluaXRpYWwpIHtcbiAgcmV0dXJuIHRoaXMub3BzLnJlZHVjZShwcmVkaWNhdGUsIGluaXRpYWwpO1xufTtcblxuRGVsdGEucHJvdG90eXBlLmNoYW5nZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVkdWNlKGZ1bmN0aW9uIChsZW5ndGgsIGVsZW0pIHtcbiAgICBpZiAoZWxlbS5pbnNlcnQpIHtcbiAgICAgIHJldHVybiBsZW5ndGggKyBvcC5sZW5ndGgoZWxlbSk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmRlbGV0ZSkge1xuICAgICAgcmV0dXJuIGxlbmd0aCAtIGVsZW0uZGVsZXRlO1xuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9LCAwKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlZHVjZShmdW5jdGlvbiAobGVuZ3RoLCBlbGVtKSB7XG4gICAgcmV0dXJuIGxlbmd0aCArIG9wLmxlbmd0aChlbGVtKTtcbiAgfSwgMCk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJykgZW5kID0gSW5maW5pdHk7XG4gIHZhciBvcHMgPSBbXTtcbiAgdmFyIGl0ZXIgPSBvcC5pdGVyYXRvcih0aGlzLm9wcyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IGVuZCAmJiBpdGVyLmhhc05leHQoKSkge1xuICAgIHZhciBuZXh0T3A7XG4gICAgaWYgKGluZGV4IDwgc3RhcnQpIHtcbiAgICAgIG5leHRPcCA9IGl0ZXIubmV4dChzdGFydCAtIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dE9wID0gaXRlci5uZXh0KGVuZCAtIGluZGV4KTtcbiAgICAgIG9wcy5wdXNoKG5leHRPcCk7XG4gICAgfVxuICAgIGluZGV4ICs9IG9wLmxlbmd0aChuZXh0T3ApO1xuICB9XG4gIHJldHVybiBuZXcgRGVsdGEob3BzKTtcbn07XG5cblxuRGVsdGEucHJvdG90eXBlLmNvbXBvc2UgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgdmFyIHRoaXNJdGVyID0gb3AuaXRlcmF0b3IodGhpcy5vcHMpO1xuICB2YXIgb3RoZXJJdGVyID0gb3AuaXRlcmF0b3Iob3RoZXIub3BzKTtcbiAgdmFyIG9wcyA9IFtdO1xuICB2YXIgZmlyc3RPdGhlciA9IG90aGVySXRlci5wZWVrKCk7XG4gIGlmIChmaXJzdE90aGVyICE9IG51bGwgJiYgdHlwZW9mIGZpcnN0T3RoZXIucmV0YWluID09PSAnbnVtYmVyJyAmJiBmaXJzdE90aGVyLmF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdExlZnQgPSBmaXJzdE90aGVyLnJldGFpbjtcbiAgICB3aGlsZSAodGhpc0l0ZXIucGVla1R5cGUoKSA9PT0gJ2luc2VydCcgJiYgdGhpc0l0ZXIucGVla0xlbmd0aCgpIDw9IGZpcnN0TGVmdCkge1xuICAgICAgZmlyc3RMZWZ0IC09IHRoaXNJdGVyLnBlZWtMZW5ndGgoKTtcbiAgICAgIG9wcy5wdXNoKHRoaXNJdGVyLm5leHQoKSk7XG4gICAgfVxuICAgIGlmIChmaXJzdE90aGVyLnJldGFpbiAtIGZpcnN0TGVmdCA+IDApIHtcbiAgICAgIG90aGVySXRlci5uZXh0KGZpcnN0T3RoZXIucmV0YWluIC0gZmlyc3RMZWZ0KTtcbiAgICB9XG4gIH1cbiAgdmFyIGRlbHRhID0gbmV3IERlbHRhKG9wcyk7XG4gIHdoaWxlICh0aGlzSXRlci5oYXNOZXh0KCkgfHwgb3RoZXJJdGVyLmhhc05leHQoKSkge1xuICAgIGlmIChvdGhlckl0ZXIucGVla1R5cGUoKSA9PT0gJ2luc2VydCcpIHtcbiAgICAgIGRlbHRhLnB1c2gob3RoZXJJdGVyLm5leHQoKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzSXRlci5wZWVrVHlwZSgpID09PSAnZGVsZXRlJykge1xuICAgICAgZGVsdGEucHVzaCh0aGlzSXRlci5uZXh0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4odGhpc0l0ZXIucGVla0xlbmd0aCgpLCBvdGhlckl0ZXIucGVla0xlbmd0aCgpKTtcbiAgICAgIHZhciB0aGlzT3AgPSB0aGlzSXRlci5uZXh0KGxlbmd0aCk7XG4gICAgICB2YXIgb3RoZXJPcCA9IG90aGVySXRlci5uZXh0KGxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIG90aGVyT3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgbmV3T3AgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzT3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG5ld09wLnJldGFpbiA9IGxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdPcC5pbnNlcnQgPSB0aGlzT3AuaW5zZXJ0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXNlcnZlIG51bGwgd2hlbiBjb21wb3Npbmcgd2l0aCBhIHJldGFpbiwgb3RoZXJ3aXNlIHJlbW92ZSBpdCBmb3IgaW5zZXJ0c1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG9wLmF0dHJpYnV0ZXMuY29tcG9zZSh0aGlzT3AuYXR0cmlidXRlcywgb3RoZXJPcC5hdHRyaWJ1dGVzLCB0eXBlb2YgdGhpc09wLnJldGFpbiA9PT0gJ251bWJlcicpO1xuICAgICAgICBpZiAoYXR0cmlidXRlcykgbmV3T3AuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIGRlbHRhLnB1c2gobmV3T3ApO1xuXG4gICAgICAgIC8vIE9wdGltaXphdGlvbiBpZiByZXN0IG9mIG90aGVyIGlzIGp1c3QgcmV0YWluXG4gICAgICAgIGlmICghb3RoZXJJdGVyLmhhc05leHQoKSAmJiBlcXVhbChkZWx0YS5vcHNbZGVsdGEub3BzLmxlbmd0aCAtIDFdLCBuZXdPcCkpIHtcbiAgICAgICAgICB2YXIgcmVzdCA9IG5ldyBEZWx0YSh0aGlzSXRlci5yZXN0KCkpO1xuICAgICAgICAgIHJldHVybiBkZWx0YS5jb25jYXQocmVzdCkuY2hvcCgpO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE90aGVyIG9wIHNob3VsZCBiZSBkZWxldGUsIHdlIGNvdWxkIGJlIGFuIGluc2VydCBvciByZXRhaW5cbiAgICAgIC8vIEluc2VydCArIGRlbGV0ZSBjYW5jZWxzIG91dFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3RoZXJPcFsnZGVsZXRlJ10gPT09ICdudW1iZXInICYmIHR5cGVvZiB0aGlzT3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgICBkZWx0YS5wdXNoKG90aGVyT3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVsdGEuY2hvcCgpO1xufTtcblxuRGVsdGEucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICB2YXIgZGVsdGEgPSBuZXcgRGVsdGEodGhpcy5vcHMuc2xpY2UoKSk7XG4gIGlmIChvdGhlci5vcHMubGVuZ3RoID4gMCkge1xuICAgIGRlbHRhLnB1c2gob3RoZXIub3BzWzBdKTtcbiAgICBkZWx0YS5vcHMgPSBkZWx0YS5vcHMuY29uY2F0KG90aGVyLm9wcy5zbGljZSgxKSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufTtcblxuRGVsdGEucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAob3RoZXIsIGluZGV4KSB7XG4gIGlmICh0aGlzLm9wcyA9PT0gb3RoZXIub3BzKSB7XG4gICAgcmV0dXJuIG5ldyBEZWx0YSgpO1xuICB9XG4gIHZhciBzdHJpbmdzID0gW3RoaXMsIG90aGVyXS5tYXAoZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgcmV0dXJuIGRlbHRhLm1hcChmdW5jdGlvbiAob3ApIHtcbiAgICAgIGlmIChvcC5pbnNlcnQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycgPyBvcC5pbnNlcnQgOiBOVUxMX0NIQVJBQ1RFUjtcbiAgICAgIH1cbiAgICAgIHZhciBwcmVwID0gKGRlbHRhID09PSBvdGhlcikgPyAnb24nIDogJ3dpdGgnO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWZmKCkgY2FsbGVkICcgKyBwcmVwICsgJyBub24tZG9jdW1lbnQnKTtcbiAgICB9KS5qb2luKCcnKTtcbiAgfSk7XG4gIHZhciBkZWx0YSA9IG5ldyBEZWx0YSgpO1xuICB2YXIgZGlmZlJlc3VsdCA9IGRpZmYoc3RyaW5nc1swXSwgc3RyaW5nc1sxXSwgaW5kZXgpO1xuICB2YXIgdGhpc0l0ZXIgPSBvcC5pdGVyYXRvcih0aGlzLm9wcyk7XG4gIHZhciBvdGhlckl0ZXIgPSBvcC5pdGVyYXRvcihvdGhlci5vcHMpO1xuICBkaWZmUmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIHZhciBsZW5ndGggPSBjb21wb25lbnRbMV0ubGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICB2YXIgb3BMZW5ndGggPSAwO1xuICAgICAgc3dpdGNoIChjb21wb25lbnRbMF0pIHtcbiAgICAgICAgY2FzZSBkaWZmLklOU0VSVDpcbiAgICAgICAgICBvcExlbmd0aCA9IE1hdGgubWluKG90aGVySXRlci5wZWVrTGVuZ3RoKCksIGxlbmd0aCk7XG4gICAgICAgICAgZGVsdGEucHVzaChvdGhlckl0ZXIubmV4dChvcExlbmd0aCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGRpZmYuREVMRVRFOlxuICAgICAgICAgIG9wTGVuZ3RoID0gTWF0aC5taW4obGVuZ3RoLCB0aGlzSXRlci5wZWVrTGVuZ3RoKCkpO1xuICAgICAgICAgIHRoaXNJdGVyLm5leHQob3BMZW5ndGgpO1xuICAgICAgICAgIGRlbHRhWydkZWxldGUnXShvcExlbmd0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZGlmZi5FUVVBTDpcbiAgICAgICAgICBvcExlbmd0aCA9IE1hdGgubWluKHRoaXNJdGVyLnBlZWtMZW5ndGgoKSwgb3RoZXJJdGVyLnBlZWtMZW5ndGgoKSwgbGVuZ3RoKTtcbiAgICAgICAgICB2YXIgdGhpc09wID0gdGhpc0l0ZXIubmV4dChvcExlbmd0aCk7XG4gICAgICAgICAgdmFyIG90aGVyT3AgPSBvdGhlckl0ZXIubmV4dChvcExlbmd0aCk7XG4gICAgICAgICAgaWYgKGVxdWFsKHRoaXNPcC5pbnNlcnQsIG90aGVyT3AuaW5zZXJ0KSkge1xuICAgICAgICAgICAgZGVsdGEucmV0YWluKG9wTGVuZ3RoLCBvcC5hdHRyaWJ1dGVzLmRpZmYodGhpc09wLmF0dHJpYnV0ZXMsIG90aGVyT3AuYXR0cmlidXRlcykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YS5wdXNoKG90aGVyT3ApWydkZWxldGUnXShvcExlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGVuZ3RoIC09IG9wTGVuZ3RoO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkZWx0YS5jaG9wKCk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUuZWFjaExpbmUgPSBmdW5jdGlvbiAocHJlZGljYXRlLCBuZXdsaW5lKSB7XG4gIG5ld2xpbmUgPSBuZXdsaW5lIHx8ICdcXG4nO1xuICB2YXIgaXRlciA9IG9wLml0ZXJhdG9yKHRoaXMub3BzKTtcbiAgdmFyIGxpbmUgPSBuZXcgRGVsdGEoKTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICBpZiAoaXRlci5wZWVrVHlwZSgpICE9PSAnaW5zZXJ0JykgcmV0dXJuO1xuICAgIHZhciB0aGlzT3AgPSBpdGVyLnBlZWsoKTtcbiAgICB2YXIgc3RhcnQgPSBvcC5sZW5ndGgodGhpc09wKSAtIGl0ZXIucGVla0xlbmd0aCgpO1xuICAgIHZhciBpbmRleCA9IHR5cGVvZiB0aGlzT3AuaW5zZXJ0ID09PSAnc3RyaW5nJyA/XG4gICAgICB0aGlzT3AuaW5zZXJ0LmluZGV4T2YobmV3bGluZSwgc3RhcnQpIC0gc3RhcnQgOiAtMTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBsaW5lLnB1c2goaXRlci5uZXh0KCkpO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPiAwKSB7XG4gICAgICBsaW5lLnB1c2goaXRlci5uZXh0KGluZGV4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmVkaWNhdGUobGluZSwgaXRlci5uZXh0KDEpLmF0dHJpYnV0ZXMgfHwge30sIGkpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpICs9IDE7XG4gICAgICBsaW5lID0gbmV3IERlbHRhKCk7XG4gICAgfVxuICB9XG4gIGlmIChsaW5lLmxlbmd0aCgpID4gMCkge1xuICAgIHByZWRpY2F0ZShsaW5lLCB7fSwgaSk7XG4gIH1cbn07XG5cbkRlbHRhLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAob3RoZXIsIHByaW9yaXR5KSB7XG4gIHByaW9yaXR5ID0gISFwcmlvcml0eTtcbiAgaWYgKHR5cGVvZiBvdGhlciA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb3NpdGlvbihvdGhlciwgcHJpb3JpdHkpO1xuICB9XG4gIHZhciB0aGlzSXRlciA9IG9wLml0ZXJhdG9yKHRoaXMub3BzKTtcbiAgdmFyIG90aGVySXRlciA9IG9wLml0ZXJhdG9yKG90aGVyLm9wcyk7XG4gIHZhciBkZWx0YSA9IG5ldyBEZWx0YSgpO1xuICB3aGlsZSAodGhpc0l0ZXIuaGFzTmV4dCgpIHx8IG90aGVySXRlci5oYXNOZXh0KCkpIHtcbiAgICBpZiAodGhpc0l0ZXIucGVla1R5cGUoKSA9PT0gJ2luc2VydCcgJiYgKHByaW9yaXR5IHx8IG90aGVySXRlci5wZWVrVHlwZSgpICE9PSAnaW5zZXJ0JykpIHtcbiAgICAgIGRlbHRhLnJldGFpbihvcC5sZW5ndGgodGhpc0l0ZXIubmV4dCgpKSk7XG4gICAgfSBlbHNlIGlmIChvdGhlckl0ZXIucGVla1R5cGUoKSA9PT0gJ2luc2VydCcpIHtcbiAgICAgIGRlbHRhLnB1c2gob3RoZXJJdGVyLm5leHQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbih0aGlzSXRlci5wZWVrTGVuZ3RoKCksIG90aGVySXRlci5wZWVrTGVuZ3RoKCkpO1xuICAgICAgdmFyIHRoaXNPcCA9IHRoaXNJdGVyLm5leHQobGVuZ3RoKTtcbiAgICAgIHZhciBvdGhlck9wID0gb3RoZXJJdGVyLm5leHQobGVuZ3RoKTtcbiAgICAgIGlmICh0aGlzT3BbJ2RlbGV0ZSddKSB7XG4gICAgICAgIC8vIE91ciBkZWxldGUgZWl0aGVyIG1ha2VzIHRoZWlyIGRlbGV0ZSByZWR1bmRhbnQgb3IgcmVtb3ZlcyB0aGVpciByZXRhaW5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyT3BbJ2RlbGV0ZSddKSB7XG4gICAgICAgIGRlbHRhLnB1c2gob3RoZXJPcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSByZXRhaW4gZWl0aGVyIHRoZWlyIHJldGFpbiBvciBpbnNlcnRcbiAgICAgICAgZGVsdGEucmV0YWluKGxlbmd0aCwgb3AuYXR0cmlidXRlcy50cmFuc2Zvcm0odGhpc09wLmF0dHJpYnV0ZXMsIG90aGVyT3AuYXR0cmlidXRlcywgcHJpb3JpdHkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlbHRhLmNob3AoKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS50cmFuc2Zvcm1Qb3NpdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgcHJpb3JpdHkpIHtcbiAgcHJpb3JpdHkgPSAhIXByaW9yaXR5O1xuICB2YXIgdGhpc0l0ZXIgPSBvcC5pdGVyYXRvcih0aGlzLm9wcyk7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB3aGlsZSAodGhpc0l0ZXIuaGFzTmV4dCgpICYmIG9mZnNldCA8PSBpbmRleCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzSXRlci5wZWVrTGVuZ3RoKCk7XG4gICAgdmFyIG5leHRUeXBlID0gdGhpc0l0ZXIucGVla1R5cGUoKTtcbiAgICB0aGlzSXRlci5uZXh0KCk7XG4gICAgaWYgKG5leHRUeXBlID09PSAnZGVsZXRlJykge1xuICAgICAgaW5kZXggLT0gTWF0aC5taW4obGVuZ3RoLCBpbmRleCAtIG9mZnNldCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKG5leHRUeXBlID09PSAnaW5zZXJ0JyAmJiAob2Zmc2V0IDwgaW5kZXggfHwgIXByaW9yaXR5KSkge1xuICAgICAgaW5kZXggKz0gbGVuZ3RoO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEZWx0YTtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShhcnIpIHtcblx0aWYgKHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKTtcblx0fVxuXG5cdHJldHVybiB0b1N0ci5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG5cdGlmICghb2JqIHx8IHRvU3RyLmNhbGwob2JqKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgaGFzT3duQ29uc3RydWN0b3IgPSBoYXNPd24uY2FsbChvYmosICdjb25zdHJ1Y3RvcicpO1xuXHR2YXIgaGFzSXNQcm90b3R5cGVPZiA9IG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IucHJvdG90eXBlICYmIGhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICdpc1Byb3RvdHlwZU9mJyk7XG5cdC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3Rcblx0aWYgKG9iai5jb25zdHJ1Y3RvciAmJiAhaGFzT3duQ29uc3RydWN0b3IgJiYgIWhhc0lzUHJvdG90eXBlT2YpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cdHZhciBrZXk7XG5cdGZvciAoa2V5IGluIG9iaikgeyAvKiovIH1cblxuXHRyZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwgaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufTtcblxuLy8gSWYgbmFtZSBpcyAnX19wcm90b19fJywgYW5kIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBpcyBhdmFpbGFibGUsIGRlZmluZSBfX3Byb3RvX18gYXMgYW4gb3duIHByb3BlcnR5IG9uIHRhcmdldFxudmFyIHNldFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJvcGVydHkodGFyZ2V0LCBvcHRpb25zKSB7XG5cdGlmIChkZWZpbmVQcm9wZXJ0eSAmJiBvcHRpb25zLm5hbWUgPT09ICdfX3Byb3RvX18nKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBvcHRpb25zLm5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHR2YWx1ZTogb3B0aW9ucy5uZXdWYWx1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0dGFyZ2V0W29wdGlvbnMubmFtZV0gPSBvcHRpb25zLm5ld1ZhbHVlO1xuXHR9XG59O1xuXG4vLyBSZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQgb2YgX19wcm90b19fIGlmICdfX3Byb3RvX18nIGlzIG5vdCBhbiBvd24gcHJvcGVydHlcbnZhciBnZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIGdldFByb3BlcnR5KG9iaiwgbmFtZSkge1xuXHRpZiAobmFtZSA9PT0gJ19fcHJvdG9fXycpIHtcblx0XHRpZiAoIWhhc093bi5jYWxsKG9iaiwgbmFtZSkpIHtcblx0XHRcdHJldHVybiB2b2lkIDA7XG5cdFx0fSBlbHNlIGlmIChnT1BEKSB7XG5cdFx0XHQvLyBJbiBlYXJseSB2ZXJzaW9ucyBvZiBub2RlLCBvYmpbJ19fcHJvdG9fXyddIGlzIGJ1Z2d5IHdoZW4gb2JqIGhhc1xuXHRcdFx0Ly8gX19wcm90b19fIGFzIGFuIG93biBwcm9wZXJ0eS4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcigpIHdvcmtzLlxuXHRcdFx0cmV0dXJuIGdPUEQob2JqLCBuYW1lKS52YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb2JqW25hbWVdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRlbmQoKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZTtcblx0dmFyIHRhcmdldCA9IGFyZ3VtZW50c1swXTtcblx0dmFyIGkgPSAxO1xuXHR2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblx0dmFyIGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnYm9vbGVhbicpIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcblx0XHQvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0aSA9IDI7XG5cdH1cblx0aWYgKHRhcmdldCA9PSBudWxsIHx8ICh0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Zm9yICg7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbaV07XG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmIChvcHRpb25zICE9IG51bGwpIHtcblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG5cdFx0XHRcdHNyYyA9IGdldFByb3BlcnR5KHRhcmdldCwgbmFtZSk7XG5cdFx0XHRcdGNvcHkgPSBnZXRQcm9wZXJ0eShvcHRpb25zLCBuYW1lKTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICh0YXJnZXQgIT09IGNvcHkpIHtcblx0XHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0XHRpZiAoZGVlcCAmJiBjb3B5ICYmIChpc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGlzQXJyYXkoY29weSkpKSkge1xuXHRcdFx0XHRcdFx0aWYgKGNvcHlJc0FycmF5KSB7XG5cdFx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdFx0c2V0UHJvcGVydHkodGFyZ2V0LCB7IG5hbWU6IG5hbWUsIG5ld1ZhbHVlOiBleHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpIH0pO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGNvcHkgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHRzZXRQcm9wZXJ0eSh0YXJnZXQsIHsgbmFtZTogbmFtZSwgbmV3VmFsdWU6IGNvcHkgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkJsb2NrRW1iZWQgPSBleHBvcnRzLmJ1YmJsZUZvcm1hdHMgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQpO1xuXG52YXIgX3F1aWxsRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3F1aWxsRGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGxEZWx0YSk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9icmVhayA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX2JyZWFrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JyZWFrKTtcblxudmFyIF9pbmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX2lubGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmxpbmUpO1xuXG52YXIgX3RleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3RleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIE5FV0xJTkVfTEVOR1RIID0gMTtcblxudmFyIEJsb2NrRW1iZWQgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRFbWJlZCkge1xuICBfaW5oZXJpdHMoQmxvY2tFbWJlZCwgX1BhcmNobWVudCRFbWJlZCk7XG5cbiAgZnVuY3Rpb24gQmxvY2tFbWJlZCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmxvY2tFbWJlZCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJsb2NrRW1iZWQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9ja0VtYmVkKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmxvY2tFbWJlZCwgW3tcbiAgICBrZXk6ICdhdHRhY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgICBfZ2V0KEJsb2NrRW1iZWQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2tFbWJlZC5wcm90b3R5cGUpLCAnYXR0YWNoJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuU3RvcmUodGhpcy5kb21Ob2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWx0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbHRhKCkge1xuICAgICAgcmV0dXJuIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLmluc2VydCh0aGlzLnZhbHVlKCksICgwLCBfZXh0ZW5kMi5kZWZhdWx0KSh0aGlzLmZvcm1hdHMoKSwgdGhpcy5hdHRyaWJ1dGVzLnZhbHVlcygpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgYXR0cmlidXRlID0gX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShuYW1lLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLX0FUVFJJQlVURSk7XG4gICAgICBpZiAoYXR0cmlidXRlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLmF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0QXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRBdChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJ1xcbicpKSB7XG4gICAgICAgIHZhciBibG9jayA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKEJsb2NrLmJsb3ROYW1lKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJsb2NrLCBpbmRleCA9PT0gMCA/IHRoaXMgOiB0aGlzLm5leHQpO1xuICAgICAgICBibG9jay5pbnNlcnRBdCgwLCB2YWx1ZS5zbGljZSgwLCAtMSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChCbG9ja0VtYmVkLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrRW1iZWQucHJvdG90eXBlKSwgJ2luc2VydEF0JywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgdmFsdWUsIGRlZik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJsb2NrRW1iZWQ7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQpO1xuXG5CbG9ja0VtYmVkLnNjb3BlID0gX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DS19CTE9UO1xuLy8gSXQgaXMgaW1wb3J0YW50IGZvciBjdXJzb3IgYmVoYXZpb3IgQmxvY2tFbWJlZHMgdXNlIHRhZ3MgdGhhdCBhcmUgYmxvY2sgbGV2ZWwgZWxlbWVudHNcblxuXG52YXIgQmxvY2sgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRCbG9jaykge1xuICBfaW5oZXJpdHMoQmxvY2ssIF9QYXJjaG1lbnQkQmxvY2spO1xuXG4gIGZ1bmN0aW9uIEJsb2NrKGRvbU5vZGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmxvY2spO1xuXG4gICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCbG9jay5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrKSkuY2FsbCh0aGlzLCBkb21Ob2RlKSk7XG5cbiAgICBfdGhpczIuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJsb2NrLCBbe1xuICAgIGtleTogJ2RlbHRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsdGEoKSB7XG4gICAgICBpZiAodGhpcy5jYWNoZS5kZWx0YSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuZGVsdGEgPSB0aGlzLmRlc2NlbmRhbnRzKF9wYXJjaG1lbnQyLmRlZmF1bHQuTGVhZikucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgbGVhZikge1xuICAgICAgICAgIGlmIChsZWFmLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsdGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YS5pbnNlcnQobGVhZi52YWx1ZSgpLCBidWJibGVGb3JtYXRzKGxlYWYpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpKS5pbnNlcnQoJ1xcbicsIGJ1YmJsZUZvcm1hdHModGhpcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZGVsdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlQXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVBdChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdkZWxldGVBdCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0QXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKGxlbmd0aCA8PSAwKSByZXR1cm47XG4gICAgICBpZiAoX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShuYW1lLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLKSkge1xuICAgICAgICBpZiAoaW5kZXggKyBsZW5ndGggPT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICB0aGlzLmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ2Zvcm1hdEF0JywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgTWF0aC5taW4obGVuZ3RoLCB0aGlzLmxlbmd0aCgpIC0gaW5kZXggLSAxKSwgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgIGlmIChkZWYgIT0gbnVsbCkgcmV0dXJuIF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ2luc2VydEF0JywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgdmFsdWUsIGRlZik7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgbGluZXMgPSB2YWx1ZS5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgdGV4dCA9IGxpbmVzLnNoaWZ0KCk7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMubGVuZ3RoKCkgLSAxIHx8IHRoaXMuY2hpbGRyZW4udGFpbCA9PSBudWxsKSB7XG4gICAgICAgICAgX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAnaW5zZXJ0QXQnLCB0aGlzKS5jYWxsKHRoaXMsIE1hdGgubWluKGluZGV4LCB0aGlzLmxlbmd0aCgpIC0gMSksIHRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4udGFpbC5pbnNlcnRBdCh0aGlzLmNoaWxkcmVuLnRhaWwubGVuZ3RoKCksIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBibG9jayA9IHRoaXM7XG4gICAgICBsaW5lcy5yZWR1Y2UoZnVuY3Rpb24gKGluZGV4LCBsaW5lKSB7XG4gICAgICAgIGJsb2NrID0gYmxvY2suc3BsaXQoaW5kZXgsIHRydWUpO1xuICAgICAgICBibG9jay5pbnNlcnRBdCgwLCBsaW5lKTtcbiAgICAgICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xuICAgICAgfSwgaW5kZXggKyB0ZXh0Lmxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0QmVmb3JlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGJsb3QsIHJlZikge1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLmNoaWxkcmVuLmhlYWQ7XG4gICAgICBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdpbnNlcnRCZWZvcmUnLCB0aGlzKS5jYWxsKHRoaXMsIGJsb3QsIHJlZik7XG4gICAgICBpZiAoaGVhZCBpbnN0YW5jZW9mIF9icmVhazIuZGVmYXVsdCkge1xuICAgICAgICBoZWFkLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xlbmd0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2FjaGUubGVuZ3RoID0gX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAnbGVuZ3RoJywgdGhpcykuY2FsbCh0aGlzKSArIE5FV0xJTkVfTEVOR1RIO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGUubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21vdmVDaGlsZHJlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVDaGlsZHJlbih0YXJnZXQsIHJlZikge1xuICAgICAgX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAnbW92ZUNoaWxkcmVuJywgdGhpcykuY2FsbCh0aGlzLCB0YXJnZXQsIHJlZik7XG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb3B0aW1pemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZShjb250ZXh0KSB7XG4gICAgICBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdvcHRpbWl6ZScsIHRoaXMpLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGF0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGgoaW5kZXgpIHtcbiAgICAgIHJldHVybiBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdwYXRoJywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlQ2hpbGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZCkge1xuICAgICAgX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAncmVtb3ZlQ2hpbGQnLCB0aGlzKS5jYWxsKHRoaXMsIGNoaWxkKTtcbiAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzcGxpdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0KGluZGV4KSB7XG4gICAgICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoZm9yY2UgJiYgKGluZGV4ID09PSAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKCkgLSBORVdMSU5FX0xFTkdUSCkpIHtcbiAgICAgICAgdmFyIGNsb25lID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcy5uZXh0KTtcbiAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXh0ID0gX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAnc3BsaXQnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCBmb3JjZSk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJsb2NrO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LkJsb2NrKTtcblxuQmxvY2suYmxvdE5hbWUgPSAnYmxvY2snO1xuQmxvY2sudGFnTmFtZSA9ICdQJztcbkJsb2NrLmRlZmF1bHRDaGlsZCA9ICdicmVhayc7XG5CbG9jay5hbGxvd2VkQ2hpbGRyZW4gPSBbX2lubGluZTIuZGVmYXVsdCwgX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCwgX3RleHQyLmRlZmF1bHRdO1xuXG5mdW5jdGlvbiBidWJibGVGb3JtYXRzKGJsb3QpIHtcbiAgdmFyIGZvcm1hdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIGlmIChibG90ID09IG51bGwpIHJldHVybiBmb3JtYXRzO1xuICBpZiAodHlwZW9mIGJsb3QuZm9ybWF0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvcm1hdHMgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkoZm9ybWF0cywgYmxvdC5mb3JtYXRzKCkpO1xuICB9XG4gIGlmIChibG90LnBhcmVudCA9PSBudWxsIHx8IGJsb3QucGFyZW50LmJsb3ROYW1lID09ICdzY3JvbGwnIHx8IGJsb3QucGFyZW50LnN0YXRpY3Muc2NvcGUgIT09IGJsb3Quc3RhdGljcy5zY29wZSkge1xuICAgIHJldHVybiBmb3JtYXRzO1xuICB9XG4gIHJldHVybiBidWJibGVGb3JtYXRzKGJsb3QucGFyZW50LCBmb3JtYXRzKTtcbn1cblxuZXhwb3J0cy5idWJibGVGb3JtYXRzID0gYnViYmxlRm9ybWF0cztcbmV4cG9ydHMuQmxvY2tFbWJlZCA9IEJsb2NrRW1iZWQ7XG5leHBvcnRzLmRlZmF1bHQgPSBCbG9jaztcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLm92ZXJsb2FkID0gZXhwb3J0cy5leHBhbmRDb25maWcgPSB1bmRlZmluZWQ7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcblxudmFyIF9xdWlsbERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9xdWlsbERlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsRGVsdGEpO1xuXG52YXIgX2VkaXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgX2VkaXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lZGl0b3IpO1xuXG52YXIgX2VtaXR0ZXIzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9lbWl0dGVyNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VtaXR0ZXIzKTtcblxudmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfc2VsZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfc2VsZWN0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlbGVjdGlvbik7XG5cbnZhciBfZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblxudmFyIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcblxudmFyIF90aGVtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG52YXIgX3RoZW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RoZW1lKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGRlYnVnID0gKDAsIF9sb2dnZXIyLmRlZmF1bHQpKCdxdWlsbCcpO1xuXG52YXIgUXVpbGwgPSBmdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhRdWlsbCwgbnVsbCwgW3tcbiAgICBrZXk6ICdkZWJ1ZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlYnVnKGxpbWl0KSB7XG4gICAgICBpZiAobGltaXQgPT09IHRydWUpIHtcbiAgICAgICAgbGltaXQgPSAnbG9nJztcbiAgICAgIH1cbiAgICAgIF9sb2dnZXIyLmRlZmF1bHQubGV2ZWwobGltaXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZpbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLl9fcXVpbGwgfHwgX3BhcmNobWVudDIuZGVmYXVsdC5maW5kKG5vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ltcG9ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbXBvcnQobmFtZSkge1xuICAgICAgaWYgKHRoaXMuaW1wb3J0c1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGRlYnVnLmVycm9yKCdDYW5ub3QgaW1wb3J0ICcgKyBuYW1lICsgJy4gQXJlIHlvdSBzdXJlIGl0IHdhcyByZWdpc3RlcmVkPycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0c1tuYW1lXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKHBhdGgsIHRhcmdldCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIG92ZXJ3cml0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXRoLmF0dHJOYW1lIHx8IHBhdGguYmxvdE5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyByZWdpc3RlcihCbG90IHwgQXR0cmlidXRvciwgb3ZlcndyaXRlKVxuICAgICAgICAgIHRoaXMucmVnaXN0ZXIoJ2Zvcm1hdHMvJyArIG5hbWUsIHBhdGgsIHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMocGF0aCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBfdGhpcy5yZWdpc3RlcihrZXksIHBhdGhba2V5XSwgdGFyZ2V0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaW1wb3J0c1twYXRoXSAhPSBudWxsICYmICFvdmVyd3JpdGUpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKCdPdmVyd3JpdGluZyAnICsgcGF0aCArICcgd2l0aCcsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXBvcnRzW3BhdGhdID0gdGFyZ2V0O1xuICAgICAgICBpZiAoKHBhdGguc3RhcnRzV2l0aCgnYmxvdHMvJykgfHwgcGF0aC5zdGFydHNXaXRoKCdmb3JtYXRzLycpKSAmJiB0YXJnZXQuYmxvdE5hbWUgIT09ICdhYnN0cmFjdCcpIHtcbiAgICAgICAgICBfcGFyY2htZW50Mi5kZWZhdWx0LnJlZ2lzdGVyKHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0aC5zdGFydHNXaXRoKCdtb2R1bGVzJykgJiYgdHlwZW9mIHRhcmdldC5yZWdpc3RlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRhcmdldC5yZWdpc3RlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gUXVpbGwoY29udGFpbmVyKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVpbGwpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gZXhwYW5kQ29uZmlnKGNvbnRhaW5lciwgb3B0aW9ucyk7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGVidWcuZXJyb3IoJ0ludmFsaWQgUXVpbGwgY29udGFpbmVyJywgY29udGFpbmVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgUXVpbGwuZGVidWcodGhpcy5vcHRpb25zLmRlYnVnKTtcbiAgICB9XG4gICAgdmFyIGh0bWwgPSB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwudHJpbSgpO1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3FsLWNvbnRhaW5lcicpO1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuY29udGFpbmVyLl9fcXVpbGwgPSB0aGlzO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuYWRkQ29udGFpbmVyKCdxbC1lZGl0b3InKTtcbiAgICB0aGlzLnJvb3QuY2xhc3NMaXN0LmFkZCgncWwtYmxhbmsnKTtcbiAgICB0aGlzLnJvb3Quc2V0QXR0cmlidXRlKCdkYXRhLWdyYW1tJywgZmFsc2UpO1xuICAgIHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyID0gdGhpcy5vcHRpb25zLnNjcm9sbGluZ0NvbnRhaW5lciB8fCB0aGlzLnJvb3Q7XG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IF9lbWl0dGVyNC5kZWZhdWx0KCk7XG4gICAgdGhpcy5zY3JvbGwgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh0aGlzLnJvb3QsIHtcbiAgICAgIGVtaXR0ZXI6IHRoaXMuZW1pdHRlcixcbiAgICAgIHdoaXRlbGlzdDogdGhpcy5vcHRpb25zLmZvcm1hdHNcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvciA9IG5ldyBfZWRpdG9yMi5kZWZhdWx0KHRoaXMuc2Nyb2xsKTtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IG5ldyBfc2VsZWN0aW9uMi5kZWZhdWx0KHRoaXMuc2Nyb2xsLCB0aGlzLmVtaXR0ZXIpO1xuICAgIHRoaXMudGhlbWUgPSBuZXcgdGhpcy5vcHRpb25zLnRoZW1lKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5rZXlib2FyZCA9IHRoaXMudGhlbWUuYWRkTW9kdWxlKCdrZXlib2FyZCcpO1xuICAgIHRoaXMuY2xpcGJvYXJkID0gdGhpcy50aGVtZS5hZGRNb2R1bGUoJ2NsaXBib2FyZCcpO1xuICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMudGhlbWUuYWRkTW9kdWxlKCdoaXN0b3J5Jyk7XG4gICAgdGhpcy50aGVtZS5pbml0KCk7XG4gICAgdGhpcy5lbWl0dGVyLm9uKF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5FRElUT1JfQ0hBTkdFLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5URVhUX0NIQU5HRSkge1xuICAgICAgICBfdGhpczIucm9vdC5jbGFzc0xpc3QudG9nZ2xlKCdxbC1ibGFuaycsIF90aGlzMi5lZGl0b3IuaXNCbGFuaygpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXR0ZXIub24oX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLlNDUk9MTF9VUERBVEUsIGZ1bmN0aW9uIChzb3VyY2UsIG11dGF0aW9ucykge1xuICAgICAgdmFyIHJhbmdlID0gX3RoaXMyLnNlbGVjdGlvbi5sYXN0UmFuZ2U7XG4gICAgICB2YXIgaW5kZXggPSByYW5nZSAmJiByYW5nZS5sZW5ndGggPT09IDAgPyByYW5nZS5pbmRleCA6IHVuZGVmaW5lZDtcbiAgICAgIG1vZGlmeS5jYWxsKF90aGlzMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmVkaXRvci51cGRhdGUobnVsbCwgbXV0YXRpb25zLCBpbmRleCk7XG4gICAgICB9LCBzb3VyY2UpO1xuICAgIH0pO1xuICAgIHZhciBjb250ZW50cyA9IHRoaXMuY2xpcGJvYXJkLmNvbnZlcnQoJzxkaXYgY2xhc3M9XFwncWwtZWRpdG9yXFwnIHN0eWxlPVwid2hpdGUtc3BhY2U6IG5vcm1hbDtcIj4nICsgaHRtbCArICc8cD48YnI+PC9wPjwvZGl2PicpO1xuICAgIHRoaXMuc2V0Q29udGVudHMoY29udGVudHMpO1xuICAgIHRoaXMuaGlzdG9yeS5jbGVhcigpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIpIHtcbiAgICAgIHRoaXMucm9vdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2Vob2xkZXInLCB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlYWRPbmx5KSB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUXVpbGwsIFt7XG4gICAga2V5OiAnYWRkQ29udGFpbmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgdmFyIHJlZk5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGFpbmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gY29udGFpbmVyO1xuICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIHJlZk5vZGUpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdibHVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmx1cigpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFJhbmdlKG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVUZXh0KGluZGV4LCBsZW5ndGgsIHNvdXJjZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoLCBzb3VyY2UpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMiA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZCwgNCk7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkMlswXTtcbiAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDJbMV07XG4gICAgICBzb3VyY2UgPSBfb3ZlcmxvYWQyWzNdO1xuXG4gICAgICByZXR1cm4gbW9kaWZ5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLmVkaXRvci5kZWxldGVUZXh0KGluZGV4LCBsZW5ndGgpO1xuICAgICAgfSwgc291cmNlLCBpbmRleCwgLTEgKiBsZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5lbmFibGUoZmFsc2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHZhciBlbmFibGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgICB0aGlzLnNjcm9sbC5lbmFibGUoZW5hYmxlZCk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QudG9nZ2xlKCdxbC1kaXNhYmxlZCcsICFlbmFibGVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb2N1cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLmZvY3VzKCk7XG4gICAgICB0aGlzLnNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICB0aGlzLnNjcm9sbEludG9WaWV3KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5BUEk7XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IF90aGlzNC5nZXRTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKTtcbiAgICAgICAgaWYgKHJhbmdlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgICAgICB9IGVsc2UgaWYgKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobmFtZSwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSykpIHtcbiAgICAgICAgICBjaGFuZ2UgPSBfdGhpczQuZWRpdG9yLmZvcm1hdExpbmUocmFuZ2UuaW5kZXgsIHJhbmdlLmxlbmd0aCwgX2RlZmluZVByb3BlcnR5KHt9LCBuYW1lLCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIF90aGlzNC5zZWxlY3Rpb24uZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoYW5nZSA9IF90aGlzNC5lZGl0b3IuZm9ybWF0VGV4dChyYW5nZS5pbmRleCwgcmFuZ2UubGVuZ3RoLCBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWUsIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXM0LnNldFNlbGVjdGlvbihyYW5nZSwgX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgICAgfSwgc291cmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRMaW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0TGluZShpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSwgc291cmNlKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHMgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQzID0gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUsIHNvdXJjZSk7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQ0ID0gX3NsaWNlZFRvQXJyYXkoX292ZXJsb2FkMywgNCk7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkNFswXTtcbiAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDRbMV07XG4gICAgICBmb3JtYXRzID0gX292ZXJsb2FkNFsyXTtcbiAgICAgIHNvdXJjZSA9IF9vdmVybG9hZDRbM107XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczUuZWRpdG9yLmZvcm1hdExpbmUoaW5kZXgsIGxlbmd0aCwgZm9ybWF0cyk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4LCAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0VGV4dChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSwgc291cmNlKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHMgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQ1ID0gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUsIHNvdXJjZSk7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQ2ID0gX3NsaWNlZFRvQXJyYXkoX292ZXJsb2FkNSwgNCk7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkNlswXTtcbiAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDZbMV07XG4gICAgICBmb3JtYXRzID0gX292ZXJsb2FkNlsyXTtcbiAgICAgIHNvdXJjZSA9IF9vdmVybG9hZDZbM107XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczYuZWRpdG9yLmZvcm1hdFRleHQoaW5kZXgsIGxlbmd0aCwgZm9ybWF0cyk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4LCAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRCb3VuZHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZHMoaW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICAgIHZhciBib3VuZHMgPSB2b2lkIDA7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICBib3VuZHMgPSB0aGlzLnNlbGVjdGlvbi5nZXRCb3VuZHMoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib3VuZHMgPSB0aGlzLnNlbGVjdGlvbi5nZXRCb3VuZHMoaW5kZXguaW5kZXgsIGluZGV4Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICB2YXIgY29udGFpbmVyQm91bmRzID0gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBib3R0b206IGJvdW5kcy5ib3R0b20gLSBjb250YWluZXJCb3VuZHMudG9wLFxuICAgICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0IC0gY29udGFpbmVyQm91bmRzLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBib3VuZHMucmlnaHQgLSBjb250YWluZXJCb3VuZHMubGVmdCxcbiAgICAgICAgdG9wOiBib3VuZHMudG9wIC0gY29udGFpbmVyQm91bmRzLnRvcCxcbiAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb250ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRlbnRzKCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5nZXRMZW5ndGgoKSAtIGluZGV4O1xuXG4gICAgICB2YXIgX292ZXJsb2FkNyA9IG92ZXJsb2FkKGluZGV4LCBsZW5ndGgpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkOCA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDcsIDIpO1xuXG4gICAgICBpbmRleCA9IF9vdmVybG9hZDhbMF07XG4gICAgICBsZW5ndGggPSBfb3ZlcmxvYWQ4WzFdO1xuXG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0Q29udGVudHMoaW5kZXgsIGxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Rm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0KCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmdldFNlbGVjdGlvbih0cnVlKTtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5nZXRGb3JtYXQoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0Rm9ybWF0KGluZGV4LmluZGV4LCBpbmRleC5sZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEluZGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXgoYmxvdCkge1xuICAgICAgcmV0dXJuIGJsb3Qub2Zmc2V0KHRoaXMuc2Nyb2xsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRMZW5ndGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZW5ndGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGwubGVuZ3RoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TGVhZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlYWYoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbC5sZWFmKGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRMaW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGluZShpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsLmxpbmUoaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldExpbmVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGluZXMoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGwubGluZXMoaW5kZXguaW5kZXgsIGluZGV4Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGwubGluZXMoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TW9kdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW9kdWxlKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW1lLm1vZHVsZXNbbmFtZV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0U2VsZWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgdmFyIGZvY3VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgaWYgKGZvY3VzKSB0aGlzLmZvY3VzKCk7XG4gICAgICB0aGlzLnVwZGF0ZSgpOyAvLyBNYWtlIHN1cmUgd2UgYWNjZXNzIGdldFJhbmdlIHdpdGggZWRpdG9yIGluIGNvbnNpc3RlbnQgc3RhdGVcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpWzBdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0KCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5nZXRMZW5ndGgoKSAtIGluZGV4O1xuXG4gICAgICB2YXIgX292ZXJsb2FkOSA9IG92ZXJsb2FkKGluZGV4LCBsZW5ndGgpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMTAgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQ5LCAyKTtcblxuICAgICAgaW5kZXggPSBfb3ZlcmxvYWQxMFswXTtcbiAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDEwWzFdO1xuXG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0VGV4dChpbmRleCwgbGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYXNGb2N1cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0ZvY3VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmhhc0ZvY3VzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0RW1iZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRFbWJlZChpbmRleCwgZW1iZWQsIHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogUXVpbGwuc291cmNlcy5BUEk7XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczcuZWRpdG9yLmluc2VydEVtYmVkKGluZGV4LCBlbWJlZCwgdmFsdWUpO1xuICAgICAgfSwgc291cmNlLCBpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0VGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFRleHQoaW5kZXgsIHRleHQsIG5hbWUsIHZhbHVlLCBzb3VyY2UpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB2YXIgZm9ybWF0cyA9IHZvaWQgMDtcblxuICAgICAgdmFyIF9vdmVybG9hZDExID0gb3ZlcmxvYWQoaW5kZXgsIDAsIG5hbWUsIHZhbHVlLCBzb3VyY2UpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMTIgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQxMSwgNCk7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkMTJbMF07XG4gICAgICBmb3JtYXRzID0gX292ZXJsb2FkMTJbMl07XG4gICAgICBzb3VyY2UgPSBfb3ZlcmxvYWQxMlszXTtcblxuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzOC5lZGl0b3IuaW5zZXJ0VGV4dChpbmRleCwgdGV4dCwgZm9ybWF0cyk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4LCB0ZXh0Lmxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNFbmFibGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWRpc2FibGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb2ZmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdHRlci5vZmYuYXBwbHkodGhpcy5lbWl0dGVyLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0dGVyLm9uLmFwcGx5KHRoaXMuZW1pdHRlciwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbmNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25jZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub25jZS5hcHBseSh0aGlzLmVtaXR0ZXIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGFzdGVIVE1MJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFzdGVIVE1MKGluZGV4LCBodG1sLCBzb3VyY2UpIHtcbiAgICAgIHRoaXMuY2xpcGJvYXJkLmRhbmdlcm91c2x5UGFzdGVIVE1MKGluZGV4LCBodG1sLCBzb3VyY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZUZvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUZvcm1hdChpbmRleCwgbGVuZ3RoLCBzb3VyY2UpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMTMgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoLCBzb3VyY2UpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMTQgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQxMywgNCk7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkMTRbMF07XG4gICAgICBsZW5ndGggPSBfb3ZlcmxvYWQxNFsxXTtcbiAgICAgIHNvdXJjZSA9IF9vdmVybG9hZDE0WzNdO1xuXG4gICAgICByZXR1cm4gbW9kaWZ5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM5LmVkaXRvci5yZW1vdmVGb3JtYXQoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzY3JvbGxJbnRvVmlldycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcodGhpcy5zY3JvbGxpbmdDb250YWluZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldENvbnRlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29udGVudHMoZGVsdGEpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5BUEk7XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KGRlbHRhKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IF90aGlzMTAuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIHZhciBkZWxldGVkID0gX3RoaXMxMC5lZGl0b3IuZGVsZXRlVGV4dCgwLCBsZW5ndGgpO1xuICAgICAgICB2YXIgYXBwbGllZCA9IF90aGlzMTAuZWRpdG9yLmFwcGx5RGVsdGEoZGVsdGEpO1xuICAgICAgICB2YXIgbGFzdE9wID0gYXBwbGllZC5vcHNbYXBwbGllZC5vcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0T3AgIT0gbnVsbCAmJiB0eXBlb2YgbGFzdE9wLmluc2VydCA9PT0gJ3N0cmluZycgJiYgbGFzdE9wLmluc2VydFtsYXN0T3AuaW5zZXJ0Lmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgICAgICAgIF90aGlzMTAuZWRpdG9yLmRlbGV0ZVRleHQoX3RoaXMxMC5nZXRMZW5ndGgoKSAtIDEsIDEpO1xuICAgICAgICAgIGFwcGxpZWQuZGVsZXRlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXQgPSBkZWxldGVkLmNvbXBvc2UoYXBwbGllZCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LCBzb3VyY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFNlbGVjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbmRleCwgbGVuZ3RoLCBzb3VyY2UpIHtcbiAgICAgIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFJhbmdlKG51bGwsIGxlbmd0aCB8fCBRdWlsbC5zb3VyY2VzLkFQSSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX292ZXJsb2FkMTUgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoLCBzb3VyY2UpO1xuXG4gICAgICAgIHZhciBfb3ZlcmxvYWQxNiA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDE1LCA0KTtcblxuICAgICAgICBpbmRleCA9IF9vdmVybG9hZDE2WzBdO1xuICAgICAgICBsZW5ndGggPSBfb3ZlcmxvYWQxNlsxXTtcbiAgICAgICAgc291cmNlID0gX292ZXJsb2FkMTZbM107XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0UmFuZ2UobmV3IF9zZWxlY3Rpb24uUmFuZ2UoaW5kZXgsIGxlbmd0aCksIHNvdXJjZSk7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcodGhpcy5zY3JvbGxpbmdDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRleHQodGV4dCkge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5BUEk7XG5cbiAgICAgIHZhciBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLmluc2VydCh0ZXh0KTtcbiAgICAgIHJldHVybiB0aGlzLnNldENvbnRlbnRzKGRlbHRhLCBzb3VyY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuVVNFUjtcblxuICAgICAgdmFyIGNoYW5nZSA9IHRoaXMuc2Nyb2xsLnVwZGF0ZShzb3VyY2UpOyAvLyBXaWxsIHVwZGF0ZSBzZWxlY3Rpb24gYmVmb3JlIHNlbGVjdGlvbi51cGRhdGUoKSBkb2VzIGlmIHRleHQgY2hhbmdlc1xuICAgICAgdGhpcy5zZWxlY3Rpb24udXBkYXRlKHNvdXJjZSk7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUNvbnRlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ29udGVudHMoZGVsdGEpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5BUEk7XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KGRlbHRhKTtcbiAgICAgICAgcmV0dXJuIF90aGlzMTEuZWRpdG9yLmFwcGx5RGVsdGEoZGVsdGEsIHNvdXJjZSk7XG4gICAgICB9LCBzb3VyY2UsIHRydWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdWlsbDtcbn0oKTtcblxuUXVpbGwuREVGQVVMVFMgPSB7XG4gIGJvdW5kczogbnVsbCxcbiAgZm9ybWF0czogbnVsbCxcbiAgbW9kdWxlczoge30sXG4gIHBsYWNlaG9sZGVyOiAnJyxcbiAgcmVhZE9ubHk6IGZhbHNlLFxuICBzY3JvbGxpbmdDb250YWluZXI6IG51bGwsXG4gIHN0cmljdDogdHJ1ZSxcbiAgdGhlbWU6ICdkZWZhdWx0J1xufTtcblF1aWxsLmV2ZW50cyA9IF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cztcblF1aWxsLnNvdXJjZXMgPSBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5RdWlsbC52ZXJzaW9uID0gIGZhbHNlID8gJ2RldicgOiBcIjEuMy43XCI7XG5cblF1aWxsLmltcG9ydHMgPSB7XG4gICdkZWx0YSc6IF9xdWlsbERlbHRhMi5kZWZhdWx0LFxuICAncGFyY2htZW50JzogX3BhcmNobWVudDIuZGVmYXVsdCxcbiAgJ2NvcmUvbW9kdWxlJzogX21vZHVsZTIuZGVmYXVsdCxcbiAgJ2NvcmUvdGhlbWUnOiBfdGhlbWUyLmRlZmF1bHRcbn07XG5cbmZ1bmN0aW9uIGV4cGFuZENvbmZpZyhjb250YWluZXIsIHVzZXJDb25maWcpIHtcbiAgdXNlckNvbmZpZyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KSh0cnVlLCB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgbW9kdWxlczoge1xuICAgICAgY2xpcGJvYXJkOiB0cnVlLFxuICAgICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgICBoaXN0b3J5OiB0cnVlXG4gICAgfVxuICB9LCB1c2VyQ29uZmlnKTtcbiAgaWYgKCF1c2VyQ29uZmlnLnRoZW1lIHx8IHVzZXJDb25maWcudGhlbWUgPT09IFF1aWxsLkRFRkFVTFRTLnRoZW1lKSB7XG4gICAgdXNlckNvbmZpZy50aGVtZSA9IF90aGVtZTIuZGVmYXVsdDtcbiAgfSBlbHNlIHtcbiAgICB1c2VyQ29uZmlnLnRoZW1lID0gUXVpbGwuaW1wb3J0KCd0aGVtZXMvJyArIHVzZXJDb25maWcudGhlbWUpO1xuICAgIGlmICh1c2VyQ29uZmlnLnRoZW1lID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0aGVtZSAnICsgdXNlckNvbmZpZy50aGVtZSArICcuIERpZCB5b3UgcmVnaXN0ZXIgaXQ/Jyk7XG4gICAgfVxuICB9XG4gIHZhciB0aGVtZUNvbmZpZyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KSh0cnVlLCB7fSwgdXNlckNvbmZpZy50aGVtZS5ERUZBVUxUUyk7XG4gIFt0aGVtZUNvbmZpZywgdXNlckNvbmZpZ10uZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgY29uZmlnLm1vZHVsZXMgPSBjb25maWcubW9kdWxlcyB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhjb25maWcubW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICBpZiAoY29uZmlnLm1vZHVsZXNbbW9kdWxlXSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25maWcubW9kdWxlc1ttb2R1bGVdID0ge307XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgbW9kdWxlTmFtZXMgPSBPYmplY3Qua2V5cyh0aGVtZUNvbmZpZy5tb2R1bGVzKS5jb25jYXQoT2JqZWN0LmtleXModXNlckNvbmZpZy5tb2R1bGVzKSk7XG4gIHZhciBtb2R1bGVDb25maWcgPSBtb2R1bGVOYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKGNvbmZpZywgbmFtZSkge1xuICAgIHZhciBtb2R1bGVDbGFzcyA9IFF1aWxsLmltcG9ydCgnbW9kdWxlcy8nICsgbmFtZSk7XG4gICAgaWYgKG1vZHVsZUNsYXNzID09IG51bGwpIHtcbiAgICAgIGRlYnVnLmVycm9yKCdDYW5ub3QgbG9hZCAnICsgbmFtZSArICcgbW9kdWxlLiBBcmUgeW91IHN1cmUgeW91IHJlZ2lzdGVyZWQgaXQ/Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZ1tuYW1lXSA9IG1vZHVsZUNsYXNzLkRFRkFVTFRTIHx8IHt9O1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xuICB9LCB7fSk7XG4gIC8vIFNwZWNpYWwgY2FzZSB0b29sYmFyIHNob3J0aGFuZFxuICBpZiAodXNlckNvbmZpZy5tb2R1bGVzICE9IG51bGwgJiYgdXNlckNvbmZpZy5tb2R1bGVzLnRvb2xiYXIgJiYgdXNlckNvbmZpZy5tb2R1bGVzLnRvb2xiYXIuY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICAgIHVzZXJDb25maWcubW9kdWxlcy50b29sYmFyID0ge1xuICAgICAgY29udGFpbmVyOiB1c2VyQ29uZmlnLm1vZHVsZXMudG9vbGJhclxuICAgIH07XG4gIH1cbiAgdXNlckNvbmZpZyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KSh0cnVlLCB7fSwgUXVpbGwuREVGQVVMVFMsIHsgbW9kdWxlczogbW9kdWxlQ29uZmlnIH0sIHRoZW1lQ29uZmlnLCB1c2VyQ29uZmlnKTtcbiAgWydib3VuZHMnLCAnY29udGFpbmVyJywgJ3Njcm9sbGluZ0NvbnRhaW5lciddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICh0eXBlb2YgdXNlckNvbmZpZ1trZXldID09PSAnc3RyaW5nJykge1xuICAgICAgdXNlckNvbmZpZ1trZXldID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih1c2VyQ29uZmlnW2tleV0pO1xuICAgIH1cbiAgfSk7XG4gIHVzZXJDb25maWcubW9kdWxlcyA9IE9iamVjdC5rZXlzKHVzZXJDb25maWcubW9kdWxlcykucmVkdWNlKGZ1bmN0aW9uIChjb25maWcsIG5hbWUpIHtcbiAgICBpZiAodXNlckNvbmZpZy5tb2R1bGVzW25hbWVdKSB7XG4gICAgICBjb25maWdbbmFtZV0gPSB1c2VyQ29uZmlnLm1vZHVsZXNbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIHVzZXJDb25maWc7XG59XG5cbi8vIEhhbmRsZSBzZWxlY3Rpb24gcHJlc2VydmF0aW9uIGFuZCBURVhUX0NIQU5HRSBlbWlzc2lvblxuLy8gY29tbW9uIHRvIG1vZGlmaWNhdGlvbiBBUElzXG5mdW5jdGlvbiBtb2RpZnkobW9kaWZpZXIsIHNvdXJjZSwgaW5kZXgsIHNoaWZ0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuc3RyaWN0ICYmICF0aGlzLmlzRW5hYmxlZCgpICYmIHNvdXJjZSA9PT0gX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5VU0VSKSB7XG4gICAgcmV0dXJuIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpO1xuICB9XG4gIHZhciByYW5nZSA9IGluZGV4ID09IG51bGwgPyBudWxsIDogdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIG9sZERlbHRhID0gdGhpcy5lZGl0b3IuZGVsdGE7XG4gIHZhciBjaGFuZ2UgPSBtb2RpZmllcigpO1xuICBpZiAocmFuZ2UgIT0gbnVsbCkge1xuICAgIGlmIChpbmRleCA9PT0gdHJ1ZSkgaW5kZXggPSByYW5nZS5pbmRleDtcbiAgICBpZiAoc2hpZnQgPT0gbnVsbCkge1xuICAgICAgcmFuZ2UgPSBzaGlmdFJhbmdlKHJhbmdlLCBjaGFuZ2UsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgcmFuZ2UgPSBzaGlmdFJhbmdlKHJhbmdlLCBpbmRleCwgc2hpZnQsIHNvdXJjZSk7XG4gICAgfVxuICAgIHRoaXMuc2V0U2VsZWN0aW9uKHJhbmdlLCBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gIH1cbiAgaWYgKGNoYW5nZS5sZW5ndGgoKSA+IDApIHtcbiAgICB2YXIgX2VtaXR0ZXI7XG5cbiAgICB2YXIgYXJncyA9IFtfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuVEVYVF9DSEFOR0UsIGNoYW5nZSwgb2xkRGVsdGEsIHNvdXJjZV07XG4gICAgKF9lbWl0dGVyID0gdGhpcy5lbWl0dGVyKS5lbWl0LmFwcGx5KF9lbWl0dGVyLCBbX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLkVESVRPUl9DSEFOR0VdLmNvbmNhdChhcmdzKSk7XG4gICAgaWYgKHNvdXJjZSAhPT0gX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5TSUxFTlQpIHtcbiAgICAgIHZhciBfZW1pdHRlcjI7XG5cbiAgICAgIChfZW1pdHRlcjIgPSB0aGlzLmVtaXR0ZXIpLmVtaXQuYXBwbHkoX2VtaXR0ZXIyLCBhcmdzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5nZTtcbn1cblxuZnVuY3Rpb24gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUsIHNvdXJjZSkge1xuICB2YXIgZm9ybWF0cyA9IHt9O1xuICBpZiAodHlwZW9mIGluZGV4LmluZGV4ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgaW5kZXgubGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIEFsbG93IGZvciB0aHJvd2F3YXkgZW5kICh1c2VkIGJ5IGluc2VydFRleHQvaW5zZXJ0RW1iZWQpXG4gICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgICBzb3VyY2UgPSB2YWx1ZSwgdmFsdWUgPSBuYW1lLCBuYW1lID0gbGVuZ3RoLCBsZW5ndGggPSBpbmRleC5sZW5ndGgsIGluZGV4ID0gaW5kZXguaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IGluZGV4Lmxlbmd0aCwgaW5kZXggPSBpbmRleC5pbmRleDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICBzb3VyY2UgPSB2YWx1ZSwgdmFsdWUgPSBuYW1lLCBuYW1lID0gbGVuZ3RoLCBsZW5ndGggPSAwO1xuICB9XG4gIC8vIEhhbmRsZSBmb3JtYXQgYmVpbmcgb2JqZWN0LCB0d28gZm9ybWF0IG5hbWUvdmFsdWUgc3RyaW5ncyBvciBleGNsdWRlZFxuICBpZiAoKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgZm9ybWF0cyA9IG5hbWU7XG4gICAgc291cmNlID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGZvcm1hdHNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlID0gbmFtZTtcbiAgICB9XG4gIH1cbiAgLy8gSGFuZGxlIG9wdGlvbmFsIHNvdXJjZVxuICBzb3VyY2UgPSBzb3VyY2UgfHwgX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5BUEk7XG4gIHJldHVybiBbaW5kZXgsIGxlbmd0aCwgZm9ybWF0cywgc291cmNlXTtcbn1cblxuZnVuY3Rpb24gc2hpZnRSYW5nZShyYW5nZSwgaW5kZXgsIGxlbmd0aCwgc291cmNlKSB7XG4gIGlmIChyYW5nZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgdmFyIHN0YXJ0ID0gdm9pZCAwLFxuICAgICAgZW5kID0gdm9pZCAwO1xuICBpZiAoaW5kZXggaW5zdGFuY2VvZiBfcXVpbGxEZWx0YTIuZGVmYXVsdCkge1xuICAgIHZhciBfbWFwID0gW3JhbmdlLmluZGV4LCByYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aF0ubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBpbmRleC50cmFuc2Zvcm1Qb3NpdGlvbihwb3MsIHNvdXJjZSAhPT0gX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICB9KTtcblxuICAgIHZhciBfbWFwMiA9IF9zbGljZWRUb0FycmF5KF9tYXAsIDIpO1xuXG4gICAgc3RhcnQgPSBfbWFwMlswXTtcbiAgICBlbmQgPSBfbWFwMlsxXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX21hcDMgPSBbcmFuZ2UuaW5kZXgsIHJhbmdlLmluZGV4ICsgcmFuZ2UubGVuZ3RoXS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgaWYgKHBvcyA8IGluZGV4IHx8IHBvcyA9PT0gaW5kZXggJiYgc291cmNlID09PSBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlVTRVIpIHJldHVybiBwb3M7XG4gICAgICBpZiAobGVuZ3RoID49IDApIHtcbiAgICAgICAgcmV0dXJuIHBvcyArIGxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChpbmRleCwgcG9zICsgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBfbWFwNCA9IF9zbGljZWRUb0FycmF5KF9tYXAzLCAyKTtcblxuICAgIHN0YXJ0ID0gX21hcDRbMF07XG4gICAgZW5kID0gX21hcDRbMV07XG4gIH1cbiAgcmV0dXJuIG5ldyBfc2VsZWN0aW9uLlJhbmdlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG59XG5cbmV4cG9ydHMuZXhwYW5kQ29uZmlnID0gZXhwYW5kQ29uZmlnO1xuZXhwb3J0cy5vdmVybG9hZCA9IG92ZXJsb2FkO1xuZXhwb3J0cy5kZWZhdWx0ID0gUXVpbGw7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0KTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBJbmxpbmUgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRJbmxpbmUpIHtcbiAgX2luaGVyaXRzKElubGluZSwgX1BhcmNobWVudCRJbmxpbmUpO1xuXG4gIGZ1bmN0aW9uIElubGluZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5saW5lKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSW5saW5lLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSW5saW5lKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW5saW5lLCBbe1xuICAgIGtleTogJ2Zvcm1hdEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChJbmxpbmUuY29tcGFyZSh0aGlzLnN0YXRpY3MuYmxvdE5hbWUsIG5hbWUpIDwgMCAmJiBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KG5hbWUsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPVCkpIHtcbiAgICAgICAgdmFyIGJsb3QgPSB0aGlzLmlzb2xhdGUoaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGJsb3Qud3JhcChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoSW5saW5lLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKElubGluZS5wcm90b3R5cGUpLCAnZm9ybWF0QXQnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvcHRpbWl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKGNvbnRleHQpIHtcbiAgICAgIF9nZXQoSW5saW5lLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKElubGluZS5wcm90b3R5cGUpLCAnb3B0aW1pemUnLCB0aGlzKS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgSW5saW5lICYmIElubGluZS5jb21wYXJlKHRoaXMuc3RhdGljcy5ibG90TmFtZSwgdGhpcy5wYXJlbnQuc3RhdGljcy5ibG90TmFtZSkgPiAwKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudC5pc29sYXRlKHRoaXMub2Zmc2V0KCksIHRoaXMubGVuZ3RoKCkpO1xuICAgICAgICB0aGlzLm1vdmVDaGlsZHJlbihwYXJlbnQpO1xuICAgICAgICBwYXJlbnQud3JhcCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2NvbXBhcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlKHNlbGYsIG90aGVyKSB7XG4gICAgICB2YXIgc2VsZkluZGV4ID0gSW5saW5lLm9yZGVyLmluZGV4T2Yoc2VsZik7XG4gICAgICB2YXIgb3RoZXJJbmRleCA9IElubGluZS5vcmRlci5pbmRleE9mKG90aGVyKTtcbiAgICAgIGlmIChzZWxmSW5kZXggPj0gMCB8fCBvdGhlckluZGV4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGZJbmRleCAtIG90aGVySW5kZXg7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIGlmIChzZWxmIDwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIElubGluZTtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5JbmxpbmUpO1xuXG5JbmxpbmUuYWxsb3dlZENoaWxkcmVuID0gW0lubGluZSwgX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCwgX3RleHQyLmRlZmF1bHRdO1xuLy8gTG93ZXIgaW5kZXggbWVhbnMgZGVlcGVyIGluIHRoZSBET00gdHJlZSwgc2luY2Ugbm90IGZvdW5kICgtMSkgaXMgZm9yIGVtYmVkc1xuSW5saW5lLm9yZGVyID0gWydjdXJzb3InLCAnaW5saW5lJywgLy8gTXVzdCBiZSBsb3dlclxuJ3VuZGVybGluZScsICdzdHJpa2UnLCAnaXRhbGljJywgJ2JvbGQnLCAnc2NyaXB0JywgJ2xpbmsnLCAnY29kZScgLy8gTXVzdCBiZSBoaWdoZXJcbl07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IElubGluZTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVGV4dEJsb3QgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRUZXh0KSB7XG4gIF9pbmhlcml0cyhUZXh0QmxvdCwgX1BhcmNobWVudCRUZXh0KTtcblxuICBmdW5jdGlvbiBUZXh0QmxvdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dEJsb3QpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUZXh0QmxvdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRleHRCbG90KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gVGV4dEJsb3Q7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuVGV4dCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRleHRCbG90O1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2V2ZW50ZW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xuXG52YXIgX2V2ZW50ZW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudGVtaXR0ZXIpO1xuXG52YXIgX2xvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBkZWJ1ZyA9ICgwLCBfbG9nZ2VyMi5kZWZhdWx0KSgncXVpbGw6ZXZlbnRzJyk7XG5cbnZhciBFVkVOVFMgPSBbJ3NlbGVjdGlvbmNoYW5nZScsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdjbGljayddO1xuXG5FVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucWwtY29udGFpbmVyJykpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIC8vIFRPRE8gdXNlIFdlYWtNYXBcbiAgICAgIGlmIChub2RlLl9fcXVpbGwgJiYgbm9kZS5fX3F1aWxsLmVtaXR0ZXIpIHtcbiAgICAgICAgdmFyIF9ub2RlJF9fcXVpbGwkZW1pdHRlcjtcblxuICAgICAgICAoX25vZGUkX19xdWlsbCRlbWl0dGVyID0gbm9kZS5fX3F1aWxsLmVtaXR0ZXIpLmhhbmRsZURPTS5hcHBseShfbm9kZSRfX3F1aWxsJGVtaXR0ZXIsIGFyZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG52YXIgRW1pdHRlciA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhFbWl0dGVyLCBfRXZlbnRFbWl0dGVyKTtcblxuICBmdW5jdGlvbiBFbWl0dGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChFbWl0dGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRW1pdHRlcikpLmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMubGlzdGVuZXJzID0ge307XG4gICAgX3RoaXMub24oJ2Vycm9yJywgZGVidWcuZXJyb3IpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFbWl0dGVyLCBbe1xuICAgIGtleTogJ2VtaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KCkge1xuICAgICAgZGVidWcubG9nLmFwcGx5KGRlYnVnLCBhcmd1bWVudHMpO1xuICAgICAgX2dldChFbWl0dGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEVtaXR0ZXIucHJvdG90eXBlKSwgJ2VtaXQnLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZURPTScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZURPTShldmVudCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICAodGhpcy5saXN0ZW5lcnNbZXZlbnQudHlwZV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfcmVmLm5vZGUsXG4gICAgICAgICAgICBoYW5kbGVyID0gX3JlZi5oYW5kbGVyO1xuXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IG5vZGUgfHwgbm9kZS5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgaGFuZGxlci5hcHBseSh1bmRlZmluZWQsIFtldmVudF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGlzdGVuRE9NJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuRE9NKGV2ZW50TmFtZSwgbm9kZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0ucHVzaCh7IG5vZGU6IG5vZGUsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVtaXR0ZXI7XG59KF9ldmVudGVtaXR0ZXIyLmRlZmF1bHQpO1xuXG5FbWl0dGVyLmV2ZW50cyA9IHtcbiAgRURJVE9SX0NIQU5HRTogJ2VkaXRvci1jaGFuZ2UnLFxuICBTQ1JPTExfQkVGT1JFX1VQREFURTogJ3Njcm9sbC1iZWZvcmUtdXBkYXRlJyxcbiAgU0NST0xMX09QVElNSVpFOiAnc2Nyb2xsLW9wdGltaXplJyxcbiAgU0NST0xMX1VQREFURTogJ3Njcm9sbC11cGRhdGUnLFxuICBTRUxFQ1RJT05fQ0hBTkdFOiAnc2VsZWN0aW9uLWNoYW5nZScsXG4gIFRFWFRfQ0hBTkdFOiAndGV4dC1jaGFuZ2UnXG59O1xuRW1pdHRlci5zb3VyY2VzID0ge1xuICBBUEk6ICdhcGknLFxuICBTSUxFTlQ6ICdzaWxlbnQnLFxuICBVU0VSOiAndXNlcidcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEVtaXR0ZXI7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgTW9kdWxlID0gZnVuY3Rpb24gTW9kdWxlKHF1aWxsKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kdWxlKTtcblxuICB0aGlzLnF1aWxsID0gcXVpbGw7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG59O1xuXG5Nb2R1bGUuREVGQVVMVFMgPSB7fTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTW9kdWxlO1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgbGV2ZWxzID0gWydlcnJvcicsICd3YXJuJywgJ2xvZycsICdpbmZvJ107XG52YXIgbGV2ZWwgPSAnd2Fybic7XG5cbmZ1bmN0aW9uIGRlYnVnKG1ldGhvZCkge1xuICBpZiAobGV2ZWxzLmluZGV4T2YobWV0aG9kKSA8PSBsZXZlbHMuaW5kZXhPZihsZXZlbCkpIHtcbiAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIChfY29uc29sZSA9IGNvbnNvbGUpW21ldGhvZF0uYXBwbHkoX2NvbnNvbGUsIGFyZ3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgfVxufVxuXG5mdW5jdGlvbiBuYW1lc3BhY2UobnMpIHtcbiAgcmV0dXJuIGxldmVscy5yZWR1Y2UoZnVuY3Rpb24gKGxvZ2dlciwgbWV0aG9kKSB7XG4gICAgbG9nZ2VyW21ldGhvZF0gPSBkZWJ1Zy5iaW5kKGNvbnNvbGUsIG1ldGhvZCwgbnMpO1xuICAgIHJldHVybiBsb2dnZXI7XG4gIH0sIHt9KTtcbn1cblxuZGVidWcubGV2ZWwgPSBuYW1lc3BhY2UubGV2ZWwgPSBmdW5jdGlvbiAobmV3TGV2ZWwpIHtcbiAgbGV2ZWwgPSBuZXdMZXZlbDtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5hbWVzcGFjZTtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcbnZhciBpc0FyZ3VtZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xuXG52YXIgZGVlcEVxdWFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkIHx8IHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9wdHMuc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgb3B0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyICh4KSB7XG4gIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHgubGVuZ3RoICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHguY29weSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeC5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoeC5sZW5ndGggPiAwICYmIHR5cGVvZiB4WzBdICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgb3B0cykge1xuICB2YXIgaSwga2V5O1xuICBpZiAoaXNVbmRlZmluZWRPck51bGwoYSkgfHwgaXNVbmRlZmluZWRPck51bGwoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIG9wdHMpO1xuICB9XG4gIGlmIChpc0J1ZmZlcihhKSkge1xuICAgIGlmICghaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICAgIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBvcHRzKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGI7XG59XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBBdHRyaWJ1dG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0b3IoYXR0ck5hbWUsIGtleU5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5hdHRyTmFtZSA9IGF0dHJOYW1lO1xuICAgICAgICB0aGlzLmtleU5hbWUgPSBrZXlOYW1lO1xuICAgICAgICB2YXIgYXR0cmlidXRlQml0ID0gUmVnaXN0cnkuU2NvcGUuVFlQRSAmIFJlZ2lzdHJ5LlNjb3BlLkFUVFJJQlVURTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NvcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWdub3JlIHR5cGUgYml0cywgZm9yY2UgYXR0cmlidXRlIGJpdFxuICAgICAgICAgICAgdGhpcy5zY29wZSA9IChvcHRpb25zLnNjb3BlICYgUmVnaXN0cnkuU2NvcGUuTEVWRUwpIHwgYXR0cmlidXRlQml0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY29wZSA9IFJlZ2lzdHJ5LlNjb3BlLkFUVFJJQlVURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy53aGl0ZWxpc3QgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMud2hpdGVsaXN0ID0gb3B0aW9ucy53aGl0ZWxpc3Q7XG4gICAgfVxuICAgIEF0dHJpYnV0b3Iua2V5cyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBbXS5tYXAuY2FsbChub2RlLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF0dHJpYnV0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUodGhpcy5rZXlOYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQXR0cmlidXRvci5wcm90b3R5cGUuY2FuQWRkID0gZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IFJlZ2lzdHJ5LnF1ZXJ5KG5vZGUsIFJlZ2lzdHJ5LlNjb3BlLkJMT1QgJiAodGhpcy5zY29wZSB8IFJlZ2lzdHJ5LlNjb3BlLlRZUEUpKTtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLndoaXRlbGlzdCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aGl0ZWxpc3QuaW5kZXhPZih2YWx1ZS5yZXBsYWNlKC9bXCInXS9nLCAnJykpID4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aGl0ZWxpc3QuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXR0cmlidXRvci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUodGhpcy5rZXlOYW1lKTtcbiAgICB9O1xuICAgIEF0dHJpYnV0b3IucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUodGhpcy5rZXlOYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIHJldHVybiBBdHRyaWJ1dG9yO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF0dHJpYnV0b3I7XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5Db2RlID0gdW5kZWZpbmVkO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9xdWlsbERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9xdWlsbERlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsRGVsdGEpO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxudmFyIF9pbmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX2lubGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmxpbmUpO1xuXG52YXIgX3RleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3RleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENvZGUgPSBmdW5jdGlvbiAoX0lubGluZSkge1xuICBfaW5oZXJpdHMoQ29kZSwgX0lubGluZSk7XG5cbiAgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29kZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvZGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2RlKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gQ29kZTtcbn0oX2lubGluZTIuZGVmYXVsdCk7XG5cbkNvZGUuYmxvdE5hbWUgPSAnY29kZSc7XG5Db2RlLnRhZ05hbWUgPSAnQ09ERSc7XG5cbnZhciBDb2RlQmxvY2sgPSBmdW5jdGlvbiAoX0Jsb2NrKSB7XG4gIF9pbmhlcml0cyhDb2RlQmxvY2ssIF9CbG9jayk7XG5cbiAgZnVuY3Rpb24gQ29kZUJsb2NrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2RlQmxvY2spO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2RlQmxvY2suX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2RlQmxvY2spKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2RlQmxvY2ssIFt7XG4gICAga2V5OiAnZGVsdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWx0YSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgdGV4dCA9IHRoaXMuZG9tTm9kZS50ZXh0Q29udGVudDtcbiAgICAgIGlmICh0ZXh0LmVuZHNXaXRoKCdcXG4nKSkge1xuICAgICAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHRydWVcbiAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHQuc3BsaXQoJ1xcbicpLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIGZyYWcpIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhLmluc2VydChmcmFnKS5pbnNlcnQoJ1xcbicsIF90aGlzMy5mb3JtYXRzKCkpO1xuICAgICAgfSwgbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKG5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSAmJiB2YWx1ZSkgcmV0dXJuO1xuXG4gICAgICB2YXIgX2Rlc2NlbmRhbnQgPSB0aGlzLmRlc2NlbmRhbnQoX3RleHQyLmRlZmF1bHQsIHRoaXMubGVuZ3RoKCkgLSAxKSxcbiAgICAgICAgICBfZGVzY2VuZGFudDIgPSBfc2xpY2VkVG9BcnJheShfZGVzY2VuZGFudCwgMSksXG4gICAgICAgICAgdGV4dCA9IF9kZXNjZW5kYW50MlswXTtcblxuICAgICAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgICAgICB0ZXh0LmRlbGV0ZUF0KHRleHQubGVuZ3RoKCkgLSAxLCAxKTtcbiAgICAgIH1cbiAgICAgIF9nZXQoQ29kZUJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvZGVCbG9jay5wcm90b3R5cGUpLCAnZm9ybWF0JywgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0QXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgaWYgKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobmFtZSwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSykgPT0gbnVsbCB8fCBuYW1lID09PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgJiYgdmFsdWUgPT09IHRoaXMuc3RhdGljcy5mb3JtYXRzKHRoaXMuZG9tTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5leHROZXdsaW5lID0gdGhpcy5uZXdsaW5lSW5kZXgoaW5kZXgpO1xuICAgICAgaWYgKG5leHROZXdsaW5lIDwgMCB8fCBuZXh0TmV3bGluZSA+PSBpbmRleCArIGxlbmd0aCkgcmV0dXJuO1xuICAgICAgdmFyIHByZXZOZXdsaW5lID0gdGhpcy5uZXdsaW5lSW5kZXgoaW5kZXgsIHRydWUpICsgMTtcbiAgICAgIHZhciBpc29sYXRlTGVuZ3RoID0gbmV4dE5ld2xpbmUgLSBwcmV2TmV3bGluZSArIDE7XG4gICAgICB2YXIgYmxvdCA9IHRoaXMuaXNvbGF0ZShwcmV2TmV3bGluZSwgaXNvbGF0ZUxlbmd0aCk7XG4gICAgICB2YXIgbmV4dCA9IGJsb3QubmV4dDtcbiAgICAgIGJsb3QuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgQ29kZUJsb2NrKSB7XG4gICAgICAgIG5leHQuZm9ybWF0QXQoMCwgaW5kZXggLSBwcmV2TmV3bGluZSArIGxlbmd0aCAtIGlzb2xhdGVMZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICBpZiAoZGVmICE9IG51bGwpIHJldHVybjtcblxuICAgICAgdmFyIF9kZXNjZW5kYW50MyA9IHRoaXMuZGVzY2VuZGFudChfdGV4dDIuZGVmYXVsdCwgaW5kZXgpLFxuICAgICAgICAgIF9kZXNjZW5kYW50NCA9IF9zbGljZWRUb0FycmF5KF9kZXNjZW5kYW50MywgMiksXG4gICAgICAgICAgdGV4dCA9IF9kZXNjZW5kYW50NFswXSxcbiAgICAgICAgICBvZmZzZXQgPSBfZGVzY2VuZGFudDRbMV07XG5cbiAgICAgIHRleHQuaW5zZXJ0QXQob2Zmc2V0LCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGVuZ3RoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICBpZiAoIXRoaXMuZG9tTm9kZS50ZXh0Q29udGVudC5lbmRzV2l0aCgnXFxuJykpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25ld2xpbmVJbmRleCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld2xpbmVJbmRleChzZWFyY2hJbmRleCkge1xuICAgICAgdmFyIHJldmVyc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoIXJldmVyc2UpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuZG9tTm9kZS50ZXh0Q29udGVudC5zbGljZShzZWFyY2hJbmRleCkuaW5kZXhPZignXFxuJyk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPiAtMSA/IHNlYXJjaEluZGV4ICsgb2Zmc2V0IDogLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5kb21Ob2RlLnRleHRDb250ZW50LnNsaWNlKDAsIHNlYXJjaEluZGV4KS5sYXN0SW5kZXhPZignXFxuJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb3B0aW1pemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZShjb250ZXh0KSB7XG4gICAgICBpZiAoIXRoaXMuZG9tTm9kZS50ZXh0Q29udGVudC5lbmRzV2l0aCgnXFxuJykpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSgndGV4dCcsICdcXG4nKSk7XG4gICAgICB9XG4gICAgICBfZ2V0KENvZGVCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2RlQmxvY2sucHJvdG90eXBlKSwgJ29wdGltaXplJywgdGhpcykuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgaWYgKG5leHQgIT0gbnVsbCAmJiBuZXh0LnByZXYgPT09IHRoaXMgJiYgbmV4dC5zdGF0aWNzLmJsb3ROYW1lID09PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgJiYgdGhpcy5zdGF0aWNzLmZvcm1hdHModGhpcy5kb21Ob2RlKSA9PT0gbmV4dC5zdGF0aWNzLmZvcm1hdHMobmV4dC5kb21Ob2RlKSkge1xuICAgICAgICBuZXh0Lm9wdGltaXplKGNvbnRleHQpO1xuICAgICAgICBuZXh0Lm1vdmVDaGlsZHJlbih0aGlzKTtcbiAgICAgICAgbmV4dC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXBsYWNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZSh0YXJnZXQpIHtcbiAgICAgIF9nZXQoQ29kZUJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvZGVCbG9jay5wcm90b3R5cGUpLCAncmVwbGFjZScsIHRoaXMpLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICAgIFtdLnNsaWNlLmNhbGwodGhpcy5kb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgYmxvdCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuZmluZChub2RlKTtcbiAgICAgICAgaWYgKGJsb3QgPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChibG90IGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCkge1xuICAgICAgICAgIGJsb3QucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmxvdC51bndyYXAoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIHZhciBkb21Ob2RlID0gX2dldChDb2RlQmxvY2suX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2RlQmxvY2spLCAnY3JlYXRlJywgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICBkb21Ob2RlLnNldEF0dHJpYnV0ZSgnc3BlbGxjaGVjaycsIGZhbHNlKTtcbiAgICAgIHJldHVybiBkb21Ob2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvZGVCbG9jaztcbn0oX2Jsb2NrMi5kZWZhdWx0KTtcblxuQ29kZUJsb2NrLmJsb3ROYW1lID0gJ2NvZGUtYmxvY2snO1xuQ29kZUJsb2NrLnRhZ05hbWUgPSAnUFJFJztcbkNvZGVCbG9jay5UQUIgPSAnICAnO1xuXG5leHBvcnRzLkNvZGUgPSBDb2RlO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29kZUJsb2NrO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3F1aWxsRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3F1aWxsRGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGxEZWx0YSk7XG5cbnZhciBfb3AgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxudmFyIF9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vcCk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9jb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBfY29kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2RlKTtcblxudmFyIF9jdXJzb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxudmFyIF9jdXJzb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3Vyc29yKTtcblxudmFyIF9ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfYmxvY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2spO1xuXG52YXIgX2JyZWFrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfYnJlYWsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJlYWspO1xuXG52YXIgX2Nsb25lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbnZhciBfY2xvbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvbmUpO1xuXG52YXIgX2RlZXBFcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX2V4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZXh0ZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBU0NJSSA9IC9eWyAtfl0qJC87XG5cbnZhciBFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVkaXRvcihzY3JvbGwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRpdG9yKTtcblxuICAgIHRoaXMuc2Nyb2xsID0gc2Nyb2xsO1xuICAgIHRoaXMuZGVsdGEgPSB0aGlzLmdldERlbHRhKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRWRpdG9yLCBbe1xuICAgIGtleTogJ2FwcGx5RGVsdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseURlbHRhKGRlbHRhKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgY29uc3VtZU5leHROZXdsaW5lID0gZmFsc2U7XG4gICAgICB0aGlzLnNjcm9sbC51cGRhdGUoKTtcbiAgICAgIHZhciBzY3JvbGxMZW5ndGggPSB0aGlzLnNjcm9sbC5sZW5ndGgoKTtcbiAgICAgIHRoaXMuc2Nyb2xsLmJhdGNoU3RhcnQoKTtcbiAgICAgIGRlbHRhID0gbm9ybWFsaXplRGVsdGEoZGVsdGEpO1xuICAgICAgZGVsdGEucmVkdWNlKGZ1bmN0aW9uIChpbmRleCwgb3ApIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IG9wLnJldGFpbiB8fCBvcC5kZWxldGUgfHwgb3AuaW5zZXJ0Lmxlbmd0aCB8fCAxO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG9wLmF0dHJpYnV0ZXMgfHwge307XG4gICAgICAgIGlmIChvcC5pbnNlcnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3AuaW5zZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBvcC5pbnNlcnQ7XG4gICAgICAgICAgICBpZiAodGV4dC5lbmRzV2l0aCgnXFxuJykgJiYgY29uc3VtZU5leHROZXdsaW5lKSB7XG4gICAgICAgICAgICAgIGNvbnN1bWVOZXh0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gc2Nyb2xsTGVuZ3RoICYmICF0ZXh0LmVuZHNXaXRoKCdcXG4nKSkge1xuICAgICAgICAgICAgICBjb25zdW1lTmV4dE5ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsLmluc2VydEF0KGluZGV4LCB0ZXh0KTtcblxuICAgICAgICAgICAgdmFyIF9zY3JvbGwkbGluZSA9IF90aGlzLnNjcm9sbC5saW5lKGluZGV4KSxcbiAgICAgICAgICAgICAgICBfc2Nyb2xsJGxpbmUyID0gX3NsaWNlZFRvQXJyYXkoX3Njcm9sbCRsaW5lLCAyKSxcbiAgICAgICAgICAgICAgICBsaW5lID0gX3Njcm9sbCRsaW5lMlswXSxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBfc2Nyb2xsJGxpbmUyWzFdO1xuXG4gICAgICAgICAgICB2YXIgZm9ybWF0cyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KSh7fSwgKDAsIF9ibG9jay5idWJibGVGb3JtYXRzKShsaW5lKSk7XG4gICAgICAgICAgICBpZiAobGluZSBpbnN0YW5jZW9mIF9ibG9jazIuZGVmYXVsdCkge1xuICAgICAgICAgICAgICB2YXIgX2xpbmUkZGVzY2VuZGFudCA9IGxpbmUuZGVzY2VuZGFudChfcGFyY2htZW50Mi5kZWZhdWx0LkxlYWYsIG9mZnNldCksXG4gICAgICAgICAgICAgICAgICBfbGluZSRkZXNjZW5kYW50MiA9IF9zbGljZWRUb0FycmF5KF9saW5lJGRlc2NlbmRhbnQsIDEpLFxuICAgICAgICAgICAgICAgICAgbGVhZiA9IF9saW5lJGRlc2NlbmRhbnQyWzBdO1xuXG4gICAgICAgICAgICAgIGZvcm1hdHMgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkoZm9ybWF0cywgKDAsIF9ibG9jay5idWJibGVGb3JtYXRzKShsZWFmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gX29wMi5kZWZhdWx0LmF0dHJpYnV0ZXMuZGlmZihmb3JtYXRzLCBhdHRyaWJ1dGVzKSB8fCB7fTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3AuaW5zZXJ0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBPYmplY3Qua2V5cyhvcC5pbnNlcnQpWzBdOyAvLyBUaGVyZSBzaG91bGQgb25seSBiZSBvbmUga2V5XG4gICAgICAgICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbC5pbnNlcnRBdChpbmRleCwga2V5LCBvcC5pbnNlcnRba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjcm9sbExlbmd0aCArPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIF90aGlzLnNjcm9sbC5mb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCBhdHRyaWJ1dGVzW25hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbmRleCArIGxlbmd0aDtcbiAgICAgIH0sIDApO1xuICAgICAgZGVsdGEucmVkdWNlKGZ1bmN0aW9uIChpbmRleCwgb3ApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcC5kZWxldGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgX3RoaXMuc2Nyb2xsLmRlbGV0ZUF0KGluZGV4LCBvcC5kZWxldGUpO1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXggKyAob3AucmV0YWluIHx8IG9wLmluc2VydC5sZW5ndGggfHwgMSk7XG4gICAgICB9LCAwKTtcbiAgICAgIHRoaXMuc2Nyb2xsLmJhdGNoRW5kKCk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUoZGVsdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVUZXh0KGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHRoaXMuc2Nyb2xsLmRlbGV0ZUF0KGluZGV4LCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihpbmRleCkuZGVsZXRlKGxlbmd0aCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdExpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRMaW5lKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9ybWF0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHRoaXMuc2Nyb2xsLnVwZGF0ZSgpO1xuICAgICAgT2JqZWN0LmtleXMoZm9ybWF0cykuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIGlmIChfdGhpczIuc2Nyb2xsLndoaXRlbGlzdCAhPSBudWxsICYmICFfdGhpczIuc2Nyb2xsLndoaXRlbGlzdFtmb3JtYXRdKSByZXR1cm47XG4gICAgICAgIHZhciBsaW5lcyA9IF90aGlzMi5zY3JvbGwubGluZXMoaW5kZXgsIE1hdGgubWF4KGxlbmd0aCwgMSkpO1xuICAgICAgICB2YXIgbGVuZ3RoUmVtYWluaW5nID0gbGVuZ3RoO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lLmxlbmd0aCgpO1xuICAgICAgICAgIGlmICghKGxpbmUgaW5zdGFuY2VvZiBfY29kZTIuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgIGxpbmUuZm9ybWF0KGZvcm1hdCwgZm9ybWF0c1tmb3JtYXRdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvZGVJbmRleCA9IGluZGV4IC0gbGluZS5vZmZzZXQoX3RoaXMyLnNjcm9sbCk7XG4gICAgICAgICAgICB2YXIgY29kZUxlbmd0aCA9IGxpbmUubmV3bGluZUluZGV4KGNvZGVJbmRleCArIGxlbmd0aFJlbWFpbmluZykgLSBjb2RlSW5kZXggKyAxO1xuICAgICAgICAgICAgbGluZS5mb3JtYXRBdChjb2RlSW5kZXgsIGNvZGVMZW5ndGgsIGZvcm1hdCwgZm9ybWF0c1tmb3JtYXRdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoUmVtYWluaW5nIC09IGxpbmVMZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNjcm9sbC5vcHRpbWl6ZSgpO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihpbmRleCkucmV0YWluKGxlbmd0aCwgKDAsIF9jbG9uZTIuZGVmYXVsdCkoZm9ybWF0cykpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0VGV4dChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBPYmplY3Qua2V5cyhmb3JtYXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgX3RoaXMzLnNjcm9sbC5mb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBmb3JtYXQsIGZvcm1hdHNbZm9ybWF0XSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oaW5kZXgpLnJldGFpbihsZW5ndGgsICgwLCBfY2xvbmUyLmRlZmF1bHQpKGZvcm1hdHMpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q29udGVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZW50cyhpbmRleCwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWx0YS5zbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldERlbHRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVsdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGwubGluZXMoKS5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBsaW5lKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5jb25jYXQobGluZS5kZWx0YSgpKTtcbiAgICAgIH0sIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRGb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXQoaW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICAgIHZhciBsaW5lcyA9IFtdLFxuICAgICAgICAgIGxlYXZlcyA9IFtdO1xuICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNjcm9sbC5wYXRoKGluZGV4KS5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgdmFyIF9wYXRoID0gX3NsaWNlZFRvQXJyYXkocGF0aCwgMSksXG4gICAgICAgICAgICAgIGJsb3QgPSBfcGF0aFswXTtcblxuICAgICAgICAgIGlmIChibG90IGluc3RhbmNlb2YgX2Jsb2NrMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGJsb3QpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYmxvdCBpbnN0YW5jZW9mIF9wYXJjaG1lbnQyLmRlZmF1bHQuTGVhZikge1xuICAgICAgICAgICAgbGVhdmVzLnB1c2goYmxvdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmVzID0gdGhpcy5zY3JvbGwubGluZXMoaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIGxlYXZlcyA9IHRoaXMuc2Nyb2xsLmRlc2NlbmRhbnRzKF9wYXJjaG1lbnQyLmRlZmF1bHQuTGVhZiwgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICB2YXIgZm9ybWF0c0FyciA9IFtsaW5lcywgbGVhdmVzXS5tYXAoZnVuY3Rpb24gKGJsb3RzKSB7XG4gICAgICAgIGlmIChibG90cy5sZW5ndGggPT09IDApIHJldHVybiB7fTtcbiAgICAgICAgdmFyIGZvcm1hdHMgPSAoMCwgX2Jsb2NrLmJ1YmJsZUZvcm1hdHMpKGJsb3RzLnNoaWZ0KCkpO1xuICAgICAgICB3aGlsZSAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBibG90ID0gYmxvdHMuc2hpZnQoKTtcbiAgICAgICAgICBpZiAoYmxvdCA9PSBudWxsKSByZXR1cm4gZm9ybWF0cztcbiAgICAgICAgICBmb3JtYXRzID0gY29tYmluZUZvcm1hdHMoKDAsIF9ibG9jay5idWJibGVGb3JtYXRzKShibG90KSwgZm9ybWF0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfZXh0ZW5kMi5kZWZhdWx0LmFwcGx5KF9leHRlbmQyLmRlZmF1bHQsIGZvcm1hdHNBcnIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0KGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENvbnRlbnRzKGluZGV4LCBsZW5ndGgpLmZpbHRlcihmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChvcCkge1xuICAgICAgICByZXR1cm4gb3AuaW5zZXJ0O1xuICAgICAgfSkuam9pbignJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0RW1iZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRFbWJlZChpbmRleCwgZW1iZWQsIHZhbHVlKSB7XG4gICAgICB0aGlzLnNjcm9sbC5pbnNlcnRBdChpbmRleCwgZW1iZWQsIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oaW5kZXgpLmluc2VydChfZGVmaW5lUHJvcGVydHkoe30sIGVtYmVkLCB2YWx1ZSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0VGV4dChpbmRleCwgdGV4dCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtYXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcbicpO1xuICAgICAgdGhpcy5zY3JvbGwuaW5zZXJ0QXQoaW5kZXgsIHRleHQpO1xuICAgICAgT2JqZWN0LmtleXMoZm9ybWF0cykuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIF90aGlzNC5zY3JvbGwuZm9ybWF0QXQoaW5kZXgsIHRleHQubGVuZ3RoLCBmb3JtYXQsIGZvcm1hdHNbZm9ybWF0XSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oaW5kZXgpLmluc2VydCh0ZXh0LCAoMCwgX2Nsb25lMi5kZWZhdWx0KShmb3JtYXRzKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzQmxhbmsnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JsYW5rKCkge1xuICAgICAgaWYgKHRoaXMuc2Nyb2xsLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLnNjcm9sbC5jaGlsZHJlbi5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgYmxvY2sgPSB0aGlzLnNjcm9sbC5jaGlsZHJlbi5oZWFkO1xuICAgICAgaWYgKGJsb2NrLnN0YXRpY3MuYmxvdE5hbWUgIT09IF9ibG9jazIuZGVmYXVsdC5ibG90TmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBibG9jay5jaGlsZHJlbi5oZWFkIGluc3RhbmNlb2YgX2JyZWFrMi5kZWZhdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZUZvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUZvcm1hdChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dChpbmRleCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIF9zY3JvbGwkbGluZTMgPSB0aGlzLnNjcm9sbC5saW5lKGluZGV4ICsgbGVuZ3RoKSxcbiAgICAgICAgICBfc2Nyb2xsJGxpbmU0ID0gX3NsaWNlZFRvQXJyYXkoX3Njcm9sbCRsaW5lMywgMiksXG4gICAgICAgICAgbGluZSA9IF9zY3JvbGwkbGluZTRbMF0sXG4gICAgICAgICAgb2Zmc2V0ID0gX3Njcm9sbCRsaW5lNFsxXTtcblxuICAgICAgdmFyIHN1ZmZpeExlbmd0aCA9IDAsXG4gICAgICAgICAgc3VmZml4ID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCk7XG4gICAgICBpZiAobGluZSAhPSBudWxsKSB7XG4gICAgICAgIGlmICghKGxpbmUgaW5zdGFuY2VvZiBfY29kZTIuZGVmYXVsdCkpIHtcbiAgICAgICAgICBzdWZmaXhMZW5ndGggPSBsaW5lLmxlbmd0aCgpIC0gb2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1ZmZpeExlbmd0aCA9IGxpbmUubmV3bGluZUluZGV4KG9mZnNldCkgLSBvZmZzZXQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHN1ZmZpeCA9IGxpbmUuZGVsdGEoKS5zbGljZShvZmZzZXQsIG9mZnNldCArIHN1ZmZpeExlbmd0aCAtIDEpLmluc2VydCgnXFxuJyk7XG4gICAgICB9XG4gICAgICB2YXIgY29udGVudHMgPSB0aGlzLmdldENvbnRlbnRzKGluZGV4LCBsZW5ndGggKyBzdWZmaXhMZW5ndGgpO1xuICAgICAgdmFyIGRpZmYgPSBjb250ZW50cy5kaWZmKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLmluc2VydCh0ZXh0KS5jb25jYXQoc3VmZml4KSk7XG4gICAgICB2YXIgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oaW5kZXgpLmNvbmNhdChkaWZmKTtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5RGVsdGEoZGVsdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShjaGFuZ2UpIHtcbiAgICAgIHZhciBtdXRhdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgICAgdmFyIGN1cnNvckluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBvbGREZWx0YSA9IHRoaXMuZGVsdGE7XG4gICAgICBpZiAobXV0YXRpb25zLmxlbmd0aCA9PT0gMSAmJiBtdXRhdGlvbnNbMF0udHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnICYmIG11dGF0aW9uc1swXS50YXJnZXQuZGF0YS5tYXRjaChBU0NJSSkgJiYgX3BhcmNobWVudDIuZGVmYXVsdC5maW5kKG11dGF0aW9uc1swXS50YXJnZXQpKSB7XG4gICAgICAgIC8vIE9wdGltaXphdGlvbiBmb3IgY2hhcmFjdGVyIGNoYW5nZXNcbiAgICAgICAgdmFyIHRleHRCbG90ID0gX3BhcmNobWVudDIuZGVmYXVsdC5maW5kKG11dGF0aW9uc1swXS50YXJnZXQpO1xuICAgICAgICB2YXIgZm9ybWF0cyA9ICgwLCBfYmxvY2suYnViYmxlRm9ybWF0cykodGV4dEJsb3QpO1xuICAgICAgICB2YXIgaW5kZXggPSB0ZXh0QmxvdC5vZmZzZXQodGhpcy5zY3JvbGwpO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBtdXRhdGlvbnNbMF0ub2xkVmFsdWUucmVwbGFjZShfY3Vyc29yMi5kZWZhdWx0LkNPTlRFTlRTLCAnJyk7XG4gICAgICAgIHZhciBvbGRUZXh0ID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkuaW5zZXJ0KG9sZFZhbHVlKTtcbiAgICAgICAgdmFyIG5ld1RleHQgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5pbnNlcnQodGV4dEJsb3QudmFsdWUoKSk7XG4gICAgICAgIHZhciBkaWZmRGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oaW5kZXgpLmNvbmNhdChvbGRUZXh0LmRpZmYobmV3VGV4dCwgY3Vyc29ySW5kZXgpKTtcbiAgICAgICAgY2hhbmdlID0gZGlmZkRlbHRhLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIG9wKSB7XG4gICAgICAgICAgaWYgKG9wLmluc2VydCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhLmluc2VydChvcC5pbnNlcnQsIGZvcm1hdHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsdGEucHVzaChvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSk7XG4gICAgICAgIHRoaXMuZGVsdGEgPSBvbGREZWx0YS5jb21wb3NlKGNoYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlbHRhID0gdGhpcy5nZXREZWx0YSgpO1xuICAgICAgICBpZiAoIWNoYW5nZSB8fCAhKDAsIF9kZWVwRXF1YWwyLmRlZmF1bHQpKG9sZERlbHRhLmNvbXBvc2UoY2hhbmdlKSwgdGhpcy5kZWx0YSkpIHtcbiAgICAgICAgICBjaGFuZ2UgPSBvbGREZWx0YS5kaWZmKHRoaXMuZGVsdGEsIGN1cnNvckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRWRpdG9yO1xufSgpO1xuXG5mdW5jdGlvbiBjb21iaW5lRm9ybWF0cyhmb3JtYXRzLCBjb21iaW5lZCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoY29tYmluZWQpLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBuYW1lKSB7XG4gICAgaWYgKGZvcm1hdHNbbmFtZV0gPT0gbnVsbCkgcmV0dXJuIG1lcmdlZDtcbiAgICBpZiAoY29tYmluZWRbbmFtZV0gPT09IGZvcm1hdHNbbmFtZV0pIHtcbiAgICAgIG1lcmdlZFtuYW1lXSA9IGNvbWJpbmVkW25hbWVdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb21iaW5lZFtuYW1lXSkpIHtcbiAgICAgIGlmIChjb21iaW5lZFtuYW1lXS5pbmRleE9mKGZvcm1hdHNbbmFtZV0pIDwgMCkge1xuICAgICAgICBtZXJnZWRbbmFtZV0gPSBjb21iaW5lZFtuYW1lXS5jb25jYXQoW2Zvcm1hdHNbbmFtZV1dKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VkW25hbWVdID0gW2NvbWJpbmVkW25hbWVdLCBmb3JtYXRzW25hbWVdXTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVEZWx0YShkZWx0YSkge1xuICByZXR1cm4gZGVsdGEucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgb3ApIHtcbiAgICBpZiAob3AuaW5zZXJ0ID09PSAxKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9ICgwLCBfY2xvbmUyLmRlZmF1bHQpKG9wLmF0dHJpYnV0ZXMpO1xuICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNbJ2ltYWdlJ107XG4gICAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KHsgaW1hZ2U6IG9wLmF0dHJpYnV0ZXMuaW1hZ2UgfSwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGlmIChvcC5hdHRyaWJ1dGVzICE9IG51bGwgJiYgKG9wLmF0dHJpYnV0ZXMubGlzdCA9PT0gdHJ1ZSB8fCBvcC5hdHRyaWJ1dGVzLmJ1bGxldCA9PT0gdHJ1ZSkpIHtcbiAgICAgIG9wID0gKDAsIF9jbG9uZTIuZGVmYXVsdCkob3ApO1xuICAgICAgaWYgKG9wLmF0dHJpYnV0ZXMubGlzdCkge1xuICAgICAgICBvcC5hdHRyaWJ1dGVzLmxpc3QgPSAnb3JkZXJlZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5hdHRyaWJ1dGVzLmxpc3QgPSAnYnVsbGV0JztcbiAgICAgICAgZGVsZXRlIG9wLmF0dHJpYnV0ZXMuYnVsbGV0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciB0ZXh0ID0gb3AuaW5zZXJ0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcbiAgICAgIHJldHVybiBkZWx0YS5pbnNlcnQodGV4dCwgb3AuYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBkZWx0YS5wdXNoKG9wKTtcbiAgfSwgbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBFZGl0b3I7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuUmFuZ2UgPSB1bmRlZmluZWQ7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX2Nsb25lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbnZhciBfY2xvbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvbmUpO1xuXG52YXIgX2RlZXBFcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX2VtaXR0ZXIzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9lbWl0dGVyNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VtaXR0ZXIzKTtcblxudmFyIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBkZWJ1ZyA9ICgwLCBfbG9nZ2VyMi5kZWZhdWx0KSgncXVpbGw6c2VsZWN0aW9uJyk7XG5cbnZhciBSYW5nZSA9IGZ1bmN0aW9uIFJhbmdlKGluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlKTtcblxuICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xufTtcblxudmFyIFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VsZWN0aW9uKHNjcm9sbCwgZW1pdHRlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uKTtcblxuICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgdGhpcy5zY3JvbGwgPSBzY3JvbGw7XG4gICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuc2Nyb2xsLmRvbU5vZGU7XG4gICAgdGhpcy5jdXJzb3IgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSgnY3Vyc29yJywgdGhpcyk7XG4gICAgLy8gc2F2ZWRSYW5nZSBpcyBsYXN0IG5vbi1udWxsIHJhbmdlXG4gICAgdGhpcy5sYXN0UmFuZ2UgPSB0aGlzLnNhdmVkUmFuZ2UgPSBuZXcgUmFuZ2UoMCwgMCk7XG4gICAgdGhpcy5oYW5kbGVDb21wb3NpdGlvbigpO1xuICAgIHRoaXMuaGFuZGxlRHJhZ2dpbmcoKTtcbiAgICB0aGlzLmVtaXR0ZXIubGlzdGVuRE9NKCdzZWxlY3Rpb25jaGFuZ2UnLCBkb2N1bWVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5tb3VzZURvd24pIHtcbiAgICAgICAgc2V0VGltZW91dChfdGhpcy51cGRhdGUuYmluZChfdGhpcywgX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5VU0VSKSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0dGVyLm9uKF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5FRElUT1JfQ0hBTkdFLCBmdW5jdGlvbiAodHlwZSwgZGVsdGEpIHtcbiAgICAgIGlmICh0eXBlID09PSBfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuVEVYVF9DSEFOR0UgJiYgZGVsdGEubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZShfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0dGVyLm9uKF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfQkVGT1JFX1VQREFURSwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5oYXNGb2N1cygpKSByZXR1cm47XG4gICAgICB2YXIgbmF0aXZlID0gX3RoaXMuZ2V0TmF0aXZlUmFuZ2UoKTtcbiAgICAgIGlmIChuYXRpdmUgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKG5hdGl2ZS5zdGFydC5ub2RlID09PSBfdGhpcy5jdXJzb3IudGV4dE5vZGUpIHJldHVybjsgLy8gY3Vyc29yLnJlc3RvcmUoKSB3aWxsIGhhbmRsZVxuICAgICAgLy8gVE9ETyB1bmNsZWFyIGlmIHRoaXMgaGFzIG5lZ2F0aXZlIHNpZGUgZWZmZWN0c1xuICAgICAgX3RoaXMuZW1pdHRlci5vbmNlKF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfVVBEQVRFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3RoaXMuc2V0TmF0aXZlUmFuZ2UobmF0aXZlLnN0YXJ0Lm5vZGUsIG5hdGl2ZS5zdGFydC5vZmZzZXQsIG5hdGl2ZS5lbmQubm9kZSwgbmF0aXZlLmVuZC5vZmZzZXQpO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7fVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0dGVyLm9uKF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfT1BUSU1JWkUsIGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0LnJhbmdlKSB7XG4gICAgICAgIHZhciBfY29udGV4dCRyYW5nZSA9IGNvbnRleHQucmFuZ2UsXG4gICAgICAgICAgICBzdGFydE5vZGUgPSBfY29udGV4dCRyYW5nZS5zdGFydE5vZGUsXG4gICAgICAgICAgICBzdGFydE9mZnNldCA9IF9jb250ZXh0JHJhbmdlLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgZW5kTm9kZSA9IF9jb250ZXh0JHJhbmdlLmVuZE5vZGUsXG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBfY29udGV4dCRyYW5nZS5lbmRPZmZzZXQ7XG5cbiAgICAgICAgX3RoaXMuc2V0TmF0aXZlUmFuZ2Uoc3RhcnROb2RlLCBzdGFydE9mZnNldCwgZW5kTm9kZSwgZW5kT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZShfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2VsZWN0aW9uLCBbe1xuICAgIGtleTogJ2hhbmRsZUNvbXBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ29tcG9zaXRpb24oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5jb21wb3NpbmcgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKF90aGlzMi5jdXJzb3IucGFyZW50KSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMyLmN1cnNvci5yZXN0b3JlKCk7XG4gICAgICAgICAgaWYgKCFyYW5nZSkgcmV0dXJuO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLnNldE5hdGl2ZVJhbmdlKHJhbmdlLnN0YXJ0Tm9kZSwgcmFuZ2Uuc3RhcnRPZmZzZXQsIHJhbmdlLmVuZE5vZGUsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgfSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZURyYWdnaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRHJhZ2dpbmcoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5lbWl0dGVyLmxpc3RlbkRPTSgnbW91c2Vkb3duJywgZG9jdW1lbnQuYm9keSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMubW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0dGVyLmxpc3RlbkRPTSgnbW91c2V1cCcsIGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICBfdGhpczMudXBkYXRlKF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb2N1cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgaWYgKHRoaXMuaGFzRm9jdXMoKSkgcmV0dXJuO1xuICAgICAgdGhpcy5yb290LmZvY3VzKCk7XG4gICAgICB0aGlzLnNldFJhbmdlKHRoaXMuc2F2ZWRSYW5nZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KF9mb3JtYXQsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5zY3JvbGwud2hpdGVsaXN0ICE9IG51bGwgJiYgIXRoaXMuc2Nyb2xsLndoaXRlbGlzdFtfZm9ybWF0XSkgcmV0dXJuO1xuICAgICAgdGhpcy5zY3JvbGwudXBkYXRlKCk7XG4gICAgICB2YXIgbmF0aXZlUmFuZ2UgPSB0aGlzLmdldE5hdGl2ZVJhbmdlKCk7XG4gICAgICBpZiAobmF0aXZlUmFuZ2UgPT0gbnVsbCB8fCAhbmF0aXZlUmFuZ2UubmF0aXZlLmNvbGxhcHNlZCB8fCBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KF9mb3JtYXQsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0spKSByZXR1cm47XG4gICAgICBpZiAobmF0aXZlUmFuZ2Uuc3RhcnQubm9kZSAhPT0gdGhpcy5jdXJzb3IudGV4dE5vZGUpIHtcbiAgICAgICAgdmFyIGJsb3QgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmZpbmQobmF0aXZlUmFuZ2Uuc3RhcnQubm9kZSwgZmFsc2UpO1xuICAgICAgICBpZiAoYmxvdCA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIC8vIFRPRE8gR2l2ZSBibG90IGFiaWxpdHkgdG8gbm90IHNwbGl0XG4gICAgICAgIGlmIChibG90IGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5MZWFmKSB7XG4gICAgICAgICAgdmFyIGFmdGVyID0gYmxvdC5zcGxpdChuYXRpdmVSYW5nZS5zdGFydC5vZmZzZXQpO1xuICAgICAgICAgIGJsb3QucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmN1cnNvciwgYWZ0ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsb3QuaW5zZXJ0QmVmb3JlKHRoaXMuY3Vyc29yLCBuYXRpdmVSYW5nZS5zdGFydC5ub2RlKTsgLy8gU2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Vyc29yLmF0dGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJzb3IuZm9ybWF0KF9mb3JtYXQsIHZhbHVlKTtcbiAgICAgIHRoaXMuc2Nyb2xsLm9wdGltaXplKCk7XG4gICAgICB0aGlzLnNldE5hdGl2ZVJhbmdlKHRoaXMuY3Vyc29yLnRleHROb2RlLCB0aGlzLmN1cnNvci50ZXh0Tm9kZS5kYXRhLmxlbmd0aCk7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEJvdW5kcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kcyhpbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgICAgdmFyIHNjcm9sbExlbmd0aCA9IHRoaXMuc2Nyb2xsLmxlbmd0aCgpO1xuICAgICAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgc2Nyb2xsTGVuZ3RoIC0gMSk7XG4gICAgICBsZW5ndGggPSBNYXRoLm1pbihpbmRleCArIGxlbmd0aCwgc2Nyb2xsTGVuZ3RoIC0gMSkgLSBpbmRleDtcbiAgICAgIHZhciBub2RlID0gdm9pZCAwLFxuICAgICAgICAgIF9zY3JvbGwkbGVhZiA9IHRoaXMuc2Nyb2xsLmxlYWYoaW5kZXgpLFxuICAgICAgICAgIF9zY3JvbGwkbGVhZjIgPSBfc2xpY2VkVG9BcnJheShfc2Nyb2xsJGxlYWYsIDIpLFxuICAgICAgICAgIGxlYWYgPSBfc2Nyb2xsJGxlYWYyWzBdLFxuICAgICAgICAgIG9mZnNldCA9IF9zY3JvbGwkbGVhZjJbMV07XG4gICAgICBpZiAobGVhZiA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIF9sZWFmJHBvc2l0aW9uID0gbGVhZi5wb3NpdGlvbihvZmZzZXQsIHRydWUpO1xuXG4gICAgICB2YXIgX2xlYWYkcG9zaXRpb24yID0gX3NsaWNlZFRvQXJyYXkoX2xlYWYkcG9zaXRpb24sIDIpO1xuXG4gICAgICBub2RlID0gX2xlYWYkcG9zaXRpb24yWzBdO1xuICAgICAgb2Zmc2V0ID0gX2xlYWYkcG9zaXRpb24yWzFdO1xuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcblxuICAgICAgICB2YXIgX3Njcm9sbCRsZWFmMyA9IHRoaXMuc2Nyb2xsLmxlYWYoaW5kZXggKyBsZW5ndGgpO1xuXG4gICAgICAgIHZhciBfc2Nyb2xsJGxlYWY0ID0gX3NsaWNlZFRvQXJyYXkoX3Njcm9sbCRsZWFmMywgMik7XG5cbiAgICAgICAgbGVhZiA9IF9zY3JvbGwkbGVhZjRbMF07XG4gICAgICAgIG9mZnNldCA9IF9zY3JvbGwkbGVhZjRbMV07XG5cbiAgICAgICAgaWYgKGxlYWYgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIF9sZWFmJHBvc2l0aW9uMyA9IGxlYWYucG9zaXRpb24ob2Zmc2V0LCB0cnVlKTtcblxuICAgICAgICB2YXIgX2xlYWYkcG9zaXRpb240ID0gX3NsaWNlZFRvQXJyYXkoX2xlYWYkcG9zaXRpb24zLCAyKTtcblxuICAgICAgICBub2RlID0gX2xlYWYkcG9zaXRpb240WzBdO1xuICAgICAgICBvZmZzZXQgPSBfbGVhZiRwb3NpdGlvbjRbMV07XG5cbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzaWRlID0gJ2xlZnQnO1xuICAgICAgICB2YXIgcmVjdCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgaWYgKG9mZnNldCA8IG5vZGUuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCAtIDEpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICBzaWRlID0gJ3JpZ2h0JztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3QgPSBsZWFmLmRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgaWYgKG9mZnNldCA+IDApIHNpZGUgPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm90dG9tOiByZWN0LnRvcCArIHJlY3QuaGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgICAgICAgbGVmdDogcmVjdFtzaWRlXSxcbiAgICAgICAgICByaWdodDogcmVjdFtzaWRlXSxcbiAgICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TmF0aXZlUmFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYXRpdmVSYW5nZSgpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChzZWxlY3Rpb24gPT0gbnVsbCB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA8PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBuYXRpdmVSYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgaWYgKG5hdGl2ZVJhbmdlID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5ub3JtYWxpemVOYXRpdmUobmF0aXZlUmFuZ2UpO1xuICAgICAgZGVidWcuaW5mbygnZ2V0TmF0aXZlUmFuZ2UnLCByYW5nZSk7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UmFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5nZSgpIHtcbiAgICAgIHZhciBub3JtYWxpemVkID0gdGhpcy5nZXROYXRpdmVSYW5nZSgpO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQgPT0gbnVsbCkgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMubm9ybWFsaXplZFRvUmFuZ2Uobm9ybWFsaXplZCk7XG4gICAgICByZXR1cm4gW3JhbmdlLCBub3JtYWxpemVkXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYXNGb2N1cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0ZvY3VzKCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMucm9vdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdub3JtYWxpemVkVG9SYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZWRUb1JhbmdlKHJhbmdlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHBvc2l0aW9ucyA9IFtbcmFuZ2Uuc3RhcnQubm9kZSwgcmFuZ2Uuc3RhcnQub2Zmc2V0XV07XG4gICAgICBpZiAoIXJhbmdlLm5hdGl2ZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goW3JhbmdlLmVuZC5ub2RlLCByYW5nZS5lbmQub2Zmc2V0XSk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXhlcyA9IHBvc2l0aW9ucy5tYXAoZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfcG9zaXRpb24gPSBfc2xpY2VkVG9BcnJheShwb3NpdGlvbiwgMiksXG4gICAgICAgICAgICBub2RlID0gX3Bvc2l0aW9uWzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3Bvc2l0aW9uWzFdO1xuXG4gICAgICAgIHZhciBibG90ID0gX3BhcmNobWVudDIuZGVmYXVsdC5maW5kKG5vZGUsIHRydWUpO1xuICAgICAgICB2YXIgaW5kZXggPSBibG90Lm9mZnNldChfdGhpczQuc2Nyb2xsKTtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfSBlbHNlIGlmIChibG90IGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5Db250YWluZXIpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXggKyBibG90Lmxlbmd0aCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpbmRleCArIGJsb3QuaW5kZXgobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgZW5kID0gTWF0aC5taW4oTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGluZGV4ZXMpKSwgdGhpcy5zY3JvbGwubGVuZ3RoKCkgLSAxKTtcbiAgICAgIHZhciBzdGFydCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIFtlbmRdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaW5kZXhlcykpKTtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdub3JtYWxpemVOYXRpdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemVOYXRpdmUobmF0aXZlUmFuZ2UpIHtcbiAgICAgIGlmICghY29udGFpbnModGhpcy5yb290LCBuYXRpdmVSYW5nZS5zdGFydENvbnRhaW5lcikgfHwgIW5hdGl2ZVJhbmdlLmNvbGxhcHNlZCAmJiAhY29udGFpbnModGhpcy5yb290LCBuYXRpdmVSYW5nZS5lbmRDb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHJhbmdlID0ge1xuICAgICAgICBzdGFydDogeyBub2RlOiBuYXRpdmVSYW5nZS5zdGFydENvbnRhaW5lciwgb2Zmc2V0OiBuYXRpdmVSYW5nZS5zdGFydE9mZnNldCB9LFxuICAgICAgICBlbmQ6IHsgbm9kZTogbmF0aXZlUmFuZ2UuZW5kQ29udGFpbmVyLCBvZmZzZXQ6IG5hdGl2ZVJhbmdlLmVuZE9mZnNldCB9LFxuICAgICAgICBuYXRpdmU6IG5hdGl2ZVJhbmdlXG4gICAgICB9O1xuICAgICAgW3JhbmdlLnN0YXJ0LCByYW5nZS5lbmRdLmZvckVhY2goZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBub2RlID0gcG9zaXRpb24ubm9kZSxcbiAgICAgICAgICAgIG9mZnNldCA9IHBvc2l0aW9uLm9mZnNldDtcbiAgICAgICAgd2hpbGUgKCEobm9kZSBpbnN0YW5jZW9mIFRleHQpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiBvZmZzZXQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIG9mZnNldCA9IG5vZGUgaW5zdGFuY2VvZiBUZXh0ID8gbm9kZS5kYXRhLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24ubm9kZSA9IG5vZGUsIHBvc2l0aW9uLm9mZnNldCA9IG9mZnNldDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JhbmdlVG9OYXRpdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYW5nZVRvTmF0aXZlKHJhbmdlKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGluZGV4ZXMgPSByYW5nZS5jb2xsYXBzZWQgPyBbcmFuZ2UuaW5kZXhdIDogW3JhbmdlLmluZGV4LCByYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aF07XG4gICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgdmFyIHNjcm9sbExlbmd0aCA9IHRoaXMuc2Nyb2xsLmxlbmd0aCgpO1xuICAgICAgaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCwgaSkge1xuICAgICAgICBpbmRleCA9IE1hdGgubWluKHNjcm9sbExlbmd0aCAtIDEsIGluZGV4KTtcbiAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDAsXG4gICAgICAgICAgICBfc2Nyb2xsJGxlYWY1ID0gX3RoaXM1LnNjcm9sbC5sZWFmKGluZGV4KSxcbiAgICAgICAgICAgIF9zY3JvbGwkbGVhZjYgPSBfc2xpY2VkVG9BcnJheShfc2Nyb2xsJGxlYWY1LCAyKSxcbiAgICAgICAgICAgIGxlYWYgPSBfc2Nyb2xsJGxlYWY2WzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3Njcm9sbCRsZWFmNlsxXTtcbiAgICAgICAgdmFyIF9sZWFmJHBvc2l0aW9uNSA9IGxlYWYucG9zaXRpb24ob2Zmc2V0LCBpICE9PSAwKTtcblxuICAgICAgICB2YXIgX2xlYWYkcG9zaXRpb242ID0gX3NsaWNlZFRvQXJyYXkoX2xlYWYkcG9zaXRpb241LCAyKTtcblxuICAgICAgICBub2RlID0gX2xlYWYkcG9zaXRpb242WzBdO1xuICAgICAgICBvZmZzZXQgPSBfbGVhZiRwb3NpdGlvbjZbMV07XG5cbiAgICAgICAgYXJncy5wdXNoKG5vZGUsIG9mZnNldCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2Nyb2xsSW50b1ZpZXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhzY3JvbGxpbmdDb250YWluZXIpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMubGFzdFJhbmdlO1xuICAgICAgaWYgKHJhbmdlID09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcyhyYW5nZS5pbmRleCwgcmFuZ2UubGVuZ3RoKTtcbiAgICAgIGlmIChib3VuZHMgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIGxpbWl0ID0gdGhpcy5zY3JvbGwubGVuZ3RoKCkgLSAxO1xuXG4gICAgICB2YXIgX3Njcm9sbCRsaW5lID0gdGhpcy5zY3JvbGwubGluZShNYXRoLm1pbihyYW5nZS5pbmRleCwgbGltaXQpKSxcbiAgICAgICAgICBfc2Nyb2xsJGxpbmUyID0gX3NsaWNlZFRvQXJyYXkoX3Njcm9sbCRsaW5lLCAxKSxcbiAgICAgICAgICBmaXJzdCA9IF9zY3JvbGwkbGluZTJbMF07XG5cbiAgICAgIHZhciBsYXN0ID0gZmlyc3Q7XG4gICAgICBpZiAocmFuZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX3Njcm9sbCRsaW5lMyA9IHRoaXMuc2Nyb2xsLmxpbmUoTWF0aC5taW4ocmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGgsIGxpbWl0KSk7XG5cbiAgICAgICAgdmFyIF9zY3JvbGwkbGluZTQgPSBfc2xpY2VkVG9BcnJheShfc2Nyb2xsJGxpbmUzLCAxKTtcblxuICAgICAgICBsYXN0ID0gX3Njcm9sbCRsaW5lNFswXTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdCA9PSBudWxsIHx8IGxhc3QgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIHNjcm9sbEJvdW5kcyA9IHNjcm9sbGluZ0NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmIChib3VuZHMudG9wIDwgc2Nyb2xsQm91bmRzLnRvcCkge1xuICAgICAgICBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wIC09IHNjcm9sbEJvdW5kcy50b3AgLSBib3VuZHMudG9wO1xuICAgICAgfSBlbHNlIGlmIChib3VuZHMuYm90dG9tID4gc2Nyb2xsQm91bmRzLmJvdHRvbSkge1xuICAgICAgICBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wICs9IGJvdW5kcy5ib3R0b20gLSBzY3JvbGxCb3VuZHMuYm90dG9tO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldE5hdGl2ZVJhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TmF0aXZlUmFuZ2Uoc3RhcnROb2RlLCBzdGFydE9mZnNldCkge1xuICAgICAgdmFyIGVuZE5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHN0YXJ0Tm9kZTtcbiAgICAgIHZhciBlbmRPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHN0YXJ0T2Zmc2V0O1xuICAgICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAgICAgZGVidWcuaW5mbygnc2V0TmF0aXZlUmFuZ2UnLCBzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0LCBlbmROb2RlLCBlbmRPZmZzZXQpO1xuICAgICAgaWYgKHN0YXJ0Tm9kZSAhPSBudWxsICYmICh0aGlzLnJvb3QucGFyZW50Tm9kZSA9PSBudWxsIHx8IHN0YXJ0Tm9kZS5wYXJlbnROb2RlID09IG51bGwgfHwgZW5kTm9kZS5wYXJlbnROb2RlID09IG51bGwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKHN0YXJ0Tm9kZSAhPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cygpKSB0aGlzLnJvb3QuZm9jdXMoKTtcbiAgICAgICAgdmFyIG5hdGl2ZSA9ICh0aGlzLmdldE5hdGl2ZVJhbmdlKCkgfHwge30pLm5hdGl2ZTtcbiAgICAgICAgaWYgKG5hdGl2ZSA9PSBudWxsIHx8IGZvcmNlIHx8IHN0YXJ0Tm9kZSAhPT0gbmF0aXZlLnN0YXJ0Q29udGFpbmVyIHx8IHN0YXJ0T2Zmc2V0ICE9PSBuYXRpdmUuc3RhcnRPZmZzZXQgfHwgZW5kTm9kZSAhPT0gbmF0aXZlLmVuZENvbnRhaW5lciB8fCBlbmRPZmZzZXQgIT09IG5hdGl2ZS5lbmRPZmZzZXQpIHtcblxuICAgICAgICAgIGlmIChzdGFydE5vZGUudGFnTmFtZSA9PSBcIkJSXCIpIHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gW10uaW5kZXhPZi5jYWxsKHN0YXJ0Tm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMsIHN0YXJ0Tm9kZSk7XG4gICAgICAgICAgICBzdGFydE5vZGUgPSBzdGFydE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZE5vZGUudGFnTmFtZSA9PSBcIkJSXCIpIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IFtdLmluZGV4T2YuY2FsbChlbmROb2RlLnBhcmVudE5vZGUuY2hpbGROb2RlcywgZW5kTm9kZSk7XG4gICAgICAgICAgICBlbmROb2RlID0gZW5kTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChlbmROb2RlLCBlbmRPZmZzZXQpO1xuICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHRoaXMucm9vdC5ibHVyKCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTsgLy8gcm9vdC5ibHVyKCkgbm90IGVub3VnaCBvbiBJRTExK1RyYXZpcytTYXVjZUxhYnMgKGJ1dCBub3QgbG9jYWwgVk1zKVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFJhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UmFuZ2UocmFuZ2UpIHtcbiAgICAgIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLkFQSTtcblxuICAgICAgaWYgKHR5cGVvZiBmb3JjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc291cmNlID0gZm9yY2U7XG4gICAgICAgIGZvcmNlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBkZWJ1Zy5pbmZvKCdzZXRSYW5nZScsIHJhbmdlKTtcbiAgICAgIGlmIChyYW5nZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy5yYW5nZVRvTmF0aXZlKHJhbmdlKTtcbiAgICAgICAgdGhpcy5zZXROYXRpdmVSYW5nZS5hcHBseSh0aGlzLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJncykuY29uY2F0KFtmb3JjZV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0TmF0aXZlUmFuZ2UobnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZShzb3VyY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuVVNFUjtcblxuICAgICAgdmFyIG9sZFJhbmdlID0gdGhpcy5sYXN0UmFuZ2U7XG5cbiAgICAgIHZhciBfZ2V0UmFuZ2UgPSB0aGlzLmdldFJhbmdlKCksXG4gICAgICAgICAgX2dldFJhbmdlMiA9IF9zbGljZWRUb0FycmF5KF9nZXRSYW5nZSwgMiksXG4gICAgICAgICAgbGFzdFJhbmdlID0gX2dldFJhbmdlMlswXSxcbiAgICAgICAgICBuYXRpdmVSYW5nZSA9IF9nZXRSYW5nZTJbMV07XG5cbiAgICAgIHRoaXMubGFzdFJhbmdlID0gbGFzdFJhbmdlO1xuICAgICAgaWYgKHRoaXMubGFzdFJhbmdlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zYXZlZFJhbmdlID0gdGhpcy5sYXN0UmFuZ2U7XG4gICAgICB9XG4gICAgICBpZiAoISgwLCBfZGVlcEVxdWFsMi5kZWZhdWx0KShvbGRSYW5nZSwgdGhpcy5sYXN0UmFuZ2UpKSB7XG4gICAgICAgIHZhciBfZW1pdHRlcjtcblxuICAgICAgICBpZiAoIXRoaXMuY29tcG9zaW5nICYmIG5hdGl2ZVJhbmdlICE9IG51bGwgJiYgbmF0aXZlUmFuZ2UubmF0aXZlLmNvbGxhcHNlZCAmJiBuYXRpdmVSYW5nZS5zdGFydC5ub2RlICE9PSB0aGlzLmN1cnNvci50ZXh0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IFtfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuU0VMRUNUSU9OX0NIQU5HRSwgKDAsIF9jbG9uZTIuZGVmYXVsdCkodGhpcy5sYXN0UmFuZ2UpLCAoMCwgX2Nsb25lMi5kZWZhdWx0KShvbGRSYW5nZSksIHNvdXJjZV07XG4gICAgICAgIChfZW1pdHRlciA9IHRoaXMuZW1pdHRlcikuZW1pdC5hcHBseShfZW1pdHRlciwgW19lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5FRElUT1JfQ0hBTkdFXS5jb25jYXQoYXJncykpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCkge1xuICAgICAgICAgIHZhciBfZW1pdHRlcjI7XG5cbiAgICAgICAgICAoX2VtaXR0ZXIyID0gdGhpcy5lbWl0dGVyKS5lbWl0LmFwcGx5KF9lbWl0dGVyMiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2VsZWN0aW9uO1xufSgpO1xuXG5mdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGRlc2NlbmRhbnQpIHtcbiAgdHJ5IHtcbiAgICAvLyBGaXJlZm94IGluc2VydHMgaW5hY2Nlc3NpYmxlIG5vZGVzIGFyb3VuZCB2aWRlbyBlbGVtZW50c1xuICAgIGRlc2NlbmRhbnQucGFyZW50Tm9kZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBJRTExIGhhcyBidWcgd2l0aCBUZXh0IG5vZGVzXG4gIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvNzgwODc0L25vZGUtY29udGFpbnMtaXMtaW5jb3JyZWN0XG4gIGlmIChkZXNjZW5kYW50IGluc3RhbmNlb2YgVGV4dCkge1xuICAgIGRlc2NlbmRhbnQgPSBkZXNjZW5kYW50LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHBhcmVudC5jb250YWlucyhkZXNjZW5kYW50KTtcbn1cblxuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gU2VsZWN0aW9uO1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBCcmVhayA9IGZ1bmN0aW9uIChfUGFyY2htZW50JEVtYmVkKSB7XG4gIF9pbmhlcml0cyhCcmVhaywgX1BhcmNobWVudCRFbWJlZCk7XG5cbiAgZnVuY3Rpb24gQnJlYWsoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyZWFrKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQnJlYWsuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCcmVhaykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJyZWFrLCBbe1xuICAgIGtleTogJ2luc2VydEludG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRJbnRvKHBhcmVudCwgcmVmKSB7XG4gICAgICBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBfZ2V0KEJyZWFrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJyZWFrLnByb3RvdHlwZSksICdpbnNlcnRJbnRvJywgdGhpcykuY2FsbCh0aGlzLCBwYXJlbnQsIHJlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xlbmd0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnJlYWs7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQpO1xuXG5CcmVhay5ibG90TmFtZSA9ICdicmVhayc7XG5CcmVhay50YWdOYW1lID0gJ0JSJztcblxuZXhwb3J0cy5kZWZhdWx0ID0gQnJlYWs7XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxpbmtlZF9saXN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbnZhciBzaGFkb3dfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBDb250YWluZXJCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250YWluZXJCbG90LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRhaW5lckJsb3QoZG9tTm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb21Ob2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5idWlsZCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG90aGVyKTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5hdHRhY2guY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQuYXR0YWNoKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgbGlua2VkX2xpc3RfMS5kZWZhdWx0KCk7XG4gICAgICAgIC8vIE5lZWQgdG8gYmUgcmV2ZXJzZWQgZm9yIGlmIERPTSBub2RlcyBhbHJlYWR5IGluIG9yZGVyXG4gICAgICAgIFtdLnNsaWNlXG4gICAgICAgICAgICAuY2FsbCh0aGlzLmRvbU5vZGUuY2hpbGROb2RlcylcbiAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IG1ha2VCbG90KG5vZGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmluc2VydEJlZm9yZShjaGlsZCwgX3RoaXMuY2hpbGRyZW4uaGVhZCB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBSZWdpc3RyeS5QYXJjaG1lbnRFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmRlbGV0ZUF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwICYmIGxlbmd0aCA9PT0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoQXQoaW5kZXgsIGxlbmd0aCwgZnVuY3Rpb24gKGNoaWxkLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgY2hpbGQuZGVsZXRlQXQob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmRlc2NlbmRhbnQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGluZGV4KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY2hpbGRyZW4uZmluZChpbmRleCksIGNoaWxkID0gX2FbMF0sIG9mZnNldCA9IF9hWzFdO1xuICAgICAgICBpZiAoKGNyaXRlcmlhLmJsb3ROYW1lID09IG51bGwgJiYgY3JpdGVyaWEoY2hpbGQpKSB8fFxuICAgICAgICAgICAgKGNyaXRlcmlhLmJsb3ROYW1lICE9IG51bGwgJiYgY2hpbGQgaW5zdGFuY2VvZiBjcml0ZXJpYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbY2hpbGQsIG9mZnNldF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBDb250YWluZXJCbG90KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuZGVzY2VuZGFudChjcml0ZXJpYSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgLTFdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5kZXNjZW5kYW50cyA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IDA7IH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7IGxlbmd0aCA9IE51bWJlci5NQVhfVkFMVUU7IH1cbiAgICAgICAgdmFyIGRlc2NlbmRhbnRzID0gW107XG4gICAgICAgIHZhciBsZW5ndGhMZWZ0ID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2hBdChpbmRleCwgbGVuZ3RoLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgoY3JpdGVyaWEuYmxvdE5hbWUgPT0gbnVsbCAmJiBjcml0ZXJpYShjaGlsZCkpIHx8XG4gICAgICAgICAgICAgICAgKGNyaXRlcmlhLmJsb3ROYW1lICE9IG51bGwgJiYgY2hpbGQgaW5zdGFuY2VvZiBjcml0ZXJpYSkpIHtcbiAgICAgICAgICAgICAgICBkZXNjZW5kYW50cy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbnRhaW5lckJsb3QpIHtcbiAgICAgICAgICAgICAgICBkZXNjZW5kYW50cyA9IGRlc2NlbmRhbnRzLmNvbmNhdChjaGlsZC5kZXNjZW5kYW50cyhjcml0ZXJpYSwgaW5kZXgsIGxlbmd0aExlZnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbmd0aExlZnQgLT0gbGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlc2NlbmRhbnRzO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5kZXRhY2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGV0YWNoLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5mb3JtYXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2hBdChpbmRleCwgbGVuZ3RoLCBmdW5jdGlvbiAoY2hpbGQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGlsZC5mb3JtYXRBdChvZmZzZXQsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmluc2VydEF0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY2hpbGRyZW4uZmluZChpbmRleCksIGNoaWxkID0gX2FbMF0sIG9mZnNldCA9IF9hWzFdO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLmluc2VydEF0KG9mZnNldCwgdmFsdWUsIGRlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYmxvdCA9IGRlZiA9PSBudWxsID8gUmVnaXN0cnkuY3JlYXRlKCd0ZXh0JywgdmFsdWUpIDogUmVnaXN0cnkuY3JlYXRlKHZhbHVlLCBkZWYpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChibG90KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKGNoaWxkQmxvdCwgcmVmQmxvdCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0aWNzLmFsbG93ZWRDaGlsZHJlbiAhPSBudWxsICYmXG4gICAgICAgICAgICAhdGhpcy5zdGF0aWNzLmFsbG93ZWRDaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZEJsb3QgaW5zdGFuY2VvZiBjaGlsZDtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVnaXN0cnkuUGFyY2htZW50RXJyb3IoXCJDYW5ub3QgaW5zZXJ0IFwiICsgY2hpbGRCbG90LnN0YXRpY3MuYmxvdE5hbWUgKyBcIiBpbnRvIFwiICsgdGhpcy5zdGF0aWNzLmJsb3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZEJsb3QuaW5zZXJ0SW50byh0aGlzLCByZWZCbG90KTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lbW8gKyBjaGlsZC5sZW5ndGgoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5tb3ZlQ2hpbGRyZW4gPSBmdW5jdGlvbiAodGFyZ2V0UGFyZW50LCByZWZOb2RlKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHRhcmdldFBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHJlZk5vZGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLm9wdGltaXplID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vcHRpbWl6ZS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRpY3MuZGVmYXVsdENoaWxkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBSZWdpc3RyeS5jcmVhdGUodGhpcy5zdGF0aWNzLmRlZmF1bHRDaGlsZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgY2hpbGQub3B0aW1pemUoY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKGluZGV4LCBpbmNsdXNpdmUpIHtcbiAgICAgICAgaWYgKGluY2x1c2l2ZSA9PT0gdm9pZCAwKSB7IGluY2x1c2l2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY2hpbGRyZW4uZmluZChpbmRleCwgaW5jbHVzaXZlKSwgY2hpbGQgPSBfYVswXSwgb2Zmc2V0ID0gX2FbMV07XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IFtbdGhpcywgaW5kZXhdXTtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQ29udGFpbmVyQmxvdCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uLmNvbmNhdChjaGlsZC5wYXRoKG9mZnNldCwgaW5jbHVzaXZlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zaXRpb24ucHVzaChbY2hpbGQsIG9mZnNldF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucmVtb3ZlKGNoaWxkKTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBDb250YWluZXJCbG90KSB7XG4gICAgICAgICAgICB0YXJnZXQubW92ZUNoaWxkcmVuKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVwbGFjZS5jYWxsKHRoaXMsIHRhcmdldCk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChpbmRleCwgZm9yY2UpIHtcbiAgICAgICAgaWYgKGZvcmNlID09PSB2b2lkIDApIHsgZm9yY2UgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoIWZvcmNlKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMubGVuZ3RoKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShhZnRlciwgdGhpcy5uZXh0KTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoQXQoaW5kZXgsIHRoaXMubGVuZ3RoKCksIGZ1bmN0aW9uIChjaGlsZCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuc3BsaXQob2Zmc2V0LCBmb3JjZSk7XG4gICAgICAgICAgICBhZnRlci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS51bndyYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubW92ZUNoaWxkcmVuKHRoaXMucGFyZW50LCB0aGlzLm5leHQpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWRkZWROb2RlcyA9IFtdO1xuICAgICAgICB2YXIgcmVtb3ZlZE5vZGVzID0gW107XG4gICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnRhcmdldCA9PT0gX3RoaXMuZG9tTm9kZSAmJiBtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgICAgIGFkZGVkTm9kZXMucHVzaC5hcHBseShhZGRlZE5vZGVzLCBtdXRhdGlvbi5hZGRlZE5vZGVzKTtcbiAgICAgICAgICAgICAgICByZW1vdmVkTm9kZXMucHVzaC5hcHBseShyZW1vdmVkTm9kZXMsIG11dGF0aW9uLnJlbW92ZWROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgbm9kZSBoYXMgYWN0dWFsbHkgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICAvLyBPbmUgZXhjZXB0aW9uIGlzIENocm9tZSBkb2VzIG5vdCBpbW1lZGlhdGVseSByZW1vdmUgSUZSQU1Fc1xuICAgICAgICAgICAgLy8gZnJvbSBET00gYnV0IE11dGF0aW9uUmVjb3JkIGlzIGNvcnJlY3QgaW4gaXRzIHJlcG9ydGVkIHJlbW92YWxcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBub2RlLnRhZ05hbWUgIT09ICdJRlJBTUUnICYmXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJsb3QgPSBSZWdpc3RyeS5maW5kKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGJsb3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoYmxvdC5kb21Ob2RlLnBhcmVudE5vZGUgPT0gbnVsbCB8fCBibG90LmRvbU5vZGUucGFyZW50Tm9kZSA9PT0gX3RoaXMuZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgIGJsb3QuZGV0YWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRlZE5vZGVzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlID09IF90aGlzLmRvbU5vZGU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPT09IGIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBpZiAoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHJlZkJsb3QgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlZkJsb3QgPSBSZWdpc3RyeS5maW5kKG5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJsb3QgPSBtYWtlQmxvdChub2RlKTtcbiAgICAgICAgICAgIGlmIChibG90Lm5leHQgIT0gcmVmQmxvdCB8fCBibG90Lm5leHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChibG90LnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb3QucGFyZW50LnJlbW92ZUNoaWxkKF90aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5zZXJ0QmVmb3JlKGJsb3QsIHJlZkJsb3QgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udGFpbmVyQmxvdDtcbn0oc2hhZG93XzEuZGVmYXVsdCkpO1xuZnVuY3Rpb24gbWFrZUJsb3Qobm9kZSkge1xuICAgIHZhciBibG90ID0gUmVnaXN0cnkuZmluZChub2RlKTtcbiAgICBpZiAoYmxvdCA9PSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBibG90ID0gUmVnaXN0cnkuY3JlYXRlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBibG90ID0gUmVnaXN0cnkuY3JlYXRlKFJlZ2lzdHJ5LlNjb3BlLklOTElORSk7XG4gICAgICAgICAgICBbXS5zbGljZS5jYWxsKG5vZGUuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgYmxvdC5kb21Ob2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYmxvdC5kb21Ob2RlLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb3QuYXR0YWNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJsb3Q7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb250YWluZXJCbG90O1xuXG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGF0dHJpYnV0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIHN0b3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcbnZhciBjb250YWluZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBGb3JtYXRCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb3JtYXRCbG90LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvcm1hdEJsb3QoZG9tTm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb21Ob2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hdHRyaWJ1dGVzID0gbmV3IHN0b3JlXzEuZGVmYXVsdChfdGhpcy5kb21Ob2RlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGb3JtYXRCbG90LmZvcm1hdHMgPSBmdW5jdGlvbiAoZG9tTm9kZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudGFnTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy50YWdOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbU5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBGb3JtYXRCbG90LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IFJlZ2lzdHJ5LnF1ZXJ5KG5hbWUpO1xuICAgICAgICBpZiAoZm9ybWF0IGluc3RhbmNlb2YgYXR0cmlidXRvcl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5hdHRyaWJ1dGUoZm9ybWF0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgIT0gbnVsbCAmJiAobmFtZSAhPT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lIHx8IHRoaXMuZm9ybWF0cygpW25hbWVdICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRm9ybWF0QmxvdC5wcm90b3R5cGUuZm9ybWF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZvcm1hdHMgPSB0aGlzLmF0dHJpYnV0ZXMudmFsdWVzKCk7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLnN0YXRpY3MuZm9ybWF0cyh0aGlzLmRvbU5vZGUpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdHNbdGhpcy5zdGF0aWNzLmJsb3ROYW1lXSA9IGZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICB9O1xuICAgIEZvcm1hdEJsb3QucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciByZXBsYWNlbWVudCA9IF9zdXBlci5wcm90b3R5cGUucmVwbGFjZVdpdGguY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5jb3B5KHJlcGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuICAgIH07XG4gICAgRm9ybWF0QmxvdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIG11dGF0aW9ucywgY29udGV4dCk7XG4gICAgICAgIGlmIChtdXRhdGlvbnMuc29tZShmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBtdXRhdGlvbi50YXJnZXQgPT09IF90aGlzLmRvbU5vZGUgJiYgbXV0YXRpb24udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnO1xuICAgICAgICB9KSkge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLmJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZvcm1hdEJsb3QucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBfc3VwZXIucHJvdG90eXBlLndyYXAuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgRm9ybWF0QmxvdCAmJiB3cmFwcGVyLnN0YXRpY3Muc2NvcGUgPT09IHRoaXMuc3RhdGljcy5zY29wZSkge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLm1vdmUod3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfTtcbiAgICByZXR1cm4gRm9ybWF0QmxvdDtcbn0oY29udGFpbmVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRm9ybWF0QmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzaGFkb3dfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBMZWFmQmxvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGVhZkJsb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGVhZkJsb3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTGVhZkJsb3QudmFsdWUgPSBmdW5jdGlvbiAoZG9tTm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIExlYWZCbG90LnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uIChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tTm9kZSA9PT0gbm9kZSB8fFxuICAgICAgICAgICAgdGhpcy5kb21Ob2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5vZGUpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihvZmZzZXQsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIExlYWZCbG90LnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgaW5jbHVzaXZlKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBbXS5pbmRleE9mLmNhbGwodGhpcy5wYXJlbnQuZG9tTm9kZS5jaGlsZE5vZGVzLCB0aGlzLmRvbU5vZGUpO1xuICAgICAgICBpZiAoaW5kZXggPiAwKVxuICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiBbdGhpcy5wYXJlbnQuZG9tTm9kZSwgb2Zmc2V0XTtcbiAgICB9O1xuICAgIExlYWZCbG90LnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX2EgPSB7fSwgX2FbdGhpcy5zdGF0aWNzLmJsb3ROYW1lXSA9IHRoaXMuc3RhdGljcy52YWx1ZSh0aGlzLmRvbU5vZGUpIHx8IHRydWUsIF9hO1xuICAgIH07XG4gICAgTGVhZkJsb3Quc2NvcGUgPSBSZWdpc3RyeS5TY29wZS5JTkxJTkVfQkxPVDtcbiAgICByZXR1cm4gTGVhZkJsb3Q7XG59KHNoYWRvd18xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IExlYWZCbG90O1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGVxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXG52YXIgbGliID0ge1xuICBhdHRyaWJ1dGVzOiB7XG4gICAgY29tcG9zZTogZnVuY3Rpb24gKGEsIGIsIGtlZXBOdWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT09ICdvYmplY3QnKSBhID0ge307XG4gICAgICBpZiAodHlwZW9mIGIgIT09ICdvYmplY3QnKSBiID0ge307XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGV4dGVuZCh0cnVlLCB7fSwgYik7XG4gICAgICBpZiAoIWtlZXBOdWxsKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGNvcHksIGtleSkge1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29weVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29weTtcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgaWYgKGFba2V5XSAhPT0gdW5kZWZpbmVkICYmIGJba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gYVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCA/IGF0dHJpYnV0ZXMgOiB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIGRpZmY6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpIGEgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgYiAhPT0gJ29iamVjdCcpIGIgPSB7fTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoYSkuY29uY2F0KE9iamVjdC5rZXlzKGIpKS5yZWR1Y2UoZnVuY3Rpb24gKGF0dHJpYnV0ZXMsIGtleSkge1xuICAgICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGJba2V5XSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGJba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgIH0sIHt9KTtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwID8gYXR0cmlidXRlcyA6IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoYSwgYiwgcHJpb3JpdHkpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpIHJldHVybiBiO1xuICAgICAgaWYgKHR5cGVvZiBiICE9PSAnb2JqZWN0JykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIGlmICghcHJpb3JpdHkpIHJldHVybiBiOyAgLy8gYiBzaW1wbHkgb3ZlcndyaXRlcyB1cyB3aXRob3V0IHByaW9yaXR5XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGIpLnJlZHVjZShmdW5jdGlvbiAoYXR0cmlidXRlcywga2V5KSB7XG4gICAgICAgIGlmIChhW2tleV0gPT09IHVuZGVmaW5lZCkgYXR0cmlidXRlc1trZXldID0gYltrZXldOyAgLy8gbnVsbCBpcyBhIHZhbGlkIHZhbHVlXG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgfSwge30pO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDAgPyBhdHRyaWJ1dGVzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcblxuICBpdGVyYXRvcjogZnVuY3Rpb24gKG9wcykge1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3Iob3BzKTtcbiAgfSxcblxuICBsZW5ndGg6IGZ1bmN0aW9uIChvcCkge1xuICAgIGlmICh0eXBlb2Ygb3BbJ2RlbGV0ZSddID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIG9wWydkZWxldGUnXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gb3AucmV0YWluO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycgPyBvcC5pbnNlcnQubGVuZ3RoIDogMTtcbiAgICB9XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gSXRlcmF0b3Iob3BzKSB7XG4gIHRoaXMub3BzID0gb3BzO1xuICB0aGlzLmluZGV4ID0gMDtcbiAgdGhpcy5vZmZzZXQgPSAwO1xufTtcblxuSXRlcmF0b3IucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBlZWtMZW5ndGgoKSA8IEluZmluaXR5O1xufTtcblxuSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gIGlmICghbGVuZ3RoKSBsZW5ndGggPSBJbmZpbml0eTtcbiAgdmFyIG5leHRPcCA9IHRoaXMub3BzW3RoaXMuaW5kZXhdO1xuICBpZiAobmV4dE9wKSB7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgIHZhciBvcExlbmd0aCA9IGxpYi5sZW5ndGgobmV4dE9wKVxuICAgIGlmIChsZW5ndGggPj0gb3BMZW5ndGggLSBvZmZzZXQpIHtcbiAgICAgIGxlbmd0aCA9IG9wTGVuZ3RoIC0gb2Zmc2V0O1xuICAgICAgdGhpcy5pbmRleCArPSAxO1xuICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV4dE9wWydkZWxldGUnXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB7ICdkZWxldGUnOiBsZW5ndGggfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJldE9wID0ge307XG4gICAgICBpZiAobmV4dE9wLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0T3AuYXR0cmlidXRlcyA9IG5leHRPcC5hdHRyaWJ1dGVzO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBuZXh0T3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXRPcC5yZXRhaW4gPSBsZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0T3AuaW5zZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXRPcC5pbnNlcnQgPSBuZXh0T3AuaW5zZXJ0LnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvZmZzZXQgc2hvdWxkID09PSAwLCBsZW5ndGggc2hvdWxkID09PSAxXG4gICAgICAgIHJldE9wLmluc2VydCA9IG5leHRPcC5pbnNlcnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0T3A7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHJldGFpbjogSW5maW5pdHkgfTtcbiAgfVxufTtcblxuSXRlcmF0b3IucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm9wc1t0aGlzLmluZGV4XTtcbn07XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5wZWVrTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5vcHNbdGhpcy5pbmRleF0pIHtcbiAgICAvLyBTaG91bGQgbmV2ZXIgcmV0dXJuIDAgaWYgb3VyIGluZGV4IGlzIGJlaW5nIG1hbmFnZWQgY29ycmVjdGx5XG4gICAgcmV0dXJuIGxpYi5sZW5ndGgodGhpcy5vcHNbdGhpcy5pbmRleF0pIC0gdGhpcy5vZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG59O1xuXG5JdGVyYXRvci5wcm90b3R5cGUucGVla1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm9wc1t0aGlzLmluZGV4XSkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHNbdGhpcy5pbmRleF1bJ2RlbGV0ZSddID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICdkZWxldGUnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMub3BzW3RoaXMuaW5kZXhdLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAncmV0YWluJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdpbnNlcnQnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJ3JldGFpbic7XG59O1xuXG5JdGVyYXRvci5wcm90b3R5cGUucmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmhhc05leHQoKSkge1xuICAgIHJldHVybiBbXTtcbiAgfSBlbHNlIGlmICh0aGlzLm9mZnNldCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLm9wcy5zbGljZSh0aGlzLmluZGV4KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB2YXIgbmV4dCA9IHRoaXMubmV4dCgpO1xuICAgIHZhciByZXN0ID0gdGhpcy5vcHMuc2xpY2UodGhpcy5pbmRleCk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHJldHVybiBbbmV4dF0uY29uY2F0KHJlc3QpO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbGliO1xuXG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGNsb25lID0gKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5zdGFuY2VvZihvYmosIHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUgIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiB0eXBlO1xufVxuXG52YXIgbmF0aXZlTWFwO1xudHJ5IHtcbiAgbmF0aXZlTWFwID0gTWFwO1xufSBjYXRjaChfKSB7XG4gIC8vIG1heWJlIGEgcmVmZXJlbmNlIGVycm9yIGJlY2F1c2Ugbm8gYE1hcGAuIEdpdmUgaXQgYSBkdW1teSB2YWx1ZSB0aGF0IG5vXG4gIC8vIHZhbHVlIHdpbGwgZXZlciBiZSBhbiBpbnN0YW5jZW9mLlxuICBuYXRpdmVNYXAgPSBmdW5jdGlvbigpIHt9O1xufVxuXG52YXIgbmF0aXZlU2V0O1xudHJ5IHtcbiAgbmF0aXZlU2V0ID0gU2V0O1xufSBjYXRjaChfKSB7XG4gIG5hdGl2ZVNldCA9IGZ1bmN0aW9uKCkge307XG59XG5cbnZhciBuYXRpdmVQcm9taXNlO1xudHJ5IHtcbiAgbmF0aXZlUHJvbWlzZSA9IFByb21pc2U7XG59IGNhdGNoKF8pIHtcbiAgbmF0aXZlUHJvbWlzZSA9IGZ1bmN0aW9uKCkge307XG59XG5cbi8qKlxuICogQ2xvbmVzIChjb3BpZXMpIGFuIE9iamVjdCB1c2luZyBkZWVwIGNvcHlpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGRlZmF1bHQsIGJ1dCBpZiB5b3UgYXJlIGNlcnRhaW5cbiAqIHRoZXJlIGFyZSBubyBjaXJjdWxhciByZWZlcmVuY2VzIGluIHlvdXIgb2JqZWN0LCB5b3UgY2FuIHNhdmUgc29tZSBDUFUgdGltZVxuICogYnkgY2FsbGluZyBjbG9uZShvYmosIGZhbHNlKS5cbiAqXG4gKiBDYXV0aW9uOiBpZiBgY2lyY3VsYXJgIGlzIGZhbHNlIGFuZCBgcGFyZW50YCBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzLFxuICogeW91ciBwcm9ncmFtIG1heSBlbnRlciBhbiBpbmZpbml0ZSBsb29wIGFuZCBjcmFzaC5cbiAqXG4gKiBAcGFyYW0gYHBhcmVudGAgLSB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxuICogQHBhcmFtIGBjaXJjdWxhcmAgLSBzZXQgdG8gdHJ1ZSBpZiB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZCBtYXkgY29udGFpblxuICogICAgY2lyY3VsYXIgcmVmZXJlbmNlcy4gKG9wdGlvbmFsIC0gdHJ1ZSBieSBkZWZhdWx0KVxuICogQHBhcmFtIGBkZXB0aGAgLSBzZXQgdG8gYSBudW1iZXIgaWYgdGhlIG9iamVjdCBpcyBvbmx5IHRvIGJlIGNsb25lZCB0b1xuICogICAgYSBwYXJ0aWN1bGFyIGRlcHRoLiAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBJbmZpbml0eSlcbiAqIEBwYXJhbSBgcHJvdG90eXBlYCAtIHNldHMgdGhlIHByb3RvdHlwZSB0byBiZSB1c2VkIHdoZW4gY2xvbmluZyBhbiBvYmplY3QuXG4gKiAgICAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBwYXJlbnQgcHJvdG90eXBlKS5cbiAqIEBwYXJhbSBgaW5jbHVkZU5vbkVudW1lcmFibGVgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAqICAgIHNob3VsZCBiZSBjbG9uZWQgYXMgd2VsbC4gTm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBvbiB0aGUgcHJvdG90eXBlXG4gKiAgICBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuIChvcHRpb25hbCAtIGZhbHNlIGJ5IGRlZmF1bHQpXG4qL1xuZnVuY3Rpb24gY2xvbmUocGFyZW50LCBjaXJjdWxhciwgZGVwdGgsIHByb3RvdHlwZSwgaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PT0gJ29iamVjdCcpIHtcbiAgICBkZXB0aCA9IGNpcmN1bGFyLmRlcHRoO1xuICAgIHByb3RvdHlwZSA9IGNpcmN1bGFyLnByb3RvdHlwZTtcbiAgICBpbmNsdWRlTm9uRW51bWVyYWJsZSA9IGNpcmN1bGFyLmluY2x1ZGVOb25FbnVtZXJhYmxlO1xuICAgIGNpcmN1bGFyID0gY2lyY3VsYXIuY2lyY3VsYXI7XG4gIH1cbiAgLy8gbWFpbnRhaW4gdHdvIGFycmF5cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcywgd2hlcmUgY29ycmVzcG9uZGluZyBwYXJlbnRzXG4gIC8vIGFuZCBjaGlsZHJlbiBoYXZlIHRoZSBzYW1lIGluZGV4XG4gIHZhciBhbGxQYXJlbnRzID0gW107XG4gIHZhciBhbGxDaGlsZHJlbiA9IFtdO1xuXG4gIHZhciB1c2VCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9ICd1bmRlZmluZWQnO1xuXG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT0gJ3VuZGVmaW5lZCcpXG4gICAgY2lyY3VsYXIgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZGVwdGggPT0gJ3VuZGVmaW5lZCcpXG4gICAgZGVwdGggPSBJbmZpbml0eTtcblxuICAvLyByZWN1cnNlIHRoaXMgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzZXQgYWxsUGFyZW50cyBhbmQgYWxsQ2hpbGRyZW5cbiAgZnVuY3Rpb24gX2Nsb25lKHBhcmVudCwgZGVwdGgpIHtcbiAgICAvLyBjbG9uaW5nIG51bGwgYWx3YXlzIHJldHVybnMgbnVsbFxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGlmIChkZXB0aCA9PT0gMClcbiAgICAgIHJldHVybiBwYXJlbnQ7XG5cbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIHByb3RvO1xuICAgIGlmICh0eXBlb2YgcGFyZW50ICE9ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZU1hcCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZU1hcCgpO1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVTZXQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVTZXQoKTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlUHJvbWlzZSkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwYXJlbnQudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJlc29sdmUoX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KF9jbG9uZShlcnIsIGRlcHRoIC0gMSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gW107XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzUmVnRXhwKHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IFJlZ0V4cChwYXJlbnQuc291cmNlLCBfX2dldFJlZ0V4cEZsYWdzKHBhcmVudCkpO1xuICAgICAgaWYgKHBhcmVudC5sYXN0SW5kZXgpIGNoaWxkLmxhc3RJbmRleCA9IHBhcmVudC5sYXN0SW5kZXg7XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzRGF0ZShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBEYXRlKHBhcmVudC5nZXRUaW1lKCkpO1xuICAgIH0gZWxzZSBpZiAodXNlQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihwYXJlbnQpKSB7XG4gICAgICBpZiAoQnVmZmVyLmFsbG9jVW5zYWZlKSB7XG4gICAgICAgIC8vIE5vZGUuanMgPj0gNC41LjBcbiAgICAgICAgY2hpbGQgPSBCdWZmZXIuYWxsb2NVbnNhZmUocGFyZW50Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbGRlciBOb2RlLmpzIHZlcnNpb25zXG4gICAgICAgIGNoaWxkID0gbmV3IEJ1ZmZlcihwYXJlbnQubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5jb3B5KGNoaWxkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgRXJyb3IpKSB7XG4gICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcbiAgICAgICAgcHJvdG8gPSBwcm90b3R5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICB2YXIgaW5kZXggPSBhbGxQYXJlbnRzLmluZGV4T2YocGFyZW50KTtcblxuICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgIHJldHVybiBhbGxDaGlsZHJlbltpbmRleF07XG4gICAgICB9XG4gICAgICBhbGxQYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIGFsbENoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZU1hcCkpIHtcbiAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIGtleUNoaWxkID0gX2Nsb25lKGtleSwgZGVwdGggLSAxKTtcbiAgICAgICAgdmFyIHZhbHVlQ2hpbGQgPSBfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSk7XG4gICAgICAgIGNoaWxkLnNldChrZXlDaGlsZCwgdmFsdWVDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlU2V0KSkge1xuICAgICAgcGFyZW50LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGVudHJ5Q2hpbGQgPSBfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSk7XG4gICAgICAgIGNoaWxkLmFkZChlbnRyeUNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gcGFyZW50KSB7XG4gICAgICB2YXIgYXR0cnM7XG4gICAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgYXR0cnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJzICYmIGF0dHJzLnNldCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2hpbGRbaV0gPSBfY2xvbmUocGFyZW50W2ldLCBkZXB0aCAtIDEpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocGFyZW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBEb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IGNsb25pbmcgYSBzeW1ib2wgYmVjYXVzZSBpdCBpcyBhIHByaW1pdGl2ZSxcbiAgICAgICAgLy8gbGlrZSBhIG51bWJlciBvciBzdHJpbmcuXG4gICAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xzW2ldO1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBzeW1ib2wpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5lbnVtZXJhYmxlICYmICFpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkW3N5bWJvbF0gPSBfY2xvbmUocGFyZW50W3N5bWJvbF0sIGRlcHRoIC0gMSk7XG4gICAgICAgIGlmICghZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBzeW1ib2wsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgIHZhciBhbGxQcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyZW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsUHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gYWxsUHJvcGVydHlOYW1lc1tpXTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRbcHJvcGVydHlOYW1lXSA9IF9jbG9uZShwYXJlbnRbcHJvcGVydHlOYW1lXSwgZGVwdGggLSAxKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICByZXR1cm4gX2Nsb25lKHBhcmVudCwgZGVwdGgpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBmbGF0IGNsb25lIHVzaW5nIHByb3RvdHlwZSwgYWNjZXB0cyBvbmx5IG9iamVjdHMsIHVzZWZ1bGwgZm9yIHByb3BlcnR5XG4gKiBvdmVycmlkZSBvbiBGTEFUIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChubyBuZXN0ZWQgcHJvcHMpLlxuICpcbiAqIFVTRSBXSVRIIENBVVRJT04hIFRoaXMgbWF5IG5vdCBiZWhhdmUgYXMgeW91IHdpc2ggaWYgeW91IGRvIG5vdCBrbm93IGhvdyB0aGlzXG4gKiB3b3Jrcy5cbiAqL1xuY2xvbmUuY2xvbmVQcm90b3R5cGUgPSBmdW5jdGlvbiBjbG9uZVByb3RvdHlwZShwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgYyA9IGZ1bmN0aW9uICgpIHt9O1xuICBjLnByb3RvdHlwZSA9IHBhcmVudDtcbiAgcmV0dXJuIG5ldyBjKCk7XG59O1xuXG4vLyBwcml2YXRlIHV0aWxpdHkgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIF9fb2JqVG9TdHIobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuY2xvbmUuX19vYmpUb1N0ciA9IF9fb2JqVG9TdHI7XG5cbmZ1bmN0aW9uIF9faXNEYXRlKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5jbG9uZS5fX2lzRGF0ZSA9IF9faXNEYXRlO1xuXG5mdW5jdGlvbiBfX2lzQXJyYXkobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5jbG9uZS5fX2lzQXJyYXkgPSBfX2lzQXJyYXk7XG5cbmZ1bmN0aW9uIF9faXNSZWdFeHAobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuY2xvbmUuX19pc1JlZ0V4cCA9IF9faXNSZWdFeHA7XG5cbmZ1bmN0aW9uIF9fZ2V0UmVnRXhwRmxhZ3MocmUpIHtcbiAgdmFyIGZsYWdzID0gJyc7XG4gIGlmIChyZS5nbG9iYWwpIGZsYWdzICs9ICdnJztcbiAgaWYgKHJlLmlnbm9yZUNhc2UpIGZsYWdzICs9ICdpJztcbiAgaWYgKHJlLm11bHRpbGluZSkgZmxhZ3MgKz0gJ20nO1xuICByZXR1cm4gZmxhZ3M7XG59XG5jbG9uZS5fX2dldFJlZ0V4cEZsYWdzID0gX19nZXRSZWdFeHBGbGFncztcblxucmV0dXJuIGNsb25lO1xufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG59XG5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX2VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2VtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW1pdHRlcik7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxudmFyIF9icmVhayA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX2JyZWFrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JyZWFrKTtcblxudmFyIF9jb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBfY29kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2RlKTtcblxudmFyIF9jb250YWluZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxudmFyIF9jb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGFpbmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBpc0xpbmUoYmxvdCkge1xuICByZXR1cm4gYmxvdCBpbnN0YW5jZW9mIF9ibG9jazIuZGVmYXVsdCB8fCBibG90IGluc3RhbmNlb2YgX2Jsb2NrLkJsb2NrRW1iZWQ7XG59XG5cbnZhciBTY3JvbGwgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRTY3JvbGwpIHtcbiAgX2luaGVyaXRzKFNjcm9sbCwgX1BhcmNobWVudCRTY3JvbGwpO1xuXG4gIGZ1bmN0aW9uIFNjcm9sbChkb21Ob2RlLCBjb25maWcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2Nyb2xsKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTY3JvbGwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JvbGwpKS5jYWxsKHRoaXMsIGRvbU5vZGUpKTtcblxuICAgIF90aGlzLmVtaXR0ZXIgPSBjb25maWcuZW1pdHRlcjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcud2hpdGVsaXN0KSkge1xuICAgICAgX3RoaXMud2hpdGVsaXN0ID0gY29uZmlnLndoaXRlbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHdoaXRlbGlzdCwgZm9ybWF0KSB7XG4gICAgICAgIHdoaXRlbGlzdFtmb3JtYXRdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHdoaXRlbGlzdDtcbiAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLy8gU29tZSByZWFzb24gZml4ZXMgY29tcG9zaXRpb24gaXNzdWVzIHdpdGggY2hhcmFjdGVyIGxhbmd1YWdlcyBpbiBXaW5kb3dzL0Nocm9tZSwgU2FmYXJpXG4gICAgX3RoaXMuZG9tTm9kZS5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgX3RoaXMub3B0aW1pemUoKTtcbiAgICBfdGhpcy5lbmFibGUoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2Nyb2xsLCBbe1xuICAgIGtleTogJ2JhdGNoU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYXRjaFN0YXJ0KCkge1xuICAgICAgdGhpcy5iYXRjaCA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYmF0Y2hFbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYXRjaEVuZCgpIHtcbiAgICAgIHRoaXMuYmF0Y2ggPSBmYWxzZTtcbiAgICAgIHRoaXMub3B0aW1pemUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUF0KGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHZhciBfbGluZSA9IHRoaXMubGluZShpbmRleCksXG4gICAgICAgICAgX2xpbmUyID0gX3NsaWNlZFRvQXJyYXkoX2xpbmUsIDIpLFxuICAgICAgICAgIGZpcnN0ID0gX2xpbmUyWzBdLFxuICAgICAgICAgIG9mZnNldCA9IF9saW5lMlsxXTtcblxuICAgICAgdmFyIF9saW5lMyA9IHRoaXMubGluZShpbmRleCArIGxlbmd0aCksXG4gICAgICAgICAgX2xpbmU0ID0gX3NsaWNlZFRvQXJyYXkoX2xpbmUzLCAxKSxcbiAgICAgICAgICBsYXN0ID0gX2xpbmU0WzBdO1xuXG4gICAgICBfZ2V0KFNjcm9sbC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JvbGwucHJvdG90eXBlKSwgJ2RlbGV0ZUF0JywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgIGlmIChsYXN0ICE9IG51bGwgJiYgZmlyc3QgIT09IGxhc3QgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBfYmxvY2suQmxvY2tFbWJlZCB8fCBsYXN0IGluc3RhbmNlb2YgX2Jsb2NrLkJsb2NrRW1iZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGltaXplKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIF9jb2RlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgdmFyIG5ld2xpbmVJbmRleCA9IGZpcnN0Lm5ld2xpbmVJbmRleChmaXJzdC5sZW5ndGgoKSwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKG5ld2xpbmVJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBmaXJzdCA9IGZpcnN0LnNwbGl0KG5ld2xpbmVJbmRleCArIDEpO1xuICAgICAgICAgICAgaWYgKGZpcnN0ID09PSBsYXN0KSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW1pemUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsYXN0IGluc3RhbmNlb2YgX2NvZGUyLmRlZmF1bHQpIHtcbiAgICAgICAgICB2YXIgX25ld2xpbmVJbmRleCA9IGxhc3QubmV3bGluZUluZGV4KDApO1xuICAgICAgICAgIGlmIChfbmV3bGluZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGxhc3Quc3BsaXQoX25ld2xpbmVJbmRleCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gbGFzdC5jaGlsZHJlbi5oZWFkIGluc3RhbmNlb2YgX2JyZWFrMi5kZWZhdWx0ID8gbnVsbCA6IGxhc3QuY2hpbGRyZW4uaGVhZDtcbiAgICAgICAgZmlyc3QubW92ZUNoaWxkcmVuKGxhc3QsIHJlZik7XG4gICAgICAgIGZpcnN0LnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpbWl6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHZhciBlbmFibGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgICB0aGlzLmRvbU5vZGUuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCBlbmFibGVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIGZvcm1hdCwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLndoaXRlbGlzdCAhPSBudWxsICYmICF0aGlzLndoaXRlbGlzdFtmb3JtYXRdKSByZXR1cm47XG4gICAgICBfZ2V0KFNjcm9sbC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JvbGwucHJvdG90eXBlKSwgJ2Zvcm1hdEF0JywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoLCBmb3JtYXQsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW1pemUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICBpZiAoZGVmICE9IG51bGwgJiYgdGhpcy53aGl0ZWxpc3QgIT0gbnVsbCAmJiAhdGhpcy53aGl0ZWxpc3RbdmFsdWVdKSByZXR1cm47XG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICBpZiAoZGVmID09IG51bGwgfHwgX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeSh2YWx1ZSwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSykgPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBibG90ID0gX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUodGhpcy5zdGF0aWNzLmRlZmF1bHRDaGlsZCk7XG4gICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChibG90KTtcbiAgICAgICAgICBpZiAoZGVmID09IG51bGwgJiYgdmFsdWUuZW5kc1dpdGgoJ1xcbicpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYmxvdC5pbnNlcnRBdCgwLCB2YWx1ZSwgZGVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZW1iZWQgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh2YWx1ZSwgZGVmKTtcbiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGVtYmVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChTY3JvbGwucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksICdpbnNlcnRBdCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIHZhbHVlLCBkZWYpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpbWl6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEJlZm9yZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShibG90LCByZWYpIHtcbiAgICAgIGlmIChibG90LnN0YXRpY3Muc2NvcGUgPT09IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuSU5MSU5FX0JMT1QpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh0aGlzLnN0YXRpY3MuZGVmYXVsdENoaWxkKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChibG90KTtcbiAgICAgICAgYmxvdCA9IHdyYXBwZXI7XG4gICAgICB9XG4gICAgICBfZ2V0KFNjcm9sbC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JvbGwucHJvdG90eXBlKSwgJ2luc2VydEJlZm9yZScsIHRoaXMpLmNhbGwodGhpcywgYmxvdCwgcmVmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsZWFmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVhZihpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aChpbmRleCkucG9wKCkgfHwgW251bGwsIC0xXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsaW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluZShpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmUoaW5kZXggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRlc2NlbmRhbnQoaXNMaW5lLCBpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGluZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lcygpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgIHZhciBnZXRMaW5lcyA9IGZ1bmN0aW9uIGdldExpbmVzKGJsb3QsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gW10sXG4gICAgICAgICAgICBsZW5ndGhMZWZ0ID0gbGVuZ3RoO1xuICAgICAgICBibG90LmNoaWxkcmVuLmZvckVhY2hBdChpbmRleCwgbGVuZ3RoLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoaXNMaW5lKGNoaWxkKSkge1xuICAgICAgICAgICAgbGluZXMucHVzaChjaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIF9wYXJjaG1lbnQyLmRlZmF1bHQuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBsaW5lcyA9IGxpbmVzLmNvbmNhdChnZXRMaW5lcyhjaGlsZCwgaW5kZXgsIGxlbmd0aExlZnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoTGVmdCAtPSBsZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGdldExpbmVzKHRoaXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29wdGltaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW1pemUoKSB7XG4gICAgICB2YXIgbXV0YXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgaWYgKHRoaXMuYmF0Y2ggPT09IHRydWUpIHJldHVybjtcbiAgICAgIF9nZXQoU2Nyb2xsLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCAnb3B0aW1pemUnLCB0aGlzKS5jYWxsKHRoaXMsIG11dGF0aW9ucywgY29udGV4dCk7XG4gICAgICBpZiAobXV0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoX2VtaXR0ZXIyLmRlZmF1bHQuZXZlbnRzLlNDUk9MTF9PUFRJTUlaRSwgbXV0YXRpb25zLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwYXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aChpbmRleCkge1xuICAgICAgcmV0dXJuIF9nZXQoU2Nyb2xsLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCAncGF0aCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgpLnNsaWNlKDEpOyAvLyBFeGNsdWRlIHNlbGZcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUobXV0YXRpb25zKSB7XG4gICAgICBpZiAodGhpcy5iYXRjaCA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgICAgdmFyIHNvdXJjZSA9IF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUjtcbiAgICAgIGlmICh0eXBlb2YgbXV0YXRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBzb3VyY2UgPSBtdXRhdGlvbnM7XG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobXV0YXRpb25zKSkge1xuICAgICAgICBtdXRhdGlvbnMgPSB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICB9XG4gICAgICBpZiAobXV0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoX2VtaXR0ZXIyLmRlZmF1bHQuZXZlbnRzLlNDUk9MTF9CRUZPUkVfVVBEQVRFLCBzb3VyY2UsIG11dGF0aW9ucyk7XG4gICAgICB9XG4gICAgICBfZ2V0KFNjcm9sbC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JvbGwucHJvdG90eXBlKSwgJ3VwZGF0ZScsIHRoaXMpLmNhbGwodGhpcywgbXV0YXRpb25zLmNvbmNhdChbXSkpOyAvLyBwYXNzIGNvcHlcbiAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChfZW1pdHRlcjIuZGVmYXVsdC5ldmVudHMuU0NST0xMX1VQREFURSwgc291cmNlLCBtdXRhdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY3JvbGw7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuU2Nyb2xsKTtcblxuU2Nyb2xsLmJsb3ROYW1lID0gJ3Njcm9sbCc7XG5TY3JvbGwuY2xhc3NOYW1lID0gJ3FsLWVkaXRvcic7XG5TY3JvbGwudGFnTmFtZSA9ICdESVYnO1xuU2Nyb2xsLmRlZmF1bHRDaGlsZCA9ICdibG9jayc7XG5TY3JvbGwuYWxsb3dlZENoaWxkcmVuID0gW19ibG9jazIuZGVmYXVsdCwgX2Jsb2NrLkJsb2NrRW1iZWQsIF9jb250YWluZXIyLmRlZmF1bHRdO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTY3JvbGw7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU0hPUlRLRVkgPSBleHBvcnRzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2Nsb25lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbnZhciBfY2xvbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvbmUpO1xuXG52YXIgX2RlZXBFcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX2V4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZXh0ZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZCk7XG5cbnZhciBfcXVpbGxEZWx0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfcXVpbGxEZWx0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbERlbHRhKTtcblxudmFyIF9vcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG52YXIgX29wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29wKTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX3F1aWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9xdWlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbCk7XG5cbnZhciBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ2dlcik7XG5cbnZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgZGVidWcgPSAoMCwgX2xvZ2dlcjIuZGVmYXVsdCkoJ3F1aWxsOmtleWJvYXJkJyk7XG5cbnZhciBTSE9SVEtFWSA9IC9NYWMvaS50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgPyAnbWV0YUtleScgOiAnY3RybEtleSc7XG5cbnZhciBLZXlib2FyZCA9IGZ1bmN0aW9uIChfTW9kdWxlKSB7XG4gIF9pbmhlcml0cyhLZXlib2FyZCwgX01vZHVsZSk7XG5cbiAgX2NyZWF0ZUNsYXNzKEtleWJvYXJkLCBudWxsLCBbe1xuICAgIGtleTogJ21hdGNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2goZXZ0LCBiaW5kaW5nKSB7XG4gICAgICBiaW5kaW5nID0gbm9ybWFsaXplKGJpbmRpbmcpO1xuICAgICAgaWYgKFsnYWx0S2V5JywgJ2N0cmxLZXknLCAnbWV0YUtleScsICdzaGlmdEtleSddLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gISFiaW5kaW5nW2tleV0gIT09IGV2dFtrZXldICYmIGJpbmRpbmdba2V5XSAhPT0gbnVsbDtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5kaW5nLmtleSA9PT0gKGV2dC53aGljaCB8fCBldnQua2V5Q29kZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gS2V5Ym9hcmQocXVpbGwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5Ym9hcmQpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEtleWJvYXJkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoS2V5Ym9hcmQpKS5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF90aGlzLm9wdGlvbnMuYmluZGluZ3MpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lID09PSAnbGlzdCBhdXRvZmlsbCcgJiYgcXVpbGwuc2Nyb2xsLndoaXRlbGlzdCAhPSBudWxsICYmICFxdWlsbC5zY3JvbGwud2hpdGVsaXN0WydsaXN0J10pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLm9wdGlvbnMuYmluZGluZ3NbbmFtZV0pIHtcbiAgICAgICAgX3RoaXMuYWRkQmluZGluZyhfdGhpcy5vcHRpb25zLmJpbmRpbmdzW25hbWVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpcy5hZGRCaW5kaW5nKHsga2V5OiBLZXlib2FyZC5rZXlzLkVOVEVSLCBzaGlmdEtleTogbnVsbCB9LCBoYW5kbGVFbnRlcik7XG4gICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5FTlRFUiwgbWV0YUtleTogbnVsbCwgY3RybEtleTogbnVsbCwgYWx0S2V5OiBudWxsIH0sIGZ1bmN0aW9uICgpIHt9KTtcbiAgICBpZiAoL0ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAvLyBOZWVkIHRvIGhhbmRsZSBkZWxldGUgYW5kIGJhY2tzcGFjZSBmb3IgRmlyZWZveCBpbiB0aGUgZ2VuZXJhbCBjYXNlICMxMTcxXG4gICAgICBfdGhpcy5hZGRCaW5kaW5nKHsga2V5OiBLZXlib2FyZC5rZXlzLkJBQ0tTUEFDRSB9LCB7IGNvbGxhcHNlZDogdHJ1ZSB9LCBoYW5kbGVCYWNrc3BhY2UpO1xuICAgICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5ERUxFVEUgfSwgeyBjb2xsYXBzZWQ6IHRydWUgfSwgaGFuZGxlRGVsZXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5CQUNLU1BBQ0UgfSwgeyBjb2xsYXBzZWQ6IHRydWUsIHByZWZpeDogL14uPyQvIH0sIGhhbmRsZUJhY2tzcGFjZSk7XG4gICAgICBfdGhpcy5hZGRCaW5kaW5nKHsga2V5OiBLZXlib2FyZC5rZXlzLkRFTEVURSB9LCB7IGNvbGxhcHNlZDogdHJ1ZSwgc3VmZml4OiAvXi4/JC8gfSwgaGFuZGxlRGVsZXRlKTtcbiAgICB9XG4gICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5CQUNLU1BBQ0UgfSwgeyBjb2xsYXBzZWQ6IGZhbHNlIH0sIGhhbmRsZURlbGV0ZVJhbmdlKTtcbiAgICBfdGhpcy5hZGRCaW5kaW5nKHsga2V5OiBLZXlib2FyZC5rZXlzLkRFTEVURSB9LCB7IGNvbGxhcHNlZDogZmFsc2UgfSwgaGFuZGxlRGVsZXRlUmFuZ2UpO1xuICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuQkFDS1NQQUNFLCBhbHRLZXk6IG51bGwsIGN0cmxLZXk6IG51bGwsIG1ldGFLZXk6IG51bGwsIHNoaWZ0S2V5OiBudWxsIH0sIHsgY29sbGFwc2VkOiB0cnVlLCBvZmZzZXQ6IDAgfSwgaGFuZGxlQmFja3NwYWNlKTtcbiAgICBfdGhpcy5saXN0ZW4oKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoS2V5Ym9hcmQsIFt7XG4gICAga2V5OiAnYWRkQmluZGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEJpbmRpbmcoa2V5KSB7XG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgaGFuZGxlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHZhciBiaW5kaW5nID0gbm9ybWFsaXplKGtleSk7XG4gICAgICBpZiAoYmluZGluZyA9PSBudWxsIHx8IGJpbmRpbmcua2V5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRlYnVnLndhcm4oJ0F0dGVtcHRlZCB0byBhZGQgaW52YWxpZCBrZXlib2FyZCBiaW5kaW5nJywgYmluZGluZyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29udGV4dCA9IHsgaGFuZGxlcjogY29udGV4dCB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGhhbmRsZXIgPSB7IGhhbmRsZXI6IGhhbmRsZXIgfTtcbiAgICAgIH1cbiAgICAgIGJpbmRpbmcgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkoYmluZGluZywgY29udGV4dCwgaGFuZGxlcik7XG4gICAgICB0aGlzLmJpbmRpbmdzW2JpbmRpbmcua2V5XSA9IHRoaXMuYmluZGluZ3NbYmluZGluZy5rZXldIHx8IFtdO1xuICAgICAgdGhpcy5iaW5kaW5nc1tiaW5kaW5nLmtleV0ucHVzaChiaW5kaW5nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsaXN0ZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW4oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5xdWlsbC5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGlmIChldnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgICB2YXIgd2hpY2ggPSBldnQud2hpY2ggfHwgZXZ0LmtleUNvZGU7XG4gICAgICAgIHZhciBiaW5kaW5ncyA9IChfdGhpczIuYmluZGluZ3Nbd2hpY2hdIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICByZXR1cm4gS2V5Ym9hcmQubWF0Y2goZXZ0LCBiaW5kaW5nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChiaW5kaW5ncy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMyLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAocmFuZ2UgPT0gbnVsbCB8fCAhX3RoaXMyLnF1aWxsLmhhc0ZvY3VzKCkpIHJldHVybjtcblxuICAgICAgICB2YXIgX3F1aWxsJGdldExpbmUgPSBfdGhpczIucXVpbGwuZ2V0TGluZShyYW5nZS5pbmRleCksXG4gICAgICAgICAgICBfcXVpbGwkZ2V0TGluZTIgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGluZSwgMiksXG4gICAgICAgICAgICBsaW5lID0gX3F1aWxsJGdldExpbmUyWzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3F1aWxsJGdldExpbmUyWzFdO1xuXG4gICAgICAgIHZhciBfcXVpbGwkZ2V0TGVhZiA9IF90aGlzMi5xdWlsbC5nZXRMZWFmKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgIF9xdWlsbCRnZXRMZWFmMiA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMZWFmLCAyKSxcbiAgICAgICAgICAgIGxlYWZTdGFydCA9IF9xdWlsbCRnZXRMZWFmMlswXSxcbiAgICAgICAgICAgIG9mZnNldFN0YXJ0ID0gX3F1aWxsJGdldExlYWYyWzFdO1xuXG4gICAgICAgIHZhciBfcmVmID0gcmFuZ2UubGVuZ3RoID09PSAwID8gW2xlYWZTdGFydCwgb2Zmc2V0U3RhcnRdIDogX3RoaXMyLnF1aWxsLmdldExlYWYocmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGgpLFxuICAgICAgICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgIGxlYWZFbmQgPSBfcmVmMlswXSxcbiAgICAgICAgICAgIG9mZnNldEVuZCA9IF9yZWYyWzFdO1xuXG4gICAgICAgIHZhciBwcmVmaXhUZXh0ID0gbGVhZlN0YXJ0IGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5UZXh0ID8gbGVhZlN0YXJ0LnZhbHVlKCkuc2xpY2UoMCwgb2Zmc2V0U3RhcnQpIDogJyc7XG4gICAgICAgIHZhciBzdWZmaXhUZXh0ID0gbGVhZkVuZCBpbnN0YW5jZW9mIF9wYXJjaG1lbnQyLmRlZmF1bHQuVGV4dCA/IGxlYWZFbmQudmFsdWUoKS5zbGljZShvZmZzZXRFbmQpIDogJyc7XG4gICAgICAgIHZhciBjdXJDb250ZXh0ID0ge1xuICAgICAgICAgIGNvbGxhcHNlZDogcmFuZ2UubGVuZ3RoID09PSAwLFxuICAgICAgICAgIGVtcHR5OiByYW5nZS5sZW5ndGggPT09IDAgJiYgbGluZS5sZW5ndGgoKSA8PSAxLFxuICAgICAgICAgIGZvcm1hdDogX3RoaXMyLnF1aWxsLmdldEZvcm1hdChyYW5nZSksXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgcHJlZml4OiBwcmVmaXhUZXh0LFxuICAgICAgICAgIHN1ZmZpeDogc3VmZml4VGV4dFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcHJldmVudGVkID0gYmluZGluZ3Muc29tZShmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICAgIGlmIChiaW5kaW5nLmNvbGxhcHNlZCAhPSBudWxsICYmIGJpbmRpbmcuY29sbGFwc2VkICE9PSBjdXJDb250ZXh0LmNvbGxhcHNlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGlmIChiaW5kaW5nLmVtcHR5ICE9IG51bGwgJiYgYmluZGluZy5lbXB0eSAhPT0gY3VyQ29udGV4dC5lbXB0eSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGlmIChiaW5kaW5nLm9mZnNldCAhPSBudWxsICYmIGJpbmRpbmcub2Zmc2V0ICE9PSBjdXJDb250ZXh0Lm9mZnNldCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmcuZm9ybWF0KSkge1xuICAgICAgICAgICAgLy8gYW55IGZvcm1hdCBpcyBwcmVzZW50XG4gICAgICAgICAgICBpZiAoYmluZGluZy5mb3JtYXQuZXZlcnkoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGN1ckNvbnRleHQuZm9ybWF0W25hbWVdID09IG51bGw7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGJpbmRpbmcuZm9ybWF0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIGFsbCBmb3JtYXRzIG11c3QgbWF0Y2hcbiAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoYmluZGluZy5mb3JtYXQpLmV2ZXJ5KGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgIGlmIChiaW5kaW5nLmZvcm1hdFtuYW1lXSA9PT0gdHJ1ZSkgcmV0dXJuIGN1ckNvbnRleHQuZm9ybWF0W25hbWVdICE9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChiaW5kaW5nLmZvcm1hdFtuYW1lXSA9PT0gZmFsc2UpIHJldHVybiBjdXJDb250ZXh0LmZvcm1hdFtuYW1lXSA9PSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIF9kZWVwRXF1YWwyLmRlZmF1bHQpKGJpbmRpbmcuZm9ybWF0W25hbWVdLCBjdXJDb250ZXh0LmZvcm1hdFtuYW1lXSk7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiaW5kaW5nLnByZWZpeCAhPSBudWxsICYmICFiaW5kaW5nLnByZWZpeC50ZXN0KGN1ckNvbnRleHQucHJlZml4KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGlmIChiaW5kaW5nLnN1ZmZpeCAhPSBudWxsICYmICFiaW5kaW5nLnN1ZmZpeC50ZXN0KGN1ckNvbnRleHQuc3VmZml4KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHJldHVybiBiaW5kaW5nLmhhbmRsZXIuY2FsbChfdGhpczIsIHJhbmdlLCBjdXJDb250ZXh0KSAhPT0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcmV2ZW50ZWQpIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEtleWJvYXJkO1xufShfbW9kdWxlMi5kZWZhdWx0KTtcblxuS2V5Ym9hcmQua2V5cyA9IHtcbiAgQkFDS1NQQUNFOiA4LFxuICBUQUI6IDksXG4gIEVOVEVSOiAxMyxcbiAgRVNDQVBFOiAyNyxcbiAgTEVGVDogMzcsXG4gIFVQOiAzOCxcbiAgUklHSFQ6IDM5LFxuICBET1dOOiA0MCxcbiAgREVMRVRFOiA0NlxufTtcblxuS2V5Ym9hcmQuREVGQVVMVFMgPSB7XG4gIGJpbmRpbmdzOiB7XG4gICAgJ2JvbGQnOiBtYWtlRm9ybWF0SGFuZGxlcignYm9sZCcpLFxuICAgICdpdGFsaWMnOiBtYWtlRm9ybWF0SGFuZGxlcignaXRhbGljJyksXG4gICAgJ3VuZGVybGluZSc6IG1ha2VGb3JtYXRIYW5kbGVyKCd1bmRlcmxpbmUnKSxcbiAgICAnaW5kZW50Jzoge1xuICAgICAgLy8gaGlnaGxpZ2h0IHRhYiBvciB0YWIgYXQgYmVnaW5uaW5nIG9mIGxpc3QsIGluZGVudCBvciBibG9ja3F1b3RlXG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuVEFCLFxuICAgICAgZm9ybWF0OiBbJ2Jsb2NrcXVvdGUnLCAnaW5kZW50JywgJ2xpc3QnXSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY29sbGFwc2VkICYmIGNvbnRleHQub2Zmc2V0ICE9PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2luZGVudCcsICcrMScsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ291dGRlbnQnOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuVEFCLFxuICAgICAgc2hpZnRLZXk6IHRydWUsXG4gICAgICBmb3JtYXQ6IFsnYmxvY2txdW90ZScsICdpbmRlbnQnLCAnbGlzdCddLFxuICAgICAgLy8gaGlnaGxpZ2h0IHRhYiBvciB0YWIgYXQgYmVnaW5uaW5nIG9mIGxpc3QsIGluZGVudCBvciBibG9ja3F1b3RlXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNvbGxhcHNlZCAmJiBjb250ZXh0Lm9mZnNldCAhPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdpbmRlbnQnLCAnLTEnLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdvdXRkZW50IGJhY2tzcGFjZSc6IHtcbiAgICAgIGtleTogS2V5Ym9hcmQua2V5cy5CQUNLU1BBQ0UsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBzaGlmdEtleTogbnVsbCxcbiAgICAgIG1ldGFLZXk6IG51bGwsXG4gICAgICBjdHJsS2V5OiBudWxsLFxuICAgICAgYWx0S2V5OiBudWxsLFxuICAgICAgZm9ybWF0OiBbJ2luZGVudCcsICdsaXN0J10sXG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmZvcm1hdC5pbmRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdpbmRlbnQnLCAnLTEnLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmZvcm1hdC5saXN0ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGlzdCcsIGZhbHNlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2luZGVudCBjb2RlLWJsb2NrJzogbWFrZUNvZGVCbG9ja0hhbmRsZXIodHJ1ZSksXG4gICAgJ291dGRlbnQgY29kZS1ibG9jayc6IG1ha2VDb2RlQmxvY2tIYW5kbGVyKGZhbHNlKSxcbiAgICAncmVtb3ZlIHRhYic6IHtcbiAgICAgIGtleTogS2V5Ym9hcmQua2V5cy5UQUIsXG4gICAgICBzaGlmdEtleTogdHJ1ZSxcbiAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgIHByZWZpeDogL1xcdCQvLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSkge1xuICAgICAgICB0aGlzLnF1aWxsLmRlbGV0ZVRleHQocmFuZ2UuaW5kZXggLSAxLCAxLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICd0YWInOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuVEFCLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSkge1xuICAgICAgICB0aGlzLnF1aWxsLmhpc3RvcnkuY3V0b2ZmKCk7XG4gICAgICAgIHZhciBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihyYW5nZS5pbmRleCkuZGVsZXRlKHJhbmdlLmxlbmd0aCkuaW5zZXJ0KCdcXHQnKTtcbiAgICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIHRoaXMucXVpbGwuaGlzdG9yeS5jdXRvZmYoKTtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggKyAxLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2xpc3QgZW1wdHkgZW50ZXInOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuRU5URVIsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBmb3JtYXQ6IFsnbGlzdCddLFxuICAgICAgZW1wdHk6IHRydWUsXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaXN0JywgZmFsc2UsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICBpZiAoY29udGV4dC5mb3JtYXQuaW5kZW50KSB7XG4gICAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2luZGVudCcsIGZhbHNlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2NoZWNrbGlzdCBlbnRlcic6IHtcbiAgICAgIGtleTogS2V5Ym9hcmQua2V5cy5FTlRFUixcbiAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgIGZvcm1hdDogeyBsaXN0OiAnY2hlY2tlZCcgfSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UpIHtcbiAgICAgICAgdmFyIF9xdWlsbCRnZXRMaW5lMyA9IHRoaXMucXVpbGwuZ2V0TGluZShyYW5nZS5pbmRleCksXG4gICAgICAgICAgICBfcXVpbGwkZ2V0TGluZTQgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGluZTMsIDIpLFxuICAgICAgICAgICAgbGluZSA9IF9xdWlsbCRnZXRMaW5lNFswXSxcbiAgICAgICAgICAgIG9mZnNldCA9IF9xdWlsbCRnZXRMaW5lNFsxXTtcblxuICAgICAgICB2YXIgZm9ybWF0cyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KSh7fSwgbGluZS5mb3JtYXRzKCksIHsgbGlzdDogJ2NoZWNrZWQnIH0pO1xuICAgICAgICB2YXIgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpLmluc2VydCgnXFxuJywgZm9ybWF0cykucmV0YWluKGxpbmUubGVuZ3RoKCkgLSBvZmZzZXQgLSAxKS5yZXRhaW4oMSwgeyBsaXN0OiAndW5jaGVja2VkJyB9KTtcbiAgICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgICAgdGhpcy5xdWlsbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2hlYWRlciBlbnRlcic6IHtcbiAgICAgIGtleTogS2V5Ym9hcmQua2V5cy5FTlRFUixcbiAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgIGZvcm1hdDogWydoZWFkZXInXSxcbiAgICAgIHN1ZmZpeDogL14kLyxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF9xdWlsbCRnZXRMaW5lNSA9IHRoaXMucXVpbGwuZ2V0TGluZShyYW5nZS5pbmRleCksXG4gICAgICAgICAgICBfcXVpbGwkZ2V0TGluZTYgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGluZTUsIDIpLFxuICAgICAgICAgICAgbGluZSA9IF9xdWlsbCRnZXRMaW5lNlswXSxcbiAgICAgICAgICAgIG9mZnNldCA9IF9xdWlsbCRnZXRMaW5lNlsxXTtcblxuICAgICAgICB2YXIgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpLmluc2VydCgnXFxuJywgY29udGV4dC5mb3JtYXQpLnJldGFpbihsaW5lLmxlbmd0aCgpIC0gb2Zmc2V0IC0gMSkucmV0YWluKDEsIHsgaGVhZGVyOiBudWxsIH0pO1xuICAgICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggKyAxLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgICB0aGlzLnF1aWxsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnbGlzdCBhdXRvZmlsbCc6IHtcbiAgICAgIGtleTogJyAnLFxuICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgZm9ybWF0OiB7IGxpc3Q6IGZhbHNlIH0sXG4gICAgICBwcmVmaXg6IC9eXFxzKj8oXFxkK1xcLnwtfFxcKnxcXFsgP1xcXXxcXFt4XFxdKSQvLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gY29udGV4dC5wcmVmaXgubGVuZ3RoO1xuXG4gICAgICAgIHZhciBfcXVpbGwkZ2V0TGluZTcgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgICAgX3F1aWxsJGdldExpbmU4ID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmU3LCAyKSxcbiAgICAgICAgICAgIGxpbmUgPSBfcXVpbGwkZ2V0TGluZThbMF0sXG4gICAgICAgICAgICBvZmZzZXQgPSBfcXVpbGwkZ2V0TGluZThbMV07XG5cbiAgICAgICAgaWYgKG9mZnNldCA+IGxlbmd0aCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgc3dpdGNoIChjb250ZXh0LnByZWZpeC50cmltKCkpIHtcbiAgICAgICAgICBjYXNlICdbXSc6Y2FzZSAnWyBdJzpcbiAgICAgICAgICAgIHZhbHVlID0gJ3VuY2hlY2tlZCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdbeF0nOlxuICAgICAgICAgICAgdmFsdWUgPSAnY2hlY2tlZCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICctJzpjYXNlICcqJzpcbiAgICAgICAgICAgIHZhbHVlID0gJ2J1bGxldCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsdWUgPSAnb3JkZXJlZCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWlsbC5pbnNlcnRUZXh0KHJhbmdlLmluZGV4LCAnICcsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB0aGlzLnF1aWxsLmhpc3RvcnkuY3V0b2ZmKCk7XG4gICAgICAgIHZhciBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihyYW5nZS5pbmRleCAtIG9mZnNldCkuZGVsZXRlKGxlbmd0aCArIDEpLnJldGFpbihsaW5lLmxlbmd0aCgpIC0gMiAtIG9mZnNldCkucmV0YWluKDEsIHsgbGlzdDogdmFsdWUgfSk7XG4gICAgICAgIHRoaXMucXVpbGwudXBkYXRlQ29udGVudHMoZGVsdGEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB0aGlzLnF1aWxsLmhpc3RvcnkuY3V0b2ZmKCk7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4IC0gbGVuZ3RoLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2NvZGUgZXhpdCc6IHtcbiAgICAgIGtleTogS2V5Ym9hcmQua2V5cy5FTlRFUixcbiAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgIGZvcm1hdDogWydjb2RlLWJsb2NrJ10sXG4gICAgICBwcmVmaXg6IC9cXG5cXG4kLyxcbiAgICAgIHN1ZmZpeDogL15cXHMrJC8sXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlKSB7XG4gICAgICAgIHZhciBfcXVpbGwkZ2V0TGluZTkgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgICAgX3F1aWxsJGdldExpbmUxMCA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMaW5lOSwgMiksXG4gICAgICAgICAgICBsaW5lID0gX3F1aWxsJGdldExpbmUxMFswXSxcbiAgICAgICAgICAgIG9mZnNldCA9IF9xdWlsbCRnZXRMaW5lMTBbMV07XG5cbiAgICAgICAgdmFyIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKHJhbmdlLmluZGV4ICsgbGluZS5sZW5ndGgoKSAtIG9mZnNldCAtIDIpLnJldGFpbigxLCB7ICdjb2RlLWJsb2NrJzogbnVsbCB9KS5kZWxldGUoMSk7XG4gICAgICAgIHRoaXMucXVpbGwudXBkYXRlQ29udGVudHMoZGVsdGEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2VtYmVkIGxlZnQnOiBtYWtlRW1iZWRBcnJvd0hhbmRsZXIoS2V5Ym9hcmQua2V5cy5MRUZULCBmYWxzZSksXG4gICAgJ2VtYmVkIGxlZnQgc2hpZnQnOiBtYWtlRW1iZWRBcnJvd0hhbmRsZXIoS2V5Ym9hcmQua2V5cy5MRUZULCB0cnVlKSxcbiAgICAnZW1iZWQgcmlnaHQnOiBtYWtlRW1iZWRBcnJvd0hhbmRsZXIoS2V5Ym9hcmQua2V5cy5SSUdIVCwgZmFsc2UpLFxuICAgICdlbWJlZCByaWdodCBzaGlmdCc6IG1ha2VFbWJlZEFycm93SGFuZGxlcihLZXlib2FyZC5rZXlzLlJJR0hULCB0cnVlKVxuICB9XG59O1xuXG5mdW5jdGlvbiBtYWtlRW1iZWRBcnJvd0hhbmRsZXIoa2V5LCBzaGlmdEtleSkge1xuICB2YXIgX3JlZjM7XG5cbiAgdmFyIHdoZXJlID0ga2V5ID09PSBLZXlib2FyZC5rZXlzLkxFRlQgPyAncHJlZml4JyA6ICdzdWZmaXgnO1xuICByZXR1cm4gX3JlZjMgPSB7XG4gICAga2V5OiBrZXksXG4gICAgc2hpZnRLZXk6IHNoaWZ0S2V5LFxuICAgIGFsdEtleTogbnVsbFxuICB9LCBfZGVmaW5lUHJvcGVydHkoX3JlZjMsIHdoZXJlLCAvXiQvKSwgX2RlZmluZVByb3BlcnR5KF9yZWYzLCAnaGFuZGxlcicsIGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UpIHtcbiAgICB2YXIgaW5kZXggPSByYW5nZS5pbmRleDtcbiAgICBpZiAoa2V5ID09PSBLZXlib2FyZC5rZXlzLlJJR0hUKSB7XG4gICAgICBpbmRleCArPSByYW5nZS5sZW5ndGggKyAxO1xuICAgIH1cblxuICAgIHZhciBfcXVpbGwkZ2V0TGVhZjMgPSB0aGlzLnF1aWxsLmdldExlYWYoaW5kZXgpLFxuICAgICAgICBfcXVpbGwkZ2V0TGVhZjQgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGVhZjMsIDEpLFxuICAgICAgICBsZWFmID0gX3F1aWxsJGdldExlYWY0WzBdO1xuXG4gICAgaWYgKCEobGVhZiBpbnN0YW5jZW9mIF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoa2V5ID09PSBLZXlib2FyZC5rZXlzLkxFRlQpIHtcbiAgICAgIGlmIChzaGlmdEtleSkge1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCAtIDEsIHJhbmdlLmxlbmd0aCArIDEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggLSAxLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNoaWZ0S2V5KSB7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4LCByYW5nZS5sZW5ndGggKyAxLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgcmFuZ2UubGVuZ3RoICsgMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSksIF9yZWYzO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVCYWNrc3BhY2UocmFuZ2UsIGNvbnRleHQpIHtcbiAgaWYgKHJhbmdlLmluZGV4ID09PSAwIHx8IHRoaXMucXVpbGwuZ2V0TGVuZ3RoKCkgPD0gMSkgcmV0dXJuO1xuXG4gIHZhciBfcXVpbGwkZ2V0TGluZTExID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgIF9xdWlsbCRnZXRMaW5lMTIgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGluZTExLCAxKSxcbiAgICAgIGxpbmUgPSBfcXVpbGwkZ2V0TGluZTEyWzBdO1xuXG4gIHZhciBmb3JtYXRzID0ge307XG4gIGlmIChjb250ZXh0Lm9mZnNldCA9PT0gMCkge1xuICAgIHZhciBfcXVpbGwkZ2V0TGluZTEzID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4IC0gMSksXG4gICAgICAgIF9xdWlsbCRnZXRMaW5lMTQgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGluZTEzLCAxKSxcbiAgICAgICAgcHJldiA9IF9xdWlsbCRnZXRMaW5lMTRbMF07XG5cbiAgICBpZiAocHJldiAhPSBudWxsICYmIHByZXYubGVuZ3RoKCkgPiAxKSB7XG4gICAgICB2YXIgY3VyRm9ybWF0cyA9IGxpbmUuZm9ybWF0cygpO1xuICAgICAgdmFyIHByZXZGb3JtYXRzID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQocmFuZ2UuaW5kZXggLSAxLCAxKTtcbiAgICAgIGZvcm1hdHMgPSBfb3AyLmRlZmF1bHQuYXR0cmlidXRlcy5kaWZmKGN1ckZvcm1hdHMsIHByZXZGb3JtYXRzKSB8fCB7fTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGFzdHJhbCBzeW1ib2xzXG4gIHZhciBsZW5ndGggPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXSQvLnRlc3QoY29udGV4dC5wcmVmaXgpID8gMiA6IDE7XG4gIHRoaXMucXVpbGwuZGVsZXRlVGV4dChyYW5nZS5pbmRleCAtIGxlbmd0aCwgbGVuZ3RoLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgaWYgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLnF1aWxsLmZvcm1hdExpbmUocmFuZ2UuaW5kZXggLSBsZW5ndGgsIGxlbmd0aCwgZm9ybWF0cywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gIH1cbiAgdGhpcy5xdWlsbC5mb2N1cygpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVEZWxldGUocmFuZ2UsIGNvbnRleHQpIHtcbiAgLy8gQ2hlY2sgZm9yIGFzdHJhbCBzeW1ib2xzXG4gIHZhciBsZW5ndGggPSAvXltcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vLnRlc3QoY29udGV4dC5zdWZmaXgpID8gMiA6IDE7XG4gIGlmIChyYW5nZS5pbmRleCA+PSB0aGlzLnF1aWxsLmdldExlbmd0aCgpIC0gbGVuZ3RoKSByZXR1cm47XG4gIHZhciBmb3JtYXRzID0ge30sXG4gICAgICBuZXh0TGVuZ3RoID0gMDtcblxuICB2YXIgX3F1aWxsJGdldExpbmUxNSA9IHRoaXMucXVpbGwuZ2V0TGluZShyYW5nZS5pbmRleCksXG4gICAgICBfcXVpbGwkZ2V0TGluZTE2ID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmUxNSwgMSksXG4gICAgICBsaW5lID0gX3F1aWxsJGdldExpbmUxNlswXTtcblxuICBpZiAoY29udGV4dC5vZmZzZXQgPj0gbGluZS5sZW5ndGgoKSAtIDEpIHtcbiAgICB2YXIgX3F1aWxsJGdldExpbmUxNyA9IHRoaXMucXVpbGwuZ2V0TGluZShyYW5nZS5pbmRleCArIDEpLFxuICAgICAgICBfcXVpbGwkZ2V0TGluZTE4ID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmUxNywgMSksXG4gICAgICAgIG5leHQgPSBfcXVpbGwkZ2V0TGluZTE4WzBdO1xuXG4gICAgaWYgKG5leHQpIHtcbiAgICAgIHZhciBjdXJGb3JtYXRzID0gbGluZS5mb3JtYXRzKCk7XG4gICAgICB2YXIgbmV4dEZvcm1hdHMgPSB0aGlzLnF1aWxsLmdldEZvcm1hdChyYW5nZS5pbmRleCwgMSk7XG4gICAgICBmb3JtYXRzID0gX29wMi5kZWZhdWx0LmF0dHJpYnV0ZXMuZGlmZihjdXJGb3JtYXRzLCBuZXh0Rm9ybWF0cykgfHwge307XG4gICAgICBuZXh0TGVuZ3RoID0gbmV4dC5sZW5ndGgoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5xdWlsbC5kZWxldGVUZXh0KHJhbmdlLmluZGV4LCBsZW5ndGgsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID4gMCkge1xuICAgIHRoaXMucXVpbGwuZm9ybWF0TGluZShyYW5nZS5pbmRleCArIG5leHRMZW5ndGggLSAxLCBsZW5ndGgsIGZvcm1hdHMsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZURlbGV0ZVJhbmdlKHJhbmdlKSB7XG4gIHZhciBsaW5lcyA9IHRoaXMucXVpbGwuZ2V0TGluZXMocmFuZ2UpO1xuICB2YXIgZm9ybWF0cyA9IHt9O1xuICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgIHZhciBmaXJzdEZvcm1hdHMgPSBsaW5lc1swXS5mb3JtYXRzKCk7XG4gICAgdmFyIGxhc3RGb3JtYXRzID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0uZm9ybWF0cygpO1xuICAgIGZvcm1hdHMgPSBfb3AyLmRlZmF1bHQuYXR0cmlidXRlcy5kaWZmKGxhc3RGb3JtYXRzLCBmaXJzdEZvcm1hdHMpIHx8IHt9O1xuICB9XG4gIHRoaXMucXVpbGwuZGVsZXRlVGV4dChyYW5nZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gIGlmIChPYmplY3Qua2V5cyhmb3JtYXRzKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5xdWlsbC5mb3JtYXRMaW5lKHJhbmdlLmluZGV4LCAxLCBmb3JtYXRzLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgfVxuICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgdGhpcy5xdWlsbC5mb2N1cygpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFbnRlcihyYW5nZSwgY29udGV4dCkge1xuICB2YXIgX3RoaXMzID0gdGhpcztcblxuICBpZiAocmFuZ2UubGVuZ3RoID4gMCkge1xuICAgIHRoaXMucXVpbGwuc2Nyb2xsLmRlbGV0ZUF0KHJhbmdlLmluZGV4LCByYW5nZS5sZW5ndGgpOyAvLyBTbyB3ZSBkbyBub3QgdHJpZ2dlciB0ZXh0LWNoYW5nZVxuICB9XG4gIHZhciBsaW5lRm9ybWF0cyA9IE9iamVjdC5rZXlzKGNvbnRleHQuZm9ybWF0KS5yZWR1Y2UoZnVuY3Rpb24gKGxpbmVGb3JtYXRzLCBmb3JtYXQpIHtcbiAgICBpZiAoX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShmb3JtYXQsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0spICYmICFBcnJheS5pc0FycmF5KGNvbnRleHQuZm9ybWF0W2Zvcm1hdF0pKSB7XG4gICAgICBsaW5lRm9ybWF0c1tmb3JtYXRdID0gY29udGV4dC5mb3JtYXRbZm9ybWF0XTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVGb3JtYXRzO1xuICB9LCB7fSk7XG4gIHRoaXMucXVpbGwuaW5zZXJ0VGV4dChyYW5nZS5pbmRleCwgJ1xcbicsIGxpbmVGb3JtYXRzLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgLy8gRWFybGllciBzY3JvbGwuZGVsZXRlQXQgbWlnaHQgaGF2ZSBtZXNzZWQgdXAgb3VyIHNlbGVjdGlvbixcbiAgLy8gc28gaW5zZXJ0VGV4dCdzIGJ1aWx0IGluIHNlbGVjdGlvbiBwcmVzZXJ2YXRpb24gaXMgbm90IHJlbGlhYmxlXG4gIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgdGhpcy5xdWlsbC5mb2N1cygpO1xuICBPYmplY3Qua2V5cyhjb250ZXh0LmZvcm1hdCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChsaW5lRm9ybWF0c1tuYW1lXSAhPSBudWxsKSByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGV4dC5mb3JtYXRbbmFtZV0pKSByZXR1cm47XG4gICAgaWYgKG5hbWUgPT09ICdsaW5rJykgcmV0dXJuO1xuICAgIF90aGlzMy5xdWlsbC5mb3JtYXQobmFtZSwgY29udGV4dC5mb3JtYXRbbmFtZV0sIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFrZUNvZGVCbG9ja0hhbmRsZXIoaW5kZW50KSB7XG4gIHJldHVybiB7XG4gICAga2V5OiBLZXlib2FyZC5rZXlzLlRBQixcbiAgICBzaGlmdEtleTogIWluZGVudCxcbiAgICBmb3JtYXQ6IHsgJ2NvZGUtYmxvY2snOiB0cnVlIH0sXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSkge1xuICAgICAgdmFyIENvZGVCbG9jayA9IF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkoJ2NvZGUtYmxvY2snKTtcbiAgICAgIHZhciBpbmRleCA9IHJhbmdlLmluZGV4LFxuICAgICAgICAgIGxlbmd0aCA9IHJhbmdlLmxlbmd0aDtcblxuICAgICAgdmFyIF9xdWlsbCRzY3JvbGwkZGVzY2VuZCA9IHRoaXMucXVpbGwuc2Nyb2xsLmRlc2NlbmRhbnQoQ29kZUJsb2NrLCBpbmRleCksXG4gICAgICAgICAgX3F1aWxsJHNjcm9sbCRkZXNjZW5kMiA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRzY3JvbGwkZGVzY2VuZCwgMiksXG4gICAgICAgICAgYmxvY2sgPSBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQyWzBdLFxuICAgICAgICAgIG9mZnNldCA9IF9xdWlsbCRzY3JvbGwkZGVzY2VuZDJbMV07XG5cbiAgICAgIGlmIChibG9jayA9PSBudWxsKSByZXR1cm47XG4gICAgICB2YXIgc2Nyb2xsSW5kZXggPSB0aGlzLnF1aWxsLmdldEluZGV4KGJsb2NrKTtcbiAgICAgIHZhciBzdGFydCA9IGJsb2NrLm5ld2xpbmVJbmRleChvZmZzZXQsIHRydWUpICsgMTtcbiAgICAgIHZhciBlbmQgPSBibG9jay5uZXdsaW5lSW5kZXgoc2Nyb2xsSW5kZXggKyBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgdmFyIGxpbmVzID0gYmxvY2suZG9tTm9kZS50ZXh0Q29udGVudC5zbGljZShzdGFydCwgZW5kKS5zcGxpdCgnXFxuJyk7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSwgaSkge1xuICAgICAgICBpZiAoaW5kZW50KSB7XG4gICAgICAgICAgYmxvY2suaW5zZXJ0QXQoc3RhcnQgKyBvZmZzZXQsIENvZGVCbG9jay5UQUIpO1xuICAgICAgICAgIG9mZnNldCArPSBDb2RlQmxvY2suVEFCLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgaW5kZXggKz0gQ29kZUJsb2NrLlRBQi5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSBDb2RlQmxvY2suVEFCLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKENvZGVCbG9jay5UQUIpKSB7XG4gICAgICAgICAgYmxvY2suZGVsZXRlQXQoc3RhcnQgKyBvZmZzZXQsIENvZGVCbG9jay5UQUIubGVuZ3RoKTtcbiAgICAgICAgICBvZmZzZXQgLT0gQ29kZUJsb2NrLlRBQi5sZW5ndGg7XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGluZGV4IC09IENvZGVCbG9jay5UQUIubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggLT0gQ29kZUJsb2NrLlRBQi5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucXVpbGwudXBkYXRlKF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oaW5kZXgsIGxlbmd0aCwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VGb3JtYXRIYW5kbGVyKGZvcm1hdCkge1xuICByZXR1cm4ge1xuICAgIGtleTogZm9ybWF0WzBdLnRvVXBwZXJDYXNlKCksXG4gICAgc2hvcnRLZXk6IHRydWUsXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoZm9ybWF0LCAhY29udGV4dC5mb3JtYXRbZm9ybWF0XSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUoYmluZGluZykge1xuICBpZiAodHlwZW9mIGJpbmRpbmcgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBiaW5kaW5nID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBub3JtYWxpemUoeyBrZXk6IGJpbmRpbmcgfSk7XG4gIH1cbiAgaWYgKCh0eXBlb2YgYmluZGluZyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYmluZGluZykpID09PSAnb2JqZWN0Jykge1xuICAgIGJpbmRpbmcgPSAoMCwgX2Nsb25lMi5kZWZhdWx0KShiaW5kaW5nLCBmYWxzZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nLmtleSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoS2V5Ym9hcmQua2V5c1tiaW5kaW5nLmtleS50b1VwcGVyQ2FzZSgpXSAhPSBudWxsKSB7XG4gICAgICBiaW5kaW5nLmtleSA9IEtleWJvYXJkLmtleXNbYmluZGluZy5rZXkudG9VcHBlckNhc2UoKV07XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nLmtleS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGJpbmRpbmcua2V5ID0gYmluZGluZy5rZXkudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGJpbmRpbmcuc2hvcnRLZXkpIHtcbiAgICBiaW5kaW5nW1NIT1JUS0VZXSA9IGJpbmRpbmcuc2hvcnRLZXk7XG4gICAgZGVsZXRlIGJpbmRpbmcuc2hvcnRLZXk7XG4gIH1cbiAgcmV0dXJuIGJpbmRpbmc7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEtleWJvYXJkO1xuZXhwb3J0cy5TSE9SVEtFWSA9IFNIT1JUS0VZO1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ3Vyc29yID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkRW1iZWQpIHtcbiAgX2luaGVyaXRzKEN1cnNvciwgX1BhcmNobWVudCRFbWJlZCk7XG5cbiAgX2NyZWF0ZUNsYXNzKEN1cnNvciwgbnVsbCwgW3tcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBDdXJzb3IoZG9tTm9kZSwgc2VsZWN0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1cnNvcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ3Vyc29yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3Vyc29yKSkuY2FsbCh0aGlzLCBkb21Ob2RlKSk7XG5cbiAgICBfdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgX3RoaXMudGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShDdXJzb3IuQ09OVEVOVFMpO1xuICAgIF90aGlzLmRvbU5vZGUuYXBwZW5kQ2hpbGQoX3RoaXMudGV4dE5vZGUpO1xuICAgIF90aGlzLl9sZW5ndGggPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDdXJzb3IsIFt7XG4gICAga2V5OiAnZGV0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgLy8gc3VwZXIuZGV0YWNoKCkgd2lsbCBhbHNvIGNsZWFyIGRvbU5vZGUuX19ibG90XG4gICAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbCkgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KEN1cnNvci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDdXJzb3IucHJvdG90eXBlKSwgJ2Zvcm1hdCcsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIHRhcmdldCA9IHRoaXMsXG4gICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgd2hpbGUgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldC5zdGF0aWNzLnNjb3BlICE9PSBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLX0JMT1QpIHtcbiAgICAgICAgaW5kZXggKz0gdGFyZ2V0Lm9mZnNldCh0YXJnZXQucGFyZW50KTtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9sZW5ndGggPSBDdXJzb3IuQ09OVEVOVFMubGVuZ3RoO1xuICAgICAgICB0YXJnZXQub3B0aW1pemUoKTtcbiAgICAgICAgdGFyZ2V0LmZvcm1hdEF0KGluZGV4LCBDdXJzb3IuQ09OVEVOVFMubGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5kZXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleChub2RlLCBvZmZzZXQpIHtcbiAgICAgIGlmIChub2RlID09PSB0aGlzLnRleHROb2RlKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiBfZ2V0KEN1cnNvci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDdXJzb3IucHJvdG90eXBlKSwgJ2luZGV4JywgdGhpcykuY2FsbCh0aGlzLCBub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xlbmd0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiBbdGhpcy50ZXh0Tm9kZSwgdGhpcy50ZXh0Tm9kZS5kYXRhLmxlbmd0aF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgX2dldChDdXJzb3IucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3Vyc29yLnByb3RvdHlwZSksICdyZW1vdmUnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc3RvcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLmNvbXBvc2luZyB8fCB0aGlzLnBhcmVudCA9PSBudWxsKSByZXR1cm47XG4gICAgICB2YXIgdGV4dE5vZGUgPSB0aGlzLnRleHROb2RlO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWxlY3Rpb24uZ2V0TmF0aXZlUmFuZ2UoKTtcbiAgICAgIHZhciByZXN0b3JlVGV4dCA9IHZvaWQgMCxcbiAgICAgICAgICBzdGFydCA9IHZvaWQgMCxcbiAgICAgICAgICBlbmQgPSB2b2lkIDA7XG4gICAgICBpZiAocmFuZ2UgIT0gbnVsbCAmJiByYW5nZS5zdGFydC5ub2RlID09PSB0ZXh0Tm9kZSAmJiByYW5nZS5lbmQubm9kZSA9PT0gdGV4dE5vZGUpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBbdGV4dE5vZGUsIHJhbmdlLnN0YXJ0Lm9mZnNldCwgcmFuZ2UuZW5kLm9mZnNldF07XG4gICAgICAgIHJlc3RvcmVUZXh0ID0gX3JlZlswXTtcbiAgICAgICAgc3RhcnQgPSBfcmVmWzFdO1xuICAgICAgICBlbmQgPSBfcmVmWzJdO1xuICAgICAgfVxuICAgICAgLy8gTGluayBmb3JtYXQgd2lsbCBpbnNlcnQgdGV4dCBvdXRzaWRlIG9mIGFuY2hvciB0YWdcbiAgICAgIHdoaWxlICh0aGlzLmRvbU5vZGUubGFzdENoaWxkICE9IG51bGwgJiYgdGhpcy5kb21Ob2RlLmxhc3RDaGlsZCAhPT0gdGhpcy50ZXh0Tm9kZSkge1xuICAgICAgICB0aGlzLmRvbU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb21Ob2RlLmxhc3RDaGlsZCwgdGhpcy5kb21Ob2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHROb2RlLmRhdGEgIT09IEN1cnNvci5DT05URU5UUykge1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMudGV4dE5vZGUuZGF0YS5zcGxpdChDdXJzb3IuQ09OVEVOVFMpLmpvaW4oJycpO1xuICAgICAgICBpZiAodGhpcy5uZXh0IGluc3RhbmNlb2YgX3RleHQyLmRlZmF1bHQpIHtcbiAgICAgICAgICByZXN0b3JlVGV4dCA9IHRoaXMubmV4dC5kb21Ob2RlO1xuICAgICAgICAgIHRoaXMubmV4dC5pbnNlcnRBdCgwLCB0ZXh0KTtcbiAgICAgICAgICB0aGlzLnRleHROb2RlLmRhdGEgPSBDdXJzb3IuQ09OVEVOVFM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50ZXh0Tm9kZS5kYXRhID0gdGV4dDtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUodGhpcy50ZXh0Tm9kZSksIHRoaXMpO1xuICAgICAgICAgIHRoaXMudGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShDdXJzb3IuQ09OVEVOVFMpO1xuICAgICAgICAgIHRoaXMuZG9tTm9kZS5hcHBlbmRDaGlsZCh0aGlzLnRleHROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBfbWFwID0gW3N0YXJ0LCBlbmRdLm1hcChmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHJlc3RvcmVUZXh0LmRhdGEubGVuZ3RoLCBvZmZzZXQgLSAxKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBfbWFwMiA9IF9zbGljZWRUb0FycmF5KF9tYXAsIDIpO1xuXG4gICAgICAgIHN0YXJ0ID0gX21hcDJbMF07XG4gICAgICAgIGVuZCA9IF9tYXAyWzFdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhcnROb2RlOiByZXN0b3JlVGV4dCxcbiAgICAgICAgICBzdGFydE9mZnNldDogc3RhcnQsXG4gICAgICAgICAgZW5kTm9kZTogcmVzdG9yZVRleHQsXG4gICAgICAgICAgZW5kT2Zmc2V0OiBlbmRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKG11dGF0aW9ucy5zb21lKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnICYmIG11dGF0aW9uLnRhcmdldCA9PT0gX3RoaXMyLnRleHROb2RlO1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5yZXN0b3JlKCk7XG4gICAgICAgIGlmIChyYW5nZSkgY29udGV4dC5yYW5nZSA9IHJhbmdlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1cnNvcjtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCk7XG5cbkN1cnNvci5ibG90TmFtZSA9ICdjdXJzb3InO1xuQ3Vyc29yLmNsYXNzTmFtZSA9ICdxbC1jdXJzb3InO1xuQ3Vyc29yLnRhZ05hbWUgPSAnc3Bhbic7XG5DdXJzb3IuQ09OVEVOVFMgPSAnXFx1RkVGRic7IC8vIFplcm8gd2lkdGggbm8gYnJlYWsgc3BhY2VcblxuXG5leHBvcnRzLmRlZmF1bHQgPSBDdXJzb3I7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX2Jsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9ibG9jazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ibG9jayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENvbnRhaW5lciA9IGZ1bmN0aW9uIChfUGFyY2htZW50JENvbnRhaW5lcikge1xuICBfaW5oZXJpdHMoQ29udGFpbmVyLCBfUGFyY2htZW50JENvbnRhaW5lcik7XG5cbiAgZnVuY3Rpb24gQ29udGFpbmVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250YWluZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb250YWluZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb250YWluZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBDb250YWluZXI7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuQ29udGFpbmVyKTtcblxuQ29udGFpbmVyLmFsbG93ZWRDaGlsZHJlbiA9IFtfYmxvY2syLmRlZmF1bHQsIF9ibG9jay5CbG9ja0VtYmVkLCBDb250YWluZXJdO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDb250YWluZXI7XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ29sb3JTdHlsZSA9IGV4cG9ydHMuQ29sb3JDbGFzcyA9IGV4cG9ydHMuQ29sb3JBdHRyaWJ1dG9yID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ29sb3JBdHRyaWJ1dG9yID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkQXR0cmlidXRvcikge1xuICBfaW5oZXJpdHMoQ29sb3JBdHRyaWJ1dG9yLCBfUGFyY2htZW50JEF0dHJpYnV0b3IpO1xuXG4gIGZ1bmN0aW9uIENvbG9yQXR0cmlidXRvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3JBdHRyaWJ1dG9yKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ29sb3JBdHRyaWJ1dG9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29sb3JBdHRyaWJ1dG9yKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29sb3JBdHRyaWJ1dG9yLCBbe1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZG9tTm9kZSkge1xuICAgICAgdmFyIHZhbHVlID0gX2dldChDb2xvckF0dHJpYnV0b3IucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29sb3JBdHRyaWJ1dG9yLnByb3RvdHlwZSksICd2YWx1ZScsIHRoaXMpLmNhbGwodGhpcywgZG9tTm9kZSk7XG4gICAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoJ3JnYignKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eW15cXGRdKy8sICcnKS5yZXBsYWNlKC9bXlxcZF0rJC8sICcnKTtcbiAgICAgIHJldHVybiAnIycgKyB2YWx1ZS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAoJzAwJyArIHBhcnNlSW50KGNvbXBvbmVudCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICB9KS5qb2luKCcnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29sb3JBdHRyaWJ1dG9yO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuU3R5bGUpO1xuXG52YXIgQ29sb3JDbGFzcyA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQ2xhc3MoJ2NvbG9yJywgJ3FsLWNvbG9yJywge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkVcbn0pO1xudmFyIENvbG9yU3R5bGUgPSBuZXcgQ29sb3JBdHRyaWJ1dG9yKCdjb2xvcicsICdjb2xvcicsIHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuSU5MSU5FXG59KTtcblxuZXhwb3J0cy5Db2xvckF0dHJpYnV0b3IgPSBDb2xvckF0dHJpYnV0b3I7XG5leHBvcnRzLkNvbG9yQ2xhc3MgPSBDb2xvckNsYXNzO1xuZXhwb3J0cy5Db2xvclN0eWxlID0gQ29sb3JTdHlsZTtcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zYW5pdGl6ZSA9IGV4cG9ydHMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIExpbmsgPSBmdW5jdGlvbiAoX0lubGluZSkge1xuICBfaW5oZXJpdHMoTGluaywgX0lubGluZSk7XG5cbiAgZnVuY3Rpb24gTGluaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluayk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKExpbmsuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaW5rKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGluaywgW3tcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lICE9PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgfHwgIXZhbHVlKSByZXR1cm4gX2dldChMaW5rLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpbmsucHJvdG90eXBlKSwgJ2Zvcm1hdCcsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLnNhbml0aXplKHZhbHVlKTtcbiAgICAgIHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB2YWx1ZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIHZhciBub2RlID0gX2dldChMaW5rLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGluayksICdjcmVhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIHZhbHVlID0gdGhpcy5zYW5pdGl6ZSh2YWx1ZSk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIHZhbHVlKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdyZWwnLCAnbm9vcGVuZXIgbm9yZWZlcnJlcicpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsICdfYmxhbmsnKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nhbml0aXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FuaXRpemUodXJsKSB7XG4gICAgICByZXR1cm4gX3Nhbml0aXplKHVybCwgdGhpcy5QUk9UT0NPTF9XSElURUxJU1QpID8gdXJsIDogdGhpcy5TQU5JVElaRURfVVJMO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5rO1xufShfaW5saW5lMi5kZWZhdWx0KTtcblxuTGluay5ibG90TmFtZSA9ICdsaW5rJztcbkxpbmsudGFnTmFtZSA9ICdBJztcbkxpbmsuU0FOSVRJWkVEX1VSTCA9ICdhYm91dDpibGFuayc7XG5MaW5rLlBST1RPQ09MX1dISVRFTElTVCA9IFsnaHR0cCcsICdodHRwcycsICdtYWlsdG8nLCAndGVsJ107XG5cbmZ1bmN0aW9uIF9zYW5pdGl6ZSh1cmwsIHByb3RvY29scykge1xuICB2YXIgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBhbmNob3IuaHJlZiA9IHVybDtcbiAgdmFyIHByb3RvY29sID0gYW5jaG9yLmhyZWYuc2xpY2UoMCwgYW5jaG9yLmhyZWYuaW5kZXhPZignOicpKTtcbiAgcmV0dXJuIHByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA+IC0xO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBMaW5rO1xuZXhwb3J0cy5zYW5pdGl6ZSA9IF9zYW5pdGl6ZTtcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfa2V5Ym9hcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIF9rZXlib2FyZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlib2FyZCk7XG5cbnZhciBfZHJvcGRvd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNyk7XG5cbnZhciBfZHJvcGRvd24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZHJvcGRvd24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgb3B0aW9uc0NvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiB0b2dnbGVBcmlhQXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsICEoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSA9PT0gJ3RydWUnKSk7XG59XG5cbnZhciBQaWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBpY2tlcihzZWxlY3QpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBpY2tlcik7XG5cbiAgICB0aGlzLnNlbGVjdCA9IHNlbGVjdDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICB0aGlzLmJ1aWxkUGlja2VyKCk7XG4gICAgdGhpcy5zZWxlY3Quc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLnNlbGVjdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmNvbnRhaW5lciwgdGhpcy5zZWxlY3QpO1xuXG4gICAgdGhpcy5sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy50b2dnbGVQaWNrZXIoKTtcbiAgICB9KTtcbiAgICB0aGlzLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAvLyBBbGxvd3MgdGhlIFwiRW50ZXJcIiBrZXkgdG8gb3BlbiB0aGUgcGlja2VyXG4gICAgICAgIGNhc2UgX2tleWJvYXJkMi5kZWZhdWx0LmtleXMuRU5URVI6XG4gICAgICAgICAgX3RoaXMudG9nZ2xlUGlja2VyKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gQWxsb3dzIHRoZSBcIkVzY2FwZVwiIGtleSB0byBjbG9zZSB0aGUgcGlja2VyXG4gICAgICAgIGNhc2UgX2tleWJvYXJkMi5kZWZhdWx0LmtleXMuRVNDQVBFOlxuICAgICAgICAgIF90aGlzLmVzY2FwZSgpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGlja2VyLCBbe1xuICAgIGtleTogJ3RvZ2dsZVBpY2tlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZVBpY2tlcigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC50b2dnbGUoJ3FsLWV4cGFuZGVkJyk7XG4gICAgICAvLyBUb2dnbGUgYXJpYS1leHBhbmRlZCBhbmQgYXJpYS1oaWRkZW4gdG8gbWFrZSB0aGUgcGlja2VyIGFjY2Vzc2libGVcbiAgICAgIHRvZ2dsZUFyaWFBdHRyaWJ1dGUodGhpcy5sYWJlbCwgJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICAgIHRvZ2dsZUFyaWFBdHRyaWJ1dGUodGhpcy5vcHRpb25zLCAnYXJpYS1oaWRkZW4nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdidWlsZEl0ZW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZEl0ZW0ob3B0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBpdGVtLnRhYkluZGV4ID0gJzAnO1xuICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XG5cbiAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgncWwtcGlja2VyLWl0ZW0nKTtcbiAgICAgIGlmIChvcHRpb24uaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJywgb3B0aW9uLmdldEF0dHJpYnV0ZSgndmFsdWUnKSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uLnRleHRDb250ZW50KSB7XG4gICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdkYXRhLWxhYmVsJywgb3B0aW9uLnRleHRDb250ZW50KTtcbiAgICAgIH1cbiAgICAgIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zZWxlY3RJdGVtKGl0ZW0sIHRydWUpO1xuICAgICAgfSk7XG4gICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgLy8gQWxsb3dzIHRoZSBcIkVudGVyXCIga2V5IHRvIHNlbGVjdCBhbiBpdGVtXG4gICAgICAgICAgY2FzZSBfa2V5Ym9hcmQyLmRlZmF1bHQua2V5cy5FTlRFUjpcbiAgICAgICAgICAgIF90aGlzMi5zZWxlY3RJdGVtKGl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQWxsb3dzIHRoZSBcIkVzY2FwZVwiIGtleSB0byBjbG9zZSB0aGUgcGlja2VyXG4gICAgICAgICAgY2FzZSBfa2V5Ym9hcmQyLmRlZmF1bHQua2V5cy5FU0NBUEU6XG4gICAgICAgICAgICBfdGhpczIuZXNjYXBlKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkTGFiZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZExhYmVsKCkge1xuICAgICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgncWwtcGlja2VyLWxhYmVsJyk7XG4gICAgICBsYWJlbC5pbm5lckhUTUwgPSBfZHJvcGRvd24yLmRlZmF1bHQ7XG4gICAgICBsYWJlbC50YWJJbmRleCA9ICcwJztcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkT3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkT3B0aW9ucygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIG9wdGlvbnMuY2xhc3NMaXN0LmFkZCgncWwtcGlja2VyLW9wdGlvbnMnKTtcblxuICAgICAgLy8gRG9uJ3Qgd2FudCBzY3JlZW4gcmVhZGVycyB0byByZWFkIHRoaXMgdW50aWwgb3B0aW9ucyBhcmUgdmlzaWJsZVxuICAgICAgb3B0aW9ucy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgIG9wdGlvbnMudGFiSW5kZXggPSAnLTEnO1xuXG4gICAgICAvLyBOZWVkIGEgdW5pcXVlIGlkIGZvciBhcmlhLWNvbnRyb2xzXG4gICAgICBvcHRpb25zLmlkID0gJ3FsLXBpY2tlci1vcHRpb25zLScgKyBvcHRpb25zQ291bnRlcjtcbiAgICAgIG9wdGlvbnNDb3VudGVyICs9IDE7XG4gICAgICB0aGlzLmxhYmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycsIG9wdGlvbnMuaWQpO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICBbXS5zbGljZS5jYWxsKHRoaXMuc2VsZWN0Lm9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB2YXIgaXRlbSA9IF90aGlzMy5idWlsZEl0ZW0ob3B0aW9uKTtcbiAgICAgICAgb3B0aW9ucy5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIF90aGlzMy5zZWxlY3RJdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkUGlja2VyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRQaWNrZXIoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgW10uc2xpY2UuY2FsbCh0aGlzLnNlbGVjdC5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIF90aGlzNC5jb250YWluZXIuc2V0QXR0cmlidXRlKGl0ZW0ubmFtZSwgaXRlbS52YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3FsLXBpY2tlcicpO1xuICAgICAgdGhpcy5sYWJlbCA9IHRoaXMuYnVpbGRMYWJlbCgpO1xuICAgICAgdGhpcy5idWlsZE9wdGlvbnMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlc2NhcGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc2NhcGUoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gQ2xvc2UgbWVudSBhbmQgcmV0dXJuIGZvY3VzIHRvIHRyaWdnZXIgbGFiZWxcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIC8vIE5lZWQgc2V0VGltZW91dCBmb3IgYWNjZXNzaWJpbGl0eSB0byBlbnN1cmUgdGhhdCB0aGUgYnJvd3NlciBleGVjdXRlc1xuICAgICAgLy8gZm9jdXMgb24gdGhlIG5leHQgcHJvY2VzcyB0aHJlYWQgYW5kIGFmdGVyIGFueSBET00gY29udGVudCBjaGFuZ2VzXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNS5sYWJlbC5mb2N1cygpO1xuICAgICAgfSwgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2xvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ3FsLWV4cGFuZGVkJyk7XG4gICAgICB0aGlzLmxhYmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgdGhpcy5vcHRpb25zLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdEl0ZW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RJdGVtKGl0ZW0pIHtcbiAgICAgIHZhciB0cmlnZ2VyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignLnFsLXNlbGVjdGVkJyk7XG4gICAgICBpZiAoaXRlbSA9PT0gc2VsZWN0ZWQpIHJldHVybjtcbiAgICAgIGlmIChzZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICAgIHNlbGVjdGVkLmNsYXNzTGlzdC5yZW1vdmUoJ3FsLXNlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSA9PSBudWxsKSByZXR1cm47XG4gICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3FsLXNlbGVjdGVkJyk7XG4gICAgICB0aGlzLnNlbGVjdC5zZWxlY3RlZEluZGV4ID0gW10uaW5kZXhPZi5jYWxsKGl0ZW0ucGFyZW50Tm9kZS5jaGlsZHJlbiwgaXRlbSk7XG4gICAgICBpZiAoaXRlbS5oYXNBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSkge1xuICAgICAgICB0aGlzLmxhYmVsLnNldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScsIGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYWJlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtLmhhc0F0dHJpYnV0ZSgnZGF0YS1sYWJlbCcpKSB7XG4gICAgICAgIHRoaXMubGFiZWwuc2V0QXR0cmlidXRlKCdkYXRhLWxhYmVsJywgaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGFiZWwnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhYmVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1sYWJlbCcpO1xuICAgICAgfVxuICAgICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuc2VsZWN0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBFdmVudCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoRXZlbnQpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBJRTExXG4gICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCdjaGFuZ2UnLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIG9wdGlvbiA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLnNlbGVjdC5zZWxlY3RlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucWwtcGlja2VyLW9wdGlvbnMnKS5jaGlsZHJlblt0aGlzLnNlbGVjdC5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgb3B0aW9uID0gdGhpcy5zZWxlY3Qub3B0aW9uc1t0aGlzLnNlbGVjdC5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgdGhpcy5zZWxlY3RJdGVtKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3RJdGVtKG51bGwpO1xuICAgICAgfVxuICAgICAgdmFyIGlzQWN0aXZlID0gb3B0aW9uICE9IG51bGwgJiYgb3B0aW9uICE9PSB0aGlzLnNlbGVjdC5xdWVyeVNlbGVjdG9yKCdvcHRpb25bc2VsZWN0ZWRdJyk7XG4gICAgICB0aGlzLmxhYmVsLmNsYXNzTGlzdC50b2dnbGUoJ3FsLWFjdGl2ZScsIGlzQWN0aXZlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGlja2VyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQaWNrZXI7XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX3F1aWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9xdWlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbCk7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxudmFyIF9icmVhayA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX2JyZWFrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JyZWFrKTtcblxudmFyIF9jb250YWluZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxudmFyIF9jb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGFpbmVyKTtcblxudmFyIF9jdXJzb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxudmFyIF9jdXJzb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3Vyc29yKTtcblxudmFyIF9lbWJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXG52YXIgX2VtYmVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VtYmVkKTtcblxudmFyIF9pbmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX2lubGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmxpbmUpO1xuXG52YXIgX3Njcm9sbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXG52YXIgX3Njcm9sbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zY3JvbGwpO1xuXG52YXIgX3RleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3RleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dCk7XG5cbnZhciBfY2xpcGJvYXJkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG5cbnZhciBfY2xpcGJvYXJkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsaXBib2FyZCk7XG5cbnZhciBfaGlzdG9yeSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xuXG52YXIgX2hpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGlzdG9yeSk7XG5cbnZhciBfa2V5Ym9hcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIF9rZXlib2FyZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlib2FyZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbl9xdWlsbDIuZGVmYXVsdC5yZWdpc3Rlcih7XG4gICdibG90cy9ibG9jayc6IF9ibG9jazIuZGVmYXVsdCxcbiAgJ2Jsb3RzL2Jsb2NrL2VtYmVkJzogX2Jsb2NrLkJsb2NrRW1iZWQsXG4gICdibG90cy9icmVhayc6IF9icmVhazIuZGVmYXVsdCxcbiAgJ2Jsb3RzL2NvbnRhaW5lcic6IF9jb250YWluZXIyLmRlZmF1bHQsXG4gICdibG90cy9jdXJzb3InOiBfY3Vyc29yMi5kZWZhdWx0LFxuICAnYmxvdHMvZW1iZWQnOiBfZW1iZWQyLmRlZmF1bHQsXG4gICdibG90cy9pbmxpbmUnOiBfaW5saW5lMi5kZWZhdWx0LFxuICAnYmxvdHMvc2Nyb2xsJzogX3Njcm9sbDIuZGVmYXVsdCxcbiAgJ2Jsb3RzL3RleHQnOiBfdGV4dDIuZGVmYXVsdCxcblxuICAnbW9kdWxlcy9jbGlwYm9hcmQnOiBfY2xpcGJvYXJkMi5kZWZhdWx0LFxuICAnbW9kdWxlcy9oaXN0b3J5JzogX2hpc3RvcnkyLmRlZmF1bHQsXG4gICdtb2R1bGVzL2tleWJvYXJkJzogX2tleWJvYXJkMi5kZWZhdWx0XG59KTtcblxuX3BhcmNobWVudDIuZGVmYXVsdC5yZWdpc3RlcihfYmxvY2syLmRlZmF1bHQsIF9icmVhazIuZGVmYXVsdCwgX2N1cnNvcjIuZGVmYXVsdCwgX2lubGluZTIuZGVmYXVsdCwgX3Njcm9sbDIuZGVmYXVsdCwgX3RleHQyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfcXVpbGwyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgU2hhZG93QmxvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaGFkb3dCbG90KGRvbU5vZGUpIHtcbiAgICAgICAgdGhpcy5kb21Ob2RlID0gZG9tTm9kZTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldID0geyBibG90OiB0aGlzIH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaGFkb3dCbG90LnByb3RvdHlwZSwgXCJzdGF0aWNzXCIsIHtcbiAgICAgICAgLy8gSGFjayBmb3IgYWNjZXNzaW5nIGluaGVyaXRlZCBzdGF0aWMgbWV0aG9kc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTaGFkb3dCbG90LmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50YWdOYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWdpc3RyeS5QYXJjaG1lbnRFcnJvcignQmxvdCBkZWZpbml0aW9uIG1pc3NpbmcgdGFnTmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQodmFsdWUpLnRvU3RyaW5nKCkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy50YWdOYW1lW3ZhbHVlIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50YWdOYW1lLmluZGV4T2YodmFsdWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWVbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy50YWdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbCA9IHRoaXMucGFyZW50LnNjcm9sbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21Ob2RlID0gdGhpcy5kb21Ob2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIHJldHVybiBSZWdpc3RyeS5jcmVhdGUoZG9tTm9kZSk7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZGVsZXRlIHRoaXMuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV07XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5kZWxldGVBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBibG90ID0gdGhpcy5pc29sYXRlKGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBibG90LnJlbW92ZSgpO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUuZm9ybWF0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGJsb3QgPSB0aGlzLmlzb2xhdGUoaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIGlmIChSZWdpc3RyeS5xdWVyeShuYW1lLCBSZWdpc3RyeS5TY29wZS5CTE9UKSAhPSBudWxsICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBibG90LndyYXAobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFJlZ2lzdHJ5LnF1ZXJ5KG5hbWUsIFJlZ2lzdHJ5LlNjb3BlLkFUVFJJQlVURSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IFJlZ2lzdHJ5LmNyZWF0ZSh0aGlzLnN0YXRpY3Muc2NvcGUpO1xuICAgICAgICAgICAgYmxvdC53cmFwKHBhcmVudCk7XG4gICAgICAgICAgICBwYXJlbnQuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgICAgdmFyIGJsb3QgPSBkZWYgPT0gbnVsbCA/IFJlZ2lzdHJ5LmNyZWF0ZSgndGV4dCcsIHZhbHVlKSA6IFJlZ2lzdHJ5LmNyZWF0ZSh2YWx1ZSwgZGVmKTtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXMuc3BsaXQoaW5kZXgpO1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYmxvdCwgcmVmKTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmluc2VydEludG8gPSBmdW5jdGlvbiAocGFyZW50QmxvdCwgcmVmQmxvdCkge1xuICAgICAgICBpZiAocmVmQmxvdCA9PT0gdm9pZCAwKSB7IHJlZkJsb3QgPSBudWxsOyB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5yZW1vdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZkRvbU5vZGUgPSBudWxsO1xuICAgICAgICBwYXJlbnRCbG90LmNoaWxkcmVuLmluc2VydEJlZm9yZSh0aGlzLCByZWZCbG90KTtcbiAgICAgICAgaWYgKHJlZkJsb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVmRG9tTm9kZSA9IHJlZkJsb3QuZG9tTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kb21Ob2RlLnBhcmVudE5vZGUgIT0gcGFyZW50QmxvdC5kb21Ob2RlIHx8XG4gICAgICAgICAgICB0aGlzLmRvbU5vZGUubmV4dFNpYmxpbmcgIT0gcmVmRG9tTm9kZSkge1xuICAgICAgICAgICAgcGFyZW50QmxvdC5kb21Ob2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbU5vZGUsIHJlZkRvbU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50QmxvdDtcbiAgICAgICAgdGhpcy5hdHRhY2goKTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmlzb2xhdGUgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5zcGxpdChpbmRleCk7XG4gICAgICAgIHRhcmdldC5zcGxpdChsZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIGlmIChyb290ID09PSB2b2lkIDApIHsgcm9vdCA9IHRoaXMucGFyZW50OyB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCA9PSBudWxsIHx8IHRoaXMgPT0gcm9vdClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGRyZW4ub2Zmc2V0KHRoaXMpICsgdGhpcy5wYXJlbnQub2Zmc2V0KHJvb3QpO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUub3B0aW1pemUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAvLyBUT0RPIGNsZWFuIHVwIG9uY2Ugd2UgdXNlIFdlYWtNYXBcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodGhpcy5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tTm9kZS5wYXJlbnROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQucGFyZW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRhcmdldC5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIHRhcmdldC5uZXh0KTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUucmVwbGFjZVdpdGggPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnID8gUmVnaXN0cnkuY3JlYXRlKG5hbWUsIHZhbHVlKSA6IG5hbWU7XG4gICAgICAgIHJlcGxhY2VtZW50LnJlcGxhY2UodGhpcyk7XG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKGluZGV4LCBmb3JjZSkge1xuICAgICAgICByZXR1cm4gaW5kZXggPT09IDAgPyB0aGlzIDogdGhpcy5uZXh0O1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGJ5IGRlZmF1bHRcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgPyBSZWdpc3RyeS5jcmVhdGUobmFtZSwgdmFsdWUpIDogbmFtZTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh3cmFwcGVyLCB0aGlzLm5leHQpO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5ibG90TmFtZSA9ICdhYnN0cmFjdCc7XG4gICAgcmV0dXJuIFNoYWRvd0Jsb3Q7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU2hhZG93QmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXR0cmlidXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG52YXIgY2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIHN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgQXR0cmlidXRvclN0b3JlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0b3JTdG9yZShkb21Ob2RlKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB0aGlzLmRvbU5vZGUgPSBkb21Ob2RlO1xuICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgfVxuICAgIEF0dHJpYnV0b3JTdG9yZS5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgLy8gdmVyYlxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuYWRkKHRoaXMuZG9tTm9kZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZSh0aGlzLmRvbU5vZGUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZS5hdHRyTmFtZV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZS5hdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cmlidXRlLnJlbW92ZSh0aGlzLmRvbU5vZGUpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGUuYXR0ck5hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdHRyaWJ1dG9yU3RvcmUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dG9yXzEuZGVmYXVsdC5rZXlzKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIHZhciBjbGFzc2VzID0gY2xhc3NfMS5kZWZhdWx0LmtleXModGhpcy5kb21Ob2RlKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IHN0eWxlXzEuZGVmYXVsdC5rZXlzKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC5jb25jYXQoY2xhc3NlcylcbiAgICAgICAgICAgIC5jb25jYXQoc3R5bGVzKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBhdHRyID0gUmVnaXN0cnkucXVlcnkobmFtZSwgUmVnaXN0cnkuU2NvcGUuQVRUUklCVVRFKTtcbiAgICAgICAgICAgIGlmIChhdHRyIGluc3RhbmNlb2YgYXR0cmlidXRvcl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVzW2F0dHIuYXR0ck5hbWVdID0gYXR0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdHRyaWJ1dG9yU3RvcmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy5hdHRyaWJ1dGVzW2tleV0udmFsdWUoX3RoaXMuZG9tTm9kZSk7XG4gICAgICAgICAgICB0YXJnZXQuZm9ybWF0KGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF0dHJpYnV0b3JTdG9yZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb3B5KHRhcmdldCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVzW2tleV0ucmVtb3ZlKF90aGlzLmRvbU5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgfTtcbiAgICBBdHRyaWJ1dG9yU3RvcmUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcykucmVkdWNlKGZ1bmN0aW9uIChhdHRyaWJ1dGVzLCBuYW1lKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW25hbWVdID0gX3RoaXMuYXR0cmlidXRlc1tuYW1lXS52YWx1ZShfdGhpcy5kb21Ob2RlKTtcbiAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXR0cmlidXRvclN0b3JlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF0dHJpYnV0b3JTdG9yZTtcblxuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhdHRyaWJ1dG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbmZ1bmN0aW9uIG1hdGNoKG5vZGUsIHByZWZpeCkge1xuICAgIHZhciBjbGFzc05hbWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcbiAgICByZXR1cm4gY2xhc3NOYW1lLnNwbGl0KC9cXHMrLykuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lLmluZGV4T2YocHJlZml4ICsgXCItXCIpID09PSAwO1xuICAgIH0pO1xufVxudmFyIENsYXNzQXR0cmlidXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xhc3NBdHRyaWJ1dG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENsYXNzQXR0cmlidXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDbGFzc0F0dHJpYnV0b3Iua2V5cyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZVxuICAgICAgICAgICAgICAgIC5zcGxpdCgnLScpXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgICAgIC5qb2luKCctJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2xhc3NBdHRyaWJ1dG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucmVtb3ZlKG5vZGUpO1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQodGhpcy5rZXlOYW1lICsgXCItXCIgKyB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQ2xhc3NBdHRyaWJ1dG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IG1hdGNoKG5vZGUsIHRoaXMua2V5TmFtZSk7XG4gICAgICAgIG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5vZGUuY2xhc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsYXNzQXR0cmlidXRvci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbWF0Y2gobm9kZSwgdGhpcy5rZXlOYW1lKVswXSB8fCAnJztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnNsaWNlKHRoaXMua2V5TmFtZS5sZW5ndGggKyAxKTsgLy8gKzEgZm9yIGh5cGhlblxuICAgICAgICByZXR1cm4gdGhpcy5jYW5BZGQobm9kZSwgdmFsdWUpID8gdmFsdWUgOiAnJztcbiAgICB9O1xuICAgIHJldHVybiBDbGFzc0F0dHJpYnV0b3I7XG59KGF0dHJpYnV0b3JfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDbGFzc0F0dHJpYnV0b3I7XG5cblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXR0cmlidXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5mdW5jdGlvbiBjYW1lbGl6ZShuYW1lKSB7XG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLScpO1xuICAgIHZhciByZXN0ID0gcGFydHNcbiAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRbMF0udG9VcHBlckNhc2UoKSArIHBhcnQuc2xpY2UoMSk7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJycpO1xuICAgIHJldHVybiBwYXJ0c1swXSArIHJlc3Q7XG59XG52YXIgU3R5bGVBdHRyaWJ1dG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdHlsZUF0dHJpYnV0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3R5bGVBdHRyaWJ1dG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFN0eWxlQXR0cmlidXRvci5rZXlzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIChub2RlLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJykuc3BsaXQoJzsnKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgICAgIHJldHVybiBhcnJbMF0udHJpbSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0eWxlQXR0cmlidXRvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5BZGQobm9kZSwgdmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG5vZGUuc3R5bGVbY2FtZWxpemUodGhpcy5rZXlOYW1lKV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTdHlsZUF0dHJpYnV0b3IucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbm9kZS5zdHlsZVtjYW1lbGl6ZSh0aGlzLmtleU5hbWUpXSA9ICcnO1xuICAgICAgICBpZiAoIW5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R5bGVBdHRyaWJ1dG9yLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5zdHlsZVtjYW1lbGl6ZSh0aGlzLmtleU5hbWUpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSA/IHZhbHVlIDogJyc7XG4gICAgfTtcbiAgICByZXR1cm4gU3R5bGVBdHRyaWJ1dG9yO1xufShhdHRyaWJ1dG9yXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3R5bGVBdHRyaWJ1dG9yO1xuXG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFRoZW1lID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaGVtZShxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaGVtZSk7XG5cbiAgICB0aGlzLnF1aWxsID0gcXVpbGw7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm1vZHVsZXMgPSB7fTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaGVtZSwgW3tcbiAgICBrZXk6ICdpbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChfdGhpcy5tb2R1bGVzW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICBfdGhpcy5hZGRNb2R1bGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZE1vZHVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1vZHVsZShuYW1lKSB7XG4gICAgICB2YXIgbW9kdWxlQ2xhc3MgPSB0aGlzLnF1aWxsLmNvbnN0cnVjdG9yLmltcG9ydCgnbW9kdWxlcy8nICsgbmFtZSk7XG4gICAgICB0aGlzLm1vZHVsZXNbbmFtZV0gPSBuZXcgbW9kdWxlQ2xhc3ModGhpcy5xdWlsbCwgdGhpcy5vcHRpb25zLm1vZHVsZXNbbmFtZV0gfHwge30pO1xuICAgICAgcmV0dXJuIHRoaXMubW9kdWxlc1tuYW1lXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGhlbWU7XG59KCk7XG5cblRoZW1lLkRFRkFVTFRTID0ge1xuICBtb2R1bGVzOiB7fVxufTtcblRoZW1lLnRoZW1lcyA9IHtcbiAgJ2RlZmF1bHQnOiBUaGVtZVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhlbWU7XG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgR1VBUkRfVEVYVCA9ICdcXHVGRUZGJztcblxudmFyIEVtYmVkID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkRW1iZWQpIHtcbiAgX2luaGVyaXRzKEVtYmVkLCBfUGFyY2htZW50JEVtYmVkKTtcblxuICBmdW5jdGlvbiBFbWJlZChub2RlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVtYmVkKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChFbWJlZC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEVtYmVkKSkuY2FsbCh0aGlzLCBub2RlKSk7XG5cbiAgICBfdGhpcy5jb250ZW50Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBfdGhpcy5jb250ZW50Tm9kZS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIGZhbHNlKTtcbiAgICBbXS5zbGljZS5jYWxsKF90aGlzLmRvbU5vZGUuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICBfdGhpcy5jb250ZW50Tm9kZS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgIH0pO1xuICAgIF90aGlzLmxlZnRHdWFyZCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKEdVQVJEX1RFWFQpO1xuICAgIF90aGlzLnJpZ2h0R3VhcmQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShHVUFSRF9URVhUKTtcbiAgICBfdGhpcy5kb21Ob2RlLmFwcGVuZENoaWxkKF90aGlzLmxlZnRHdWFyZCk7XG4gICAgX3RoaXMuZG9tTm9kZS5hcHBlbmRDaGlsZChfdGhpcy5jb250ZW50Tm9kZSk7XG4gICAgX3RoaXMuZG9tTm9kZS5hcHBlbmRDaGlsZChfdGhpcy5yaWdodEd1YXJkKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRW1iZWQsIFt7XG4gICAga2V5OiAnaW5kZXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleChub2RlLCBvZmZzZXQpIHtcbiAgICAgIGlmIChub2RlID09PSB0aGlzLmxlZnRHdWFyZCkgcmV0dXJuIDA7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy5yaWdodEd1YXJkKSByZXR1cm4gMTtcbiAgICAgIHJldHVybiBfZ2V0KEVtYmVkLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEVtYmVkLnByb3RvdHlwZSksICdpbmRleCcsIHRoaXMpLmNhbGwodGhpcywgbm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXN0b3JlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdG9yZShub2RlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB2b2lkIDAsXG4gICAgICAgICAgdGV4dE5vZGUgPSB2b2lkIDA7XG4gICAgICB2YXIgdGV4dCA9IG5vZGUuZGF0YS5zcGxpdChHVUFSRF9URVhUKS5qb2luKCcnKTtcbiAgICAgIGlmIChub2RlID09PSB0aGlzLmxlZnRHdWFyZCkge1xuICAgICAgICBpZiAodGhpcy5wcmV2IGluc3RhbmNlb2YgX3RleHQyLmRlZmF1bHQpIHtcbiAgICAgICAgICB2YXIgcHJldkxlbmd0aCA9IHRoaXMucHJldi5sZW5ndGgoKTtcbiAgICAgICAgICB0aGlzLnByZXYuaW5zZXJ0QXQocHJldkxlbmd0aCwgdGV4dCk7XG4gICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydE5vZGU6IHRoaXMucHJldi5kb21Ob2RlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHByZXZMZW5ndGggKyB0ZXh0Lmxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUodGV4dE5vZGUpLCB0aGlzKTtcbiAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZTogdGV4dE5vZGUsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogdGV4dC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUgPT09IHRoaXMucmlnaHRHdWFyZCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0IGluc3RhbmNlb2YgX3RleHQyLmRlZmF1bHQpIHtcbiAgICAgICAgICB0aGlzLm5leHQuaW5zZXJ0QXQoMCwgdGV4dCk7XG4gICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydE5vZGU6IHRoaXMubmV4dC5kb21Ob2RlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHRleHQubGVuZ3RoXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh0ZXh0Tm9kZSksIHRoaXMubmV4dCk7XG4gICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydE5vZGU6IHRleHROb2RlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHRleHQubGVuZ3RoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZS5kYXRhID0gR1VBUkRfVEVYVDtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgbXV0YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgKG11dGF0aW9uLnRhcmdldCA9PT0gX3RoaXMyLmxlZnRHdWFyZCB8fCBtdXRhdGlvbi50YXJnZXQgPT09IF90aGlzMi5yaWdodEd1YXJkKSkge1xuICAgICAgICAgIHZhciByYW5nZSA9IF90aGlzMi5yZXN0b3JlKG11dGF0aW9uLnRhcmdldCk7XG4gICAgICAgICAgaWYgKHJhbmdlKSBjb250ZXh0LnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFbWJlZDtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEVtYmVkO1xuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFsaWduU3R5bGUgPSBleHBvcnRzLkFsaWduQ2xhc3MgPSBleHBvcnRzLkFsaWduQXR0cmlidXRlID0gdW5kZWZpbmVkO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjb25maWcgPSB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLLFxuICB3aGl0ZWxpc3Q6IFsncmlnaHQnLCAnY2VudGVyJywgJ2p1c3RpZnknXVxufTtcblxudmFyIEFsaWduQXR0cmlidXRlID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5BdHRyaWJ1dGUoJ2FsaWduJywgJ2FsaWduJywgY29uZmlnKTtcbnZhciBBbGlnbkNsYXNzID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcygnYWxpZ24nLCAncWwtYWxpZ24nLCBjb25maWcpO1xudmFyIEFsaWduU3R5bGUgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLlN0eWxlKCdhbGlnbicsICd0ZXh0LWFsaWduJywgY29uZmlnKTtcblxuZXhwb3J0cy5BbGlnbkF0dHJpYnV0ZSA9IEFsaWduQXR0cmlidXRlO1xuZXhwb3J0cy5BbGlnbkNsYXNzID0gQWxpZ25DbGFzcztcbmV4cG9ydHMuQWxpZ25TdHlsZSA9IEFsaWduU3R5bGU7XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQmFja2dyb3VuZFN0eWxlID0gZXhwb3J0cy5CYWNrZ3JvdW5kQ2xhc3MgPSB1bmRlZmluZWQ7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9jb2xvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgQmFja2dyb3VuZENsYXNzID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcygnYmFja2dyb3VuZCcsICdxbC1iZycsIHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuSU5MSU5FXG59KTtcbnZhciBCYWNrZ3JvdW5kU3R5bGUgPSBuZXcgX2NvbG9yLkNvbG9yQXR0cmlidXRvcignYmFja2dyb3VuZCcsICdiYWNrZ3JvdW5kLWNvbG9yJywge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkVcbn0pO1xuXG5leHBvcnRzLkJhY2tncm91bmRDbGFzcyA9IEJhY2tncm91bmRDbGFzcztcbmV4cG9ydHMuQmFja2dyb3VuZFN0eWxlID0gQmFja2dyb3VuZFN0eWxlO1xuXG4vKioqLyB9KSxcbi8qIDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkRpcmVjdGlvblN0eWxlID0gZXhwb3J0cy5EaXJlY3Rpb25DbGFzcyA9IGV4cG9ydHMuRGlyZWN0aW9uQXR0cmlidXRlID0gdW5kZWZpbmVkO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjb25maWcgPSB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLLFxuICB3aGl0ZWxpc3Q6IFsncnRsJ11cbn07XG5cbnZhciBEaXJlY3Rpb25BdHRyaWJ1dGUgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkF0dHJpYnV0ZSgnZGlyZWN0aW9uJywgJ2RpcicsIGNvbmZpZyk7XG52YXIgRGlyZWN0aW9uQ2xhc3MgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkNsYXNzKCdkaXJlY3Rpb24nLCAncWwtZGlyZWN0aW9uJywgY29uZmlnKTtcbnZhciBEaXJlY3Rpb25TdHlsZSA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuU3R5bGUoJ2RpcmVjdGlvbicsICdkaXJlY3Rpb24nLCBjb25maWcpO1xuXG5leHBvcnRzLkRpcmVjdGlvbkF0dHJpYnV0ZSA9IERpcmVjdGlvbkF0dHJpYnV0ZTtcbmV4cG9ydHMuRGlyZWN0aW9uQ2xhc3MgPSBEaXJlY3Rpb25DbGFzcztcbmV4cG9ydHMuRGlyZWN0aW9uU3R5bGUgPSBEaXJlY3Rpb25TdHlsZTtcblxuLyoqKi8gfSksXG4vKiAzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Gb250Q2xhc3MgPSBleHBvcnRzLkZvbnRTdHlsZSA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNvbmZpZyA9IHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuSU5MSU5FLFxuICB3aGl0ZWxpc3Q6IFsnc2VyaWYnLCAnbW9ub3NwYWNlJ11cbn07XG5cbnZhciBGb250Q2xhc3MgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkNsYXNzKCdmb250JywgJ3FsLWZvbnQnLCBjb25maWcpO1xuXG52YXIgRm9udFN0eWxlQXR0cmlidXRvciA9IGZ1bmN0aW9uIChfUGFyY2htZW50JEF0dHJpYnV0b3IpIHtcbiAgX2luaGVyaXRzKEZvbnRTdHlsZUF0dHJpYnV0b3IsIF9QYXJjaG1lbnQkQXR0cmlidXRvcik7XG5cbiAgZnVuY3Rpb24gRm9udFN0eWxlQXR0cmlidXRvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9udFN0eWxlQXR0cmlidXRvcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZvbnRTdHlsZUF0dHJpYnV0b3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb250U3R5bGVBdHRyaWJ1dG9yKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRm9udFN0eWxlQXR0cmlidXRvciwgW3tcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG5vZGUpIHtcbiAgICAgIHJldHVybiBfZ2V0KEZvbnRTdHlsZUF0dHJpYnV0b3IucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9udFN0eWxlQXR0cmlidXRvci5wcm90b3R5cGUpLCAndmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUpLnJlcGxhY2UoL1tcIiddL2csICcnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9udFN0eWxlQXR0cmlidXRvcjtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLlN0eWxlKTtcblxudmFyIEZvbnRTdHlsZSA9IG5ldyBGb250U3R5bGVBdHRyaWJ1dG9yKCdmb250JywgJ2ZvbnQtZmFtaWx5JywgY29uZmlnKTtcblxuZXhwb3J0cy5Gb250U3R5bGUgPSBGb250U3R5bGU7XG5leHBvcnRzLkZvbnRDbGFzcyA9IEZvbnRDbGFzcztcblxuLyoqKi8gfSksXG4vKiA0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5TaXplU3R5bGUgPSBleHBvcnRzLlNpemVDbGFzcyA9IHVuZGVmaW5lZDtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgU2l6ZUNsYXNzID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcygnc2l6ZScsICdxbC1zaXplJywge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkUsXG4gIHdoaXRlbGlzdDogWydzbWFsbCcsICdsYXJnZScsICdodWdlJ11cbn0pO1xudmFyIFNpemVTdHlsZSA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuU3R5bGUoJ3NpemUnLCAnZm9udC1zaXplJywge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkUsXG4gIHdoaXRlbGlzdDogWycxMHB4JywgJzE4cHgnLCAnMzJweCddXG59KTtcblxuZXhwb3J0cy5TaXplQ2xhc3MgPSBTaXplQ2xhc3M7XG5leHBvcnRzLlNpemVTdHlsZSA9IFNpemVTdHlsZTtcblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ2FsaWduJzoge1xuICAgICcnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KSxcbiAgICAnY2VudGVyJzogX193ZWJwYWNrX3JlcXVpcmVfXyg3NyksXG4gICAgJ3JpZ2h0JzogX193ZWJwYWNrX3JlcXVpcmVfXyg3OCksXG4gICAgJ2p1c3RpZnknOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KVxuICB9LFxuICAnYmFja2dyb3VuZCc6IF9fd2VicGFja19yZXF1aXJlX18oODApLFxuICAnYmxvY2txdW90ZSc6IF9fd2VicGFja19yZXF1aXJlX18oODEpLFxuICAnYm9sZCc6IF9fd2VicGFja19yZXF1aXJlX18oODIpLFxuICAnY2xlYW4nOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzKSxcbiAgJ2NvZGUnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KSxcbiAgJ2NvZGUtYmxvY2snOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KSxcbiAgJ2NvbG9yJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4NCksXG4gICdkaXJlY3Rpb24nOiB7XG4gICAgJyc6IF9fd2VicGFja19yZXF1aXJlX18oODUpLFxuICAgICdydGwnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2KVxuICB9LFxuICAnZmxvYXQnOiB7XG4gICAgJ2NlbnRlcic6IF9fd2VicGFja19yZXF1aXJlX18oODcpLFxuICAgICdmdWxsJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4OCksXG4gICAgJ2xlZnQnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KSxcbiAgICAncmlnaHQnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKVxuICB9LFxuICAnZm9ybXVsYSc6IF9fd2VicGFja19yZXF1aXJlX18oOTEpLFxuICAnaGVhZGVyJzoge1xuICAgICcxJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5MiksXG4gICAgJzInOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzKVxuICB9LFxuICAnaXRhbGljJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5NCksXG4gICdpbWFnZSc6IF9fd2VicGFja19yZXF1aXJlX18oOTUpLFxuICAnaW5kZW50Jzoge1xuICAgICcrMSc6IF9fd2VicGFja19yZXF1aXJlX18oOTYpLFxuICAgICctMSc6IF9fd2VicGFja19yZXF1aXJlX18oOTcpXG4gIH0sXG4gICdsaW5rJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5OCksXG4gICdsaXN0Jzoge1xuICAgICdvcmRlcmVkJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5OSksXG4gICAgJ2J1bGxldCc6IF9fd2VicGFja19yZXF1aXJlX18oMTAwKSxcbiAgICAnY2hlY2snOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSlcbiAgfSxcbiAgJ3NjcmlwdCc6IHtcbiAgICAnc3ViJzogX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpLFxuICAgICdzdXBlcic6IF9fd2VicGFja19yZXF1aXJlX18oMTAzKVxuICB9LFxuICAnc3RyaWtlJzogX193ZWJwYWNrX3JlcXVpcmVfXygxMDQpLFxuICAndW5kZXJsaW5lJzogX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpLFxuICAndmlkZW8nOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNilcbn07XG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0TGFzdENoYW5nZUluZGV4ID0gZXhwb3J0cy5kZWZhdWx0ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfcXVpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX3F1aWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsKTtcblxudmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBIaXN0b3J5ID0gZnVuY3Rpb24gKF9Nb2R1bGUpIHtcbiAgX2luaGVyaXRzKEhpc3RvcnksIF9Nb2R1bGUpO1xuXG4gIGZ1bmN0aW9uIEhpc3RvcnkocXVpbGwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGlzdG9yeSk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSGlzdG9yeS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEhpc3RvcnkpKS5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5sYXN0UmVjb3JkZWQgPSAwO1xuICAgIF90aGlzLmlnbm9yZUNoYW5nZSA9IGZhbHNlO1xuICAgIF90aGlzLmNsZWFyKCk7XG4gICAgX3RoaXMucXVpbGwub24oX3F1aWxsMi5kZWZhdWx0LmV2ZW50cy5FRElUT1JfQ0hBTkdFLCBmdW5jdGlvbiAoZXZlbnROYW1lLCBkZWx0YSwgb2xkRGVsdGEsIHNvdXJjZSkge1xuICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gX3F1aWxsMi5kZWZhdWx0LmV2ZW50cy5URVhUX0NIQU5HRSB8fCBfdGhpcy5pZ25vcmVDaGFuZ2UpIHJldHVybjtcbiAgICAgIGlmICghX3RoaXMub3B0aW9ucy51c2VyT25seSB8fCBzb3VyY2UgPT09IF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpIHtcbiAgICAgICAgX3RoaXMucmVjb3JkKGRlbHRhLCBvbGREZWx0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy50cmFuc2Zvcm0oZGVsdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90aGlzLnF1aWxsLmtleWJvYXJkLmFkZEJpbmRpbmcoeyBrZXk6ICdaJywgc2hvcnRLZXk6IHRydWUgfSwgX3RoaXMudW5kby5iaW5kKF90aGlzKSk7XG4gICAgX3RoaXMucXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7IGtleTogJ1onLCBzaG9ydEtleTogdHJ1ZSwgc2hpZnRLZXk6IHRydWUgfSwgX3RoaXMucmVkby5iaW5kKF90aGlzKSk7XG4gICAgaWYgKC9XaW4vaS50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkpIHtcbiAgICAgIF90aGlzLnF1aWxsLmtleWJvYXJkLmFkZEJpbmRpbmcoeyBrZXk6ICdZJywgc2hvcnRLZXk6IHRydWUgfSwgX3RoaXMucmVkby5iaW5kKF90aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIaXN0b3J5LCBbe1xuICAgIGtleTogJ2NoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoYW5nZShzb3VyY2UsIGRlc3QpIHtcbiAgICAgIGlmICh0aGlzLnN0YWNrW3NvdXJjZV0ubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgZGVsdGEgPSB0aGlzLnN0YWNrW3NvdXJjZV0ucG9wKCk7XG4gICAgICB0aGlzLnN0YWNrW2Rlc3RdLnB1c2goZGVsdGEpO1xuICAgICAgdGhpcy5sYXN0UmVjb3JkZWQgPSAwO1xuICAgICAgdGhpcy5pZ25vcmVDaGFuZ2UgPSB0cnVlO1xuICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YVtzb3VyY2VdLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIHRoaXMuaWdub3JlQ2hhbmdlID0gZmFsc2U7XG4gICAgICB2YXIgaW5kZXggPSBnZXRMYXN0Q2hhbmdlSW5kZXgoZGVsdGFbc291cmNlXSk7XG4gICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2xlYXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuc3RhY2sgPSB7IHVuZG86IFtdLCByZWRvOiBbXSB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2N1dG9mZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1dG9mZigpIHtcbiAgICAgIHRoaXMubGFzdFJlY29yZGVkID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWNvcmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvcmQoY2hhbmdlRGVsdGEsIG9sZERlbHRhKSB7XG4gICAgICBpZiAoY2hhbmdlRGVsdGEub3BzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdGhpcy5zdGFjay5yZWRvID0gW107XG4gICAgICB2YXIgdW5kb0RlbHRhID0gdGhpcy5xdWlsbC5nZXRDb250ZW50cygpLmRpZmYob2xkRGVsdGEpO1xuICAgICAgdmFyIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICBpZiAodGhpcy5sYXN0UmVjb3JkZWQgKyB0aGlzLm9wdGlvbnMuZGVsYXkgPiB0aW1lc3RhbXAgJiYgdGhpcy5zdGFjay51bmRvLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGRlbHRhID0gdGhpcy5zdGFjay51bmRvLnBvcCgpO1xuICAgICAgICB1bmRvRGVsdGEgPSB1bmRvRGVsdGEuY29tcG9zZShkZWx0YS51bmRvKTtcbiAgICAgICAgY2hhbmdlRGVsdGEgPSBkZWx0YS5yZWRvLmNvbXBvc2UoY2hhbmdlRGVsdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXN0UmVjb3JkZWQgPSB0aW1lc3RhbXA7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YWNrLnVuZG8ucHVzaCh7XG4gICAgICAgIHJlZG86IGNoYW5nZURlbHRhLFxuICAgICAgICB1bmRvOiB1bmRvRGVsdGFcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuc3RhY2sudW5kby5sZW5ndGggPiB0aGlzLm9wdGlvbnMubWF4U3RhY2spIHtcbiAgICAgICAgdGhpcy5zdGFjay51bmRvLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVkbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZG8oKSB7XG4gICAgICB0aGlzLmNoYW5nZSgncmVkbycsICd1bmRvJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHJhbnNmb3JtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtKGRlbHRhKSB7XG4gICAgICB0aGlzLnN0YWNrLnVuZG8uZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgIGNoYW5nZS51bmRvID0gZGVsdGEudHJhbnNmb3JtKGNoYW5nZS51bmRvLCB0cnVlKTtcbiAgICAgICAgY2hhbmdlLnJlZG8gPSBkZWx0YS50cmFuc2Zvcm0oY2hhbmdlLnJlZG8sIHRydWUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0YWNrLnJlZG8uZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgIGNoYW5nZS51bmRvID0gZGVsdGEudHJhbnNmb3JtKGNoYW5nZS51bmRvLCB0cnVlKTtcbiAgICAgICAgY2hhbmdlLnJlZG8gPSBkZWx0YS50cmFuc2Zvcm0oY2hhbmdlLnJlZG8sIHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW5kbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgICB0aGlzLmNoYW5nZSgndW5kbycsICdyZWRvJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhpc3Rvcnk7XG59KF9tb2R1bGUyLmRlZmF1bHQpO1xuXG5IaXN0b3J5LkRFRkFVTFRTID0ge1xuICBkZWxheTogMTAwMCxcbiAgbWF4U3RhY2s6IDEwMCxcbiAgdXNlck9ubHk6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBlbmRzV2l0aE5ld2xpbmVDaGFuZ2UoZGVsdGEpIHtcbiAgdmFyIGxhc3RPcCA9IGRlbHRhLm9wc1tkZWx0YS5vcHMubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0T3AgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAobGFzdE9wLmluc2VydCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBsYXN0T3AuaW5zZXJ0ID09PSAnc3RyaW5nJyAmJiBsYXN0T3AuaW5zZXJ0LmVuZHNXaXRoKCdcXG4nKTtcbiAgfVxuICBpZiAobGFzdE9wLmF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhsYXN0T3AuYXR0cmlidXRlcykuc29tZShmdW5jdGlvbiAoYXR0cikge1xuICAgICAgcmV0dXJuIF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkoYXR0ciwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSykgIT0gbnVsbDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldExhc3RDaGFuZ2VJbmRleChkZWx0YSkge1xuICB2YXIgZGVsZXRlTGVuZ3RoID0gZGVsdGEucmVkdWNlKGZ1bmN0aW9uIChsZW5ndGgsIG9wKSB7XG4gICAgbGVuZ3RoICs9IG9wLmRlbGV0ZSB8fCAwO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH0sIDApO1xuICB2YXIgY2hhbmdlSW5kZXggPSBkZWx0YS5sZW5ndGgoKSAtIGRlbGV0ZUxlbmd0aDtcbiAgaWYgKGVuZHNXaXRoTmV3bGluZUNoYW5nZShkZWx0YSkpIHtcbiAgICBjaGFuZ2VJbmRleCAtPSAxO1xuICB9XG4gIHJldHVybiBjaGFuZ2VJbmRleDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gSGlzdG9yeTtcbmV4cG9ydHMuZ2V0TGFzdENoYW5nZUluZGV4ID0gZ2V0TGFzdENoYW5nZUluZGV4O1xuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkJhc2VUb29sdGlwID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblxudmFyIF9xdWlsbERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9xdWlsbERlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsRGVsdGEpO1xuXG52YXIgX2VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2VtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW1pdHRlcik7XG5cbnZhciBfa2V5Ym9hcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIF9rZXlib2FyZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlib2FyZCk7XG5cbnZhciBfdGhlbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblxudmFyIF90aGVtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aGVtZSk7XG5cbnZhciBfY29sb3JQaWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcblxudmFyIF9jb2xvclBpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2xvclBpY2tlcik7XG5cbnZhciBfaWNvblBpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xuXG52YXIgX2ljb25QaWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaWNvblBpY2tlcik7XG5cbnZhciBfcGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbnZhciBfcGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpY2tlcik7XG5cbnZhciBfdG9vbHRpcCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xuXG52YXIgX3Rvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9vbHRpcCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEFMSUdOUyA9IFtmYWxzZSwgJ2NlbnRlcicsICdyaWdodCcsICdqdXN0aWZ5J107XG5cbnZhciBDT0xPUlMgPSBbXCIjMDAwMDAwXCIsIFwiI2U2MDAwMFwiLCBcIiNmZjk5MDBcIiwgXCIjZmZmZjAwXCIsIFwiIzAwOGEwMFwiLCBcIiMwMDY2Y2NcIiwgXCIjOTkzM2ZmXCIsIFwiI2ZmZmZmZlwiLCBcIiNmYWNjY2NcIiwgXCIjZmZlYmNjXCIsIFwiI2ZmZmZjY1wiLCBcIiNjY2U4Y2NcIiwgXCIjY2NlMGY1XCIsIFwiI2ViZDZmZlwiLCBcIiNiYmJiYmJcIiwgXCIjZjA2NjY2XCIsIFwiI2ZmYzI2NlwiLCBcIiNmZmZmNjZcIiwgXCIjNjZiOTY2XCIsIFwiIzY2YTNlMFwiLCBcIiNjMjg1ZmZcIiwgXCIjODg4ODg4XCIsIFwiI2ExMDAwMFwiLCBcIiNiMjZiMDBcIiwgXCIjYjJiMjAwXCIsIFwiIzAwNjEwMFwiLCBcIiMwMDQ3YjJcIiwgXCIjNmIyNGIyXCIsIFwiIzQ0NDQ0NFwiLCBcIiM1YzAwMDBcIiwgXCIjNjYzZDAwXCIsIFwiIzY2NjYwMFwiLCBcIiMwMDM3MDBcIiwgXCIjMDAyOTY2XCIsIFwiIzNkMTQ2NlwiXTtcblxudmFyIEZPTlRTID0gW2ZhbHNlLCAnc2VyaWYnLCAnbW9ub3NwYWNlJ107XG5cbnZhciBIRUFERVJTID0gWycxJywgJzInLCAnMycsIGZhbHNlXTtcblxudmFyIFNJWkVTID0gWydzbWFsbCcsIGZhbHNlLCAnbGFyZ2UnLCAnaHVnZSddO1xuXG52YXIgQmFzZVRoZW1lID0gZnVuY3Rpb24gKF9UaGVtZSkge1xuICBfaW5oZXJpdHMoQmFzZVRoZW1lLCBfVGhlbWUpO1xuXG4gIGZ1bmN0aW9uIEJhc2VUaGVtZShxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlVGhlbWUpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJhc2VUaGVtZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJhc2VUaGVtZSkpLmNhbGwodGhpcywgcXVpbGwsIG9wdGlvbnMpKTtcblxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKGUpIHtcbiAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhxdWlsbC5yb290KSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy50b29sdGlwICE9IG51bGwgJiYgIV90aGlzLnRvb2x0aXAucm9vdC5jb250YWlucyhlLnRhcmdldCkgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gX3RoaXMudG9vbHRpcC50ZXh0Ym94ICYmICFfdGhpcy5xdWlsbC5oYXNGb2N1cygpKSB7XG4gICAgICAgIF90aGlzLnRvb2x0aXAuaGlkZSgpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLnBpY2tlcnMgIT0gbnVsbCkge1xuICAgICAgICBfdGhpcy5waWNrZXJzLmZvckVhY2goZnVuY3Rpb24gKHBpY2tlcikge1xuICAgICAgICAgIGlmICghcGlja2VyLmNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHBpY2tlci5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBxdWlsbC5lbWl0dGVyLmxpc3RlbkRPTSgnY2xpY2snLCBkb2N1bWVudC5ib2R5LCBsaXN0ZW5lcik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VUaGVtZSwgW3tcbiAgICBrZXk6ICdhZGRNb2R1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNb2R1bGUobmFtZSkge1xuICAgICAgdmFyIG1vZHVsZSA9IF9nZXQoQmFzZVRoZW1lLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJhc2VUaGVtZS5wcm90b3R5cGUpLCAnYWRkTW9kdWxlJywgdGhpcykuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIGlmIChuYW1lID09PSAndG9vbGJhcicpIHtcbiAgICAgICAgdGhpcy5leHRlbmRUb29sYmFyKG1vZHVsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkQnV0dG9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkQnV0dG9ucyhidXR0b25zLCBpY29ucykge1xuICAgICAgYnV0dG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChidXR0b24pIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gICAgICAgIGNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBpZiAoIW5hbWUuc3RhcnRzV2l0aCgncWwtJykpIHJldHVybjtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgncWwtJy5sZW5ndGgpO1xuICAgICAgICAgIGlmIChpY29uc1tuYW1lXSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICdkaXJlY3Rpb24nKSB7XG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gaWNvbnNbbmFtZV1bJyddICsgaWNvbnNbbmFtZV1bJ3J0bCddO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGljb25zW25hbWVdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9IGljb25zW25hbWVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBidXR0b24udmFsdWUgfHwgJyc7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBpY29uc1tuYW1lXVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9IGljb25zW25hbWVdW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGRQaWNrZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRQaWNrZXJzKHNlbGVjdHMsIGljb25zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5waWNrZXJzID0gc2VsZWN0cy5tYXAoZnVuY3Rpb24gKHNlbGVjdCkge1xuICAgICAgICBpZiAoc2VsZWN0LmNsYXNzTGlzdC5jb250YWlucygncWwtYWxpZ24nKSkge1xuICAgICAgICAgIGlmIChzZWxlY3QucXVlcnlTZWxlY3Rvcignb3B0aW9uJykgPT0gbnVsbCkge1xuICAgICAgICAgICAgZmlsbFNlbGVjdChzZWxlY3QsIEFMSUdOUyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgX2ljb25QaWNrZXIyLmRlZmF1bHQoc2VsZWN0LCBpY29ucy5hbGlnbik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0LmNsYXNzTGlzdC5jb250YWlucygncWwtYmFja2dyb3VuZCcpIHx8IHNlbGVjdC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWNvbG9yJykpIHtcbiAgICAgICAgICB2YXIgZm9ybWF0ID0gc2VsZWN0LmNsYXNzTGlzdC5jb250YWlucygncWwtYmFja2dyb3VuZCcpID8gJ2JhY2tncm91bmQnIDogJ2NvbG9yJztcbiAgICAgICAgICBpZiAoc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvbicpID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbGxTZWxlY3Qoc2VsZWN0LCBDT0xPUlMsIGZvcm1hdCA9PT0gJ2JhY2tncm91bmQnID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBfY29sb3JQaWNrZXIyLmRlZmF1bHQoc2VsZWN0LCBpY29uc1tmb3JtYXRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvbicpID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1mb250JykpIHtcbiAgICAgICAgICAgICAgZmlsbFNlbGVjdChzZWxlY3QsIEZPTlRTKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0LmNsYXNzTGlzdC5jb250YWlucygncWwtaGVhZGVyJykpIHtcbiAgICAgICAgICAgICAgZmlsbFNlbGVjdChzZWxlY3QsIEhFQURFUlMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1zaXplJykpIHtcbiAgICAgICAgICAgICAgZmlsbFNlbGVjdChzZWxlY3QsIFNJWkVTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBfcGlja2VyMi5kZWZhdWx0KHNlbGVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgX3RoaXMyLnBpY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAocGlja2VyKSB7XG4gICAgICAgICAgcGlja2VyLnVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0aGlzLnF1aWxsLm9uKF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5FRElUT1JfQ0hBTkdFLCB1cGRhdGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlVGhlbWU7XG59KF90aGVtZTIuZGVmYXVsdCk7XG5cbkJhc2VUaGVtZS5ERUZBVUxUUyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KSh0cnVlLCB7fSwgX3RoZW1lMi5kZWZhdWx0LkRFRkFVTFRTLCB7XG4gIG1vZHVsZXM6IHtcbiAgICB0b29sYmFyOiB7XG4gICAgICBoYW5kbGVyczoge1xuICAgICAgICBmb3JtdWxhOiBmdW5jdGlvbiBmb3JtdWxhKCkge1xuICAgICAgICAgIHRoaXMucXVpbGwudGhlbWUudG9vbHRpcC5lZGl0KCdmb3JtdWxhJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlOiBmdW5jdGlvbiBpbWFnZSgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgIHZhciBmaWxlSW5wdXQgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdpbnB1dC5xbC1pbWFnZVt0eXBlPWZpbGVdJyk7XG4gICAgICAgICAgaWYgKGZpbGVJbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgZmlsZUlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdmaWxlJyk7XG4gICAgICAgICAgICBmaWxlSW5wdXQuc2V0QXR0cmlidXRlKCdhY2NlcHQnLCAnaW1hZ2UvcG5nLCBpbWFnZS9naWYsIGltYWdlL2pwZWcsIGltYWdlL2JtcCwgaW1hZ2UveC1pY29uJyk7XG4gICAgICAgICAgICBmaWxlSW5wdXQuY2xhc3NMaXN0LmFkZCgncWwtaW1hZ2UnKTtcbiAgICAgICAgICAgIGZpbGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChmaWxlSW5wdXQuZmlsZXMgIT0gbnVsbCAmJiBmaWxlSW5wdXQuZmlsZXNbMF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMzLnF1aWxsLmdldFNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgIF90aGlzMy5xdWlsbC51cGRhdGVDb250ZW50cyhuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpLmRlbGV0ZShyYW5nZS5sZW5ndGgpLmluc2VydCh7IGltYWdlOiBlLnRhcmdldC5yZXN1bHQgfSksIF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgICAgICAgICAgICBfdGhpczMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgMSwgX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgICAgICAgICAgICAgZmlsZUlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGVJbnB1dC5maWxlc1swXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsZUlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlsZUlucHV0LmNsaWNrKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHZpZGVvOiBmdW5jdGlvbiB2aWRlbygpIHtcbiAgICAgICAgICB0aGlzLnF1aWxsLnRoZW1lLnRvb2x0aXAuZWRpdCgndmlkZW8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBCYXNlVG9vbHRpcCA9IGZ1bmN0aW9uIChfVG9vbHRpcCkge1xuICBfaW5oZXJpdHMoQmFzZVRvb2x0aXAsIF9Ub29sdGlwKTtcblxuICBmdW5jdGlvbiBCYXNlVG9vbHRpcChxdWlsbCwgYm91bmRzQ29udGFpbmVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VUb29sdGlwKTtcblxuICAgIHZhciBfdGhpczQgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQmFzZVRvb2x0aXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXNlVG9vbHRpcCkpLmNhbGwodGhpcywgcXVpbGwsIGJvdW5kc0NvbnRhaW5lcikpO1xuXG4gICAgX3RoaXM0LnRleHRib3ggPSBfdGhpczQucm9vdC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwidGV4dFwiXScpO1xuICAgIF90aGlzNC5saXN0ZW4oKTtcbiAgICByZXR1cm4gX3RoaXM0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VUb29sdGlwLCBbe1xuICAgIGtleTogJ2xpc3RlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbigpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB0aGlzLnRleHRib3guYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoX2tleWJvYXJkMi5kZWZhdWx0Lm1hdGNoKGV2ZW50LCAnZW50ZXInKSkge1xuICAgICAgICAgIF90aGlzNS5zYXZlKCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChfa2V5Ym9hcmQyLmRlZmF1bHQubWF0Y2goZXZlbnQsICdlc2NhcGUnKSkge1xuICAgICAgICAgIF90aGlzNS5jYW5jZWwoKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYW5jZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlZGl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdCgpIHtcbiAgICAgIHZhciBtb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnbGluayc7XG4gICAgICB2YXIgcHJldmlldyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5yZW1vdmUoJ3FsLWhpZGRlbicpO1xuICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5hZGQoJ3FsLWVkaXRpbmcnKTtcbiAgICAgIGlmIChwcmV2aWV3ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy50ZXh0Ym94LnZhbHVlID0gcHJldmlldztcbiAgICAgIH0gZWxzZSBpZiAobW9kZSAhPT0gdGhpcy5yb290LmdldEF0dHJpYnV0ZSgnZGF0YS1tb2RlJykpIHtcbiAgICAgICAgdGhpcy50ZXh0Ym94LnZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICB0aGlzLnBvc2l0aW9uKHRoaXMucXVpbGwuZ2V0Qm91bmRzKHRoaXMucXVpbGwuc2VsZWN0aW9uLnNhdmVkUmFuZ2UpKTtcbiAgICAgIHRoaXMudGV4dGJveC5zZWxlY3QoKTtcbiAgICAgIHRoaXMudGV4dGJveC5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgdGhpcy50ZXh0Ym94LmdldEF0dHJpYnV0ZSgnZGF0YS0nICsgbW9kZSkgfHwgJycpO1xuICAgICAgdGhpcy5yb290LnNldEF0dHJpYnV0ZSgnZGF0YS1tb2RlJywgbW9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzdG9yZUZvY3VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdG9yZUZvY3VzKCkge1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMucXVpbGwuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgIHRoaXMucXVpbGwuZm9jdXMoKTtcbiAgICAgIHRoaXMucXVpbGwuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzYXZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudGV4dGJveC52YWx1ZTtcbiAgICAgIHN3aXRjaCAodGhpcy5yb290LmdldEF0dHJpYnV0ZSgnZGF0YS1tb2RlJykpIHtcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMucXVpbGwucm9vdC5zY3JvbGxUb3A7XG4gICAgICAgICAgICBpZiAodGhpcy5saW5rUmFuZ2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXRUZXh0KHRoaXMubGlua1JhbmdlLCAnbGluaycsIHZhbHVlLCBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5saW5rUmFuZ2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVGb2N1cygpO1xuICAgICAgICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGluaycsIHZhbHVlLCBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5xdWlsbC5yb290LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlID0gZXh0cmFjdFZpZGVvVXJsKHZhbHVlKTtcbiAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICBjYXNlICdmb3JtdWxhJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSBicmVhaztcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgICAgaWYgKHJhbmdlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICAgIHRoaXMucXVpbGwuaW5zZXJ0RW1iZWQoaW5kZXgsIHRoaXMucm9vdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kZScpLCB2YWx1ZSwgX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucm9vdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kZScpID09PSAnZm9ybXVsYScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1aWxsLmluc2VydFRleHQoaW5kZXggKyAxLCAnICcsIF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oaW5kZXggKyAyLCBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgICAgdGhpcy50ZXh0Ym94LnZhbHVlID0gJyc7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZVRvb2x0aXA7XG59KF90b29sdGlwMi5kZWZhdWx0KTtcblxuZnVuY3Rpb24gZXh0cmFjdFZpZGVvVXJsKHVybCkge1xuICB2YXIgbWF0Y2ggPSB1cmwubWF0Y2goL14oPzooaHR0cHM/KTpcXC9cXC8pPyg/Oig/Ond3d3xtKVxcLik/eW91dHViZVxcLmNvbVxcL3dhdGNoLip2PShbYS16QS1aMC05Xy1dKykvKSB8fCB1cmwubWF0Y2goL14oPzooaHR0cHM/KTpcXC9cXC8pPyg/Oig/Ond3d3xtKVxcLik/eW91dHVcXC5iZVxcLyhbYS16QS1aMC05Xy1dKykvKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIChtYXRjaFsxXSB8fCAnaHR0cHMnKSArICc6Ly93d3cueW91dHViZS5jb20vZW1iZWQvJyArIG1hdGNoWzJdICsgJz9zaG93aW5mbz0wJztcbiAgfVxuICBpZiAobWF0Y2ggPSB1cmwubWF0Y2goL14oPzooaHR0cHM/KTpcXC9cXC8pPyg/Ond3d1xcLik/dmltZW9cXC5jb21cXC8oXFxkKykvKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICByZXR1cm4gKG1hdGNoWzFdIHx8ICdodHRwcycpICsgJzovL3BsYXllci52aW1lby5jb20vdmlkZW8vJyArIG1hdGNoWzJdICsgJy8nO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIGZpbGxTZWxlY3Qoc2VsZWN0LCB2YWx1ZXMpIHtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgIGlmICh2YWx1ZSA9PT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICBvcHRpb24uc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICdzZWxlY3RlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb24uc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgICB9XG4gICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gIH0pO1xufVxuXG5leHBvcnRzLkJhc2VUb29sdGlwID0gQmFzZVRvb2x0aXA7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlVGhlbWU7XG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMaW5rZWRMaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmtlZExpc3QoKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5vZGVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobm9kZXNbMF0sIG51bGwpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQuYXBwbHkodGhpcywgbm9kZXMuc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBjdXIsIG5leHQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIHdoaWxlICgoY3VyID0gbmV4dCgpKSkge1xuICAgICAgICAgICAgaWYgKGN1ciA9PT0gbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAobm9kZSwgcmVmTm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG5vZGUubmV4dCA9IHJlZk5vZGU7XG4gICAgICAgIGlmIChyZWZOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUucHJldiA9IHJlZk5vZGUucHJldjtcbiAgICAgICAgICAgIGlmIChyZWZOb2RlLnByZXYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlZk5vZGUucHJldi5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZk5vZGUucHJldiA9IG5vZGU7XG4gICAgICAgICAgICBpZiAocmVmTm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnRhaWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5wcmV2ID0gdGhpcy50YWlsO1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUucHJldiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDE7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBpbmRleCA9IDAsIGN1ciA9IHRoaXMuaGVhZDtcbiAgICAgICAgd2hpbGUgKGN1ciAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3VyID09PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgaW5kZXggKz0gY3VyLmxlbmd0aCgpO1xuICAgICAgICAgICAgY3VyID0gY3VyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5zKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAobm9kZS5wcmV2ICE9IG51bGwpXG4gICAgICAgICAgICBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgaWYgKG5vZGUubmV4dCAhPSBudWxsKVxuICAgICAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLmhlYWQpXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlLm5leHQ7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLnRhaWwpXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlLnByZXY7XG4gICAgICAgIHRoaXMubGVuZ3RoIC09IDE7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIChjdXJOb2RlKSB7XG4gICAgICAgIGlmIChjdXJOb2RlID09PSB2b2lkIDApIHsgY3VyTm9kZSA9IHRoaXMuaGVhZDsgfVxuICAgICAgICAvLyBUT0RPIHVzZSB5aWVsZCB3aGVuIHdlIGNhblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJldCA9IGN1ck5vZGU7XG4gICAgICAgICAgICBpZiAoY3VyTm9kZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGN1ck5vZGUgPSBjdXJOb2RlLm5leHQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChpbmRleCwgaW5jbHVzaXZlKSB7XG4gICAgICAgIGlmIChpbmNsdXNpdmUgPT09IHZvaWQgMCkgeyBpbmNsdXNpdmUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgY3VyLCBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAoKGN1ciA9IG5leHQoKSkpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBjdXIubGVuZ3RoKCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggfHxcbiAgICAgICAgICAgICAgICAoaW5jbHVzaXZlICYmIGluZGV4ID09PSBsZW5ndGggJiYgKGN1ci5uZXh0ID09IG51bGwgfHwgY3VyLm5leHQubGVuZ3RoKCkgIT09IDApKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbY3VyLCBpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCAtPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtudWxsLCAwXTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGN1ciwgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgd2hpbGUgKChjdXIgPSBuZXh0KCkpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhjdXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5mb3JFYWNoQXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmZpbmQoaW5kZXgpLCBzdGFydE5vZGUgPSBfYVswXSwgb2Zmc2V0ID0gX2FbMV07XG4gICAgICAgIHZhciBjdXIsIGN1ckluZGV4ID0gaW5kZXggLSBvZmZzZXQsIG5leHQgPSB0aGlzLml0ZXJhdG9yKHN0YXJ0Tm9kZSk7XG4gICAgICAgIHdoaWxlICgoY3VyID0gbmV4dCgpKSAmJiBjdXJJbmRleCA8IGluZGV4ICsgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY3VyTGVuZ3RoID0gY3VyLmxlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gY3VySW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjdXIsIGluZGV4IC0gY3VySW5kZXgsIE1hdGgubWluKGxlbmd0aCwgY3VySW5kZXggKyBjdXJMZW5ndGggLSBpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY3VyLCAwLCBNYXRoLm1pbihjdXJMZW5ndGgsIGluZGV4ICsgbGVuZ3RoIC0gY3VySW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ckluZGV4ICs9IGN1ckxlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgY3VyKSB7XG4gICAgICAgICAgICBtZW1vLnB1c2goY2FsbGJhY2soY3VyKSk7XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBtZW1vKSB7XG4gICAgICAgIHZhciBjdXIsIG5leHQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIHdoaWxlICgoY3VyID0gbmV4dCgpKSkge1xuICAgICAgICAgICAgbWVtbyA9IGNhbGxiYWNrKG1lbW8sIGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgICByZXR1cm4gTGlua2VkTGlzdDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBMaW5rZWRMaXN0O1xuXG5cbi8qKiovIH0pLFxuLyogNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRhaW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIE9CU0VSVkVSX0NPTkZJRyA9IHtcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlLFxuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlLFxufTtcbnZhciBNQVhfT1BUSU1JWkVfSVRFUkFUSU9OUyA9IDEwMDtcbnZhciBTY3JvbGxCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY3JvbGxCbG90LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNjcm9sbEJsb3Qobm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBub2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zY3JvbGwgPSBfdGhpcztcbiAgICAgICAgX3RoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGUobXV0YXRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9ic2VydmVyLm9ic2VydmUoX3RoaXMuZG9tTm9kZSwgT0JTRVJWRVJfQ09ORklHKTtcbiAgICAgICAgX3RoaXMuYXR0YWNoKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2Nyb2xsQmxvdC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRldGFjaC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICAgIFNjcm9sbEJsb3QucHJvdG90eXBlLmRlbGV0ZUF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwICYmIGxlbmd0aCA9PT0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlbGV0ZUF0LmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbEJsb3QucHJvdG90eXBlLmZvcm1hdEF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9ybWF0QXQuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBTY3JvbGxCbG90LnByb3RvdHlwZS5pbnNlcnRBdCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluc2VydEF0LmNhbGwodGhpcywgaW5kZXgsIHZhbHVlLCBkZWYpO1xuICAgIH07XG4gICAgU2Nyb2xsQmxvdC5wcm90b3R5cGUub3B0aW1pemUgPSBmdW5jdGlvbiAobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChtdXRhdGlvbnMgPT09IHZvaWQgMCkgeyBtdXRhdGlvbnMgPSBbXTsgfVxuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSB7fTsgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9wdGltaXplLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgIC8vIFdlIG11c3QgbW9kaWZ5IG11dGF0aW9ucyBkaXJlY3RseSwgY2Fubm90IG1ha2UgY29weSBhbmQgdGhlbiBtb2RpZnlcbiAgICAgICAgdmFyIHJlY29yZHMgPSBbXS5zbGljZS5jYWxsKHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgICAgIC8vIEFycmF5LnB1c2ggY3VycmVudGx5IHNlZW1zIHRvIGJlIGltcGxlbWVudGVkIGJ5IGEgbm9uLXRhaWwgcmVjdXJzaXZlIGZ1bmN0aW9uXG4gICAgICAgIC8vIHNvIHdlIGNhbm5vdCBqdXN0IG11dGF0aW9ucy5wdXNoLmFwcGx5KG11dGF0aW9ucywgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICAgICAgd2hpbGUgKHJlY29yZHMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIG11dGF0aW9ucy5wdXNoKHJlY29yZHMucG9wKCkpO1xuICAgICAgICAvLyBUT0RPIHVzZSBXZWFrTWFwXG4gICAgICAgIHZhciBtYXJrID0gZnVuY3Rpb24gKGJsb3QsIG1hcmtQYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChtYXJrUGFyZW50ID09PSB2b2lkIDApIHsgbWFya1BhcmVudCA9IHRydWU7IH1cbiAgICAgICAgICAgIGlmIChibG90ID09IG51bGwgfHwgYmxvdCA9PT0gX3RoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGJsb3QuZG9tTm9kZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKGJsb3QuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgYmxvdC5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXJrUGFyZW50KVxuICAgICAgICAgICAgICAgIG1hcmsoYmxvdC5wYXJlbnQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb3B0aW1pemUgPSBmdW5jdGlvbiAoYmxvdCkge1xuICAgICAgICAgICAgLy8gUG9zdC1vcmRlciB0cmF2ZXJzYWxcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGJsb3QuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb3QgaW5zdGFuY2VvZiBjb250YWluZXJfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgYmxvdC5jaGlsZHJlbi5mb3JFYWNoKG9wdGltaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb3Qub3B0aW1pemUoY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBtdXRhdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyByZW1haW5pbmcubGVuZ3RoID4gMDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBNQVhfT1BUSU1JWkVfSVRFUkFUSU9OUykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1BhcmNobWVudF0gTWF4aW11bSBvcHRpbWl6ZSBpdGVyYXRpb25zIHJlYWNoZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbWFpbmluZy5mb3JFYWNoKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBibG90ID0gUmVnaXN0cnkuZmluZChtdXRhdGlvbi50YXJnZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChibG90ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoYmxvdC5kb21Ob2RlID09PSBtdXRhdGlvbi50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrKFJlZ2lzdHJ5LmZpbmQobXV0YXRpb24ucHJldmlvdXNTaWJsaW5nLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKG11dGF0aW9uLmFkZGVkTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gUmVnaXN0cnkuZmluZChub2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyayhjaGlsZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIGNvbnRhaW5lcl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoZ3JhbmRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyayhncmFuZENoaWxkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyayhibG90LnByZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcmsoYmxvdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChvcHRpbWl6ZSk7XG4gICAgICAgICAgICByZW1haW5pbmcgPSBbXS5zbGljZS5jYWxsKHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgICAgICAgICByZWNvcmRzID0gcmVtYWluaW5nLnNsaWNlKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVjb3Jkcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIG11dGF0aW9ucy5wdXNoKHJlY29yZHMucG9wKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY3JvbGxCbG90LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IHt9OyB9XG4gICAgICAgIG11dGF0aW9ucyA9IG11dGF0aW9ucyB8fCB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgIC8vIFRPRE8gdXNlIFdlYWtNYXBcbiAgICAgICAgbXV0YXRpb25zXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICAgICAgdmFyIGJsb3QgPSBSZWdpc3RyeS5maW5kKG11dGF0aW9uLnRhcmdldCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoYmxvdCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKGJsb3QuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgYmxvdC5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnMgPSBbbXV0YXRpb25dO1xuICAgICAgICAgICAgICAgIHJldHVybiBibG90O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGJsb3QuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zLnB1c2gobXV0YXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGJsb3QpIHtcbiAgICAgICAgICAgIGlmIChibG90ID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICBibG90ID09PSBfdGhpcyB8fFxuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGJsb3QuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0gPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBibG90LnVwZGF0ZShibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucyB8fCBbXSwgY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh0aGlzLmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIHRoaXMuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGltaXplKG11dGF0aW9ucywgY29udGV4dCk7XG4gICAgfTtcbiAgICBTY3JvbGxCbG90LmJsb3ROYW1lID0gJ3Njcm9sbCc7XG4gICAgU2Nyb2xsQmxvdC5kZWZhdWx0Q2hpbGQgPSAnYmxvY2snO1xuICAgIFNjcm9sbEJsb3Quc2NvcGUgPSBSZWdpc3RyeS5TY29wZS5CTE9DS19CTE9UO1xuICAgIFNjcm9sbEJsb3QudGFnTmFtZSA9ICdESVYnO1xuICAgIHJldHVybiBTY3JvbGxCbG90O1xufShjb250YWluZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTY3JvbGxCbG90O1xuXG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGZvcm1hdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLy8gU2hhbGxvdyBvYmplY3QgY29tcGFyaXNvblxuZnVuY3Rpb24gaXNFcXVhbChvYmoxLCBvYmoyKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqMSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChvYmoxW3Byb3BdICE9PSBvYmoyW3Byb3BdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBJbmxpbmVCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmxpbmVCbG90LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElubGluZUJsb3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSW5saW5lQmxvdC5mb3JtYXRzID0gZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgaWYgKGRvbU5vZGUudGFnTmFtZSA9PT0gSW5saW5lQmxvdC50YWdOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5mb3JtYXRzLmNhbGwodGhpcywgZG9tTm9kZSk7XG4gICAgfTtcbiAgICBJbmxpbmVCbG90LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIGZvcm1hdF8xLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQud3JhcChJbmxpbmVCbG90LmJsb3ROYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlcy5jb3B5KGNoaWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51bndyYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9ybWF0LmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmxpbmVCbG90LnByb3RvdHlwZS5mb3JtYXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5mb3JtYXRzKClbbmFtZV0gIT0gbnVsbCB8fCBSZWdpc3RyeS5xdWVyeShuYW1lLCBSZWdpc3RyeS5TY29wZS5BVFRSSUJVVEUpKSB7XG4gICAgICAgICAgICB2YXIgYmxvdCA9IHRoaXMuaXNvbGF0ZShpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIGJsb3QuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9ybWF0QXQuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZUJsb3QucHJvdG90eXBlLm9wdGltaXplID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vcHRpbWl6ZS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB2YXIgZm9ybWF0cyA9IHRoaXMuZm9ybWF0cygpO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bndyYXAoKTsgLy8gdW5mb3JtYXR0ZWQgc3BhblxuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIElubGluZUJsb3QgJiYgbmV4dC5wcmV2ID09PSB0aGlzICYmIGlzRXF1YWwoZm9ybWF0cywgbmV4dC5mb3JtYXRzKCkpKSB7XG4gICAgICAgICAgICBuZXh0Lm1vdmVDaGlsZHJlbih0aGlzKTtcbiAgICAgICAgICAgIG5leHQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZUJsb3QuYmxvdE5hbWUgPSAnaW5saW5lJztcbiAgICBJbmxpbmVCbG90LnNjb3BlID0gUmVnaXN0cnkuU2NvcGUuSU5MSU5FX0JMT1Q7XG4gICAgSW5saW5lQmxvdC50YWdOYW1lID0gJ1NQQU4nO1xuICAgIHJldHVybiBJbmxpbmVCbG90O1xufShmb3JtYXRfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbmxpbmVCbG90O1xuXG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGZvcm1hdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIEJsb2NrQmxvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tCbG90LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrQmxvdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCbG9ja0Jsb3QuZm9ybWF0cyA9IGZ1bmN0aW9uIChkb21Ob2RlKSB7XG4gICAgICAgIHZhciB0YWdOYW1lID0gUmVnaXN0cnkucXVlcnkoQmxvY2tCbG90LmJsb3ROYW1lKS50YWdOYW1lO1xuICAgICAgICBpZiAoZG9tTm9kZS50YWdOYW1lID09PSB0YWdOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5mb3JtYXRzLmNhbGwodGhpcywgZG9tTm9kZSk7XG4gICAgfTtcbiAgICBCbG9ja0Jsb3QucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoUmVnaXN0cnkucXVlcnkobmFtZSwgUmVnaXN0cnkuU2NvcGUuQkxPQ0spID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoKEJsb2NrQmxvdC5ibG90TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdC5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmxvY2tCbG90LnByb3RvdHlwZS5mb3JtYXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoUmVnaXN0cnkucXVlcnkobmFtZSwgUmVnaXN0cnkuU2NvcGUuQkxPQ0spICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9ybWF0QXQuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJsb2NrQmxvdC5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgICAgaWYgKGRlZiA9PSBudWxsIHx8IFJlZ2lzdHJ5LnF1ZXJ5KHZhbHVlLCBSZWdpc3RyeS5TY29wZS5JTkxJTkUpICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEluc2VydCB0ZXh0IG9yIGlubGluZVxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnNlcnRBdC5jYWxsKHRoaXMsIGluZGV4LCB2YWx1ZSwgZGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhZnRlciA9IHRoaXMuc3BsaXQoaW5kZXgpO1xuICAgICAgICAgICAgdmFyIGJsb3QgPSBSZWdpc3RyeS5jcmVhdGUodmFsdWUsIGRlZik7XG4gICAgICAgICAgICBhZnRlci5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJsb3QsIGFmdGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmxvY2tCbG90LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9UcmlkZW50LykpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgbXV0YXRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmxvY2tCbG90LmJsb3ROYW1lID0gJ2Jsb2NrJztcbiAgICBCbG9ja0Jsb3Quc2NvcGUgPSBSZWdpc3RyeS5TY29wZS5CTE9DS19CTE9UO1xuICAgIEJsb2NrQmxvdC50YWdOYW1lID0gJ1AnO1xuICAgIHJldHVybiBCbG9ja0Jsb3Q7XG59KGZvcm1hdF8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJsb2NrQmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsZWFmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbnZhciBFbWJlZEJsb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtYmVkQmxvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbWJlZEJsb3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRW1iZWRCbG90LmZvcm1hdHMgPSBmdW5jdGlvbiAoZG9tTm9kZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgRW1iZWRCbG90LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgLy8gc3VwZXIuZm9ybWF0QXQgd3JhcHMsIHdoaWNoIGlzIHdoYXQgd2Ugd2FudCBpbiBnZW5lcmFsLFxuICAgICAgICAvLyBidXQgdGhpcyBhbGxvd3Mgc3ViY2xhc3NlcyB0byBvdmVyd3JpdGUgZm9yIGZvcm1hdHNcbiAgICAgICAgLy8gdGhhdCBqdXN0IGFwcGx5IHRvIHBhcnRpY3VsYXIgZW1iZWRzXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9ybWF0QXQuY2FsbCh0aGlzLCAwLCB0aGlzLmxlbmd0aCgpLCBuYW1lLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBFbWJlZEJsb3QucHJvdG90eXBlLmZvcm1hdEF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiBsZW5ndGggPT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9ybWF0QXQuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVtYmVkQmxvdC5wcm90b3R5cGUuZm9ybWF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGljcy5mb3JtYXRzKHRoaXMuZG9tTm9kZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRW1iZWRCbG90O1xufShsZWFmXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRW1iZWRCbG90O1xuXG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxlYWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBUZXh0QmxvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGV4dEJsb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dEJsb3Qobm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBub2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZXh0ID0gX3RoaXMuc3RhdGljcy52YWx1ZShfdGhpcy5kb21Ob2RlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUZXh0QmxvdC5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICB9O1xuICAgIFRleHRCbG90LnZhbHVlID0gZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgdmFyIHRleHQgPSBkb21Ob2RlLmRhdGE7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHRleHRbJ25vcm1hbGl6ZSddKVxuICAgICAgICAgICAgdGV4dCA9IHRleHRbJ25vcm1hbGl6ZSddKCk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgVGV4dEJsb3QucHJvdG90eXBlLmRlbGV0ZUF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kb21Ob2RlLmRhdGEgPSB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgaW5kZXgpICsgdGhpcy50ZXh0LnNsaWNlKGluZGV4ICsgbGVuZ3RoKTtcbiAgICB9O1xuICAgIFRleHRCbG90LnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uIChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tTm9kZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgICAgaWYgKGRlZiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgaW5kZXgpICsgdmFsdWUgKyB0aGlzLnRleHQuc2xpY2UoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5kb21Ob2RlLmRhdGEgPSB0aGlzLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluc2VydEF0LmNhbGwodGhpcywgaW5kZXgsIHZhbHVlLCBkZWYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9O1xuICAgIFRleHRCbG90LnByb3RvdHlwZS5vcHRpbWl6ZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub3B0aW1pemUuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5zdGF0aWNzLnZhbHVlKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIGlmICh0aGlzLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dCBpbnN0YW5jZW9mIFRleHRCbG90ICYmIHRoaXMubmV4dC5wcmV2ID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEF0KHRoaXMubGVuZ3RoKCksIHRoaXMubmV4dC52YWx1ZSgpKTtcbiAgICAgICAgICAgIHRoaXMubmV4dC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEJsb3QucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKGluZGV4LCBpbmNsdXNpdmUpIHtcbiAgICAgICAgaWYgKGluY2x1c2l2ZSA9PT0gdm9pZCAwKSB7IGluY2x1c2l2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBbdGhpcy5kb21Ob2RlLCBpbmRleF07XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoaW5kZXgsIGZvcmNlKSB7XG4gICAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7IGZvcmNlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKCFmb3JjZSkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmxlbmd0aCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFmdGVyID0gUmVnaXN0cnkuY3JlYXRlKHRoaXMuZG9tTm9kZS5zcGxpdFRleHQoaW5kZXgpKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGFmdGVyLCB0aGlzLm5leHQpO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnN0YXRpY3MudmFsdWUodGhpcy5kb21Ob2RlKTtcbiAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgIH07XG4gICAgVGV4dEJsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG11dGF0aW9ucy5zb21lKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXRhdGlvbi50YXJnZXQgPT09IF90aGlzLmRvbU5vZGU7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnN0YXRpY3MudmFsdWUodGhpcy5kb21Ob2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEJsb3QucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH07XG4gICAgVGV4dEJsb3QuYmxvdE5hbWUgPSAndGV4dCc7XG4gICAgVGV4dEJsb3Quc2NvcGUgPSBSZWdpc3RyeS5TY29wZS5JTkxJTkVfQkxPVDtcbiAgICByZXR1cm4gVGV4dEJsb3Q7XG59KGxlYWZfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUZXh0QmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5lbGVtLmNsYXNzTGlzdC50b2dnbGUoJ3Rlc3QtY2xhc3MnLCBmYWxzZSk7XG5pZiAoZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3QtY2xhc3MnKSkge1xuICB2YXIgX3RvZ2dsZSA9IERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlO1xuICBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICh0b2tlbiwgZm9yY2UpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgIXRoaXMuY29udGFpbnModG9rZW4pID09PSAhZm9yY2UpIHtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF90b2dnbGUuY2FsbCh0aGlzLCB0b2tlbik7XG4gICAgfVxuICB9O1xufVxuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCkge1xuICBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgIHBvc2l0aW9uID0gcG9zaXRpb24gfHwgMDtcbiAgICByZXR1cm4gdGhpcy5zdWJzdHIocG9zaXRpb24sIHNlYXJjaFN0cmluZy5sZW5ndGgpID09PSBzZWFyY2hTdHJpbmc7XG4gIH07XG59XG5cbmlmICghU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCkge1xuICBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcbiAgICB2YXIgc3ViamVjdFN0cmluZyA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJyB8fCAhaXNGaW5pdGUocG9zaXRpb24pIHx8IE1hdGguZmxvb3IocG9zaXRpb24pICE9PSBwb3NpdGlvbiB8fCBwb3NpdGlvbiA+IHN1YmplY3RTdHJpbmcubGVuZ3RoKSB7XG4gICAgICBwb3NpdGlvbiA9IHN1YmplY3RTdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICAgIHZhciBsYXN0SW5kZXggPSBzdWJqZWN0U3RyaW5nLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcbiAgfTtcbn1cblxuaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCBcImZpbmRcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5maW5kIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuICAgICAgdmFyIGxpc3QgPSBPYmplY3QodGhpcyk7XG4gICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGggPj4+IDA7XG4gICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaSwgbGlzdCkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcbn1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gKCkge1xuICAvLyBEaXNhYmxlIHJlc2l6aW5nIGluIEZpcmVmb3hcbiAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJlbmFibGVPYmplY3RSZXNpemluZ1wiLCBmYWxzZSwgZmFsc2UpO1xuICAvLyBEaXNhYmxlIGF1dG9tYXRpYyBsaW5raWZ5aW5nIGluIElFMTFcbiAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJhdXRvVXJsRGV0ZWN0XCIsIGZhbHNlLCBmYWxzZSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA1MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoaXMgbGlicmFyeSBtb2RpZmllcyB0aGUgZGlmZi1wYXRjaC1tYXRjaCBsaWJyYXJ5IGJ5IE5laWwgRnJhc2VyXG4gKiBieSByZW1vdmluZyB0aGUgcGF0Y2ggYW5kIG1hdGNoIGZ1bmN0aW9uYWxpdHkgYW5kIGNlcnRhaW4gYWR2YW5jZWRcbiAqIG9wdGlvbnMgaW4gdGhlIGRpZmYgZnVuY3Rpb24uIFRoZSBvcmlnaW5hbCBsaWNlbnNlIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogPT09XG4gKlxuICogRGlmZiBNYXRjaCBhbmQgUGF0Y2hcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNiBHb29nbGUgSW5jLlxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIFRoZSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYSBkaWZmIGlzIGFuIGFycmF5IG9mIHR1cGxlczpcbiAqIFtbRElGRl9ERUxFVEUsICdIZWxsbyddLCBbRElGRl9JTlNFUlQsICdHb29kYnllJ10sIFtESUZGX0VRVUFMLCAnIHdvcmxkLiddXVxuICogd2hpY2ggbWVhbnM6IGRlbGV0ZSAnSGVsbG8nLCBhZGQgJ0dvb2RieWUnIGFuZCBrZWVwICcgd29ybGQuJ1xuICovXG52YXIgRElGRl9ERUxFVEUgPSAtMTtcbnZhciBESUZGX0lOU0VSVCA9IDE7XG52YXIgRElGRl9FUVVBTCA9IDA7XG5cblxuLyoqXG4gKiBGaW5kIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byB0ZXh0cy4gIFNpbXBsaWZpZXMgdGhlIHByb2JsZW0gYnkgc3RyaXBwaW5nXG4gKiBhbnkgY29tbW9uIHByZWZpeCBvciBzdWZmaXggb2ZmIHRoZSB0ZXh0cyBiZWZvcmUgZGlmZmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7SW50fSBjdXJzb3JfcG9zIEV4cGVjdGVkIGVkaXQgcG9zaXRpb24gaW4gdGV4dDEgKG9wdGlvbmFsKVxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICovXG5mdW5jdGlvbiBkaWZmX21haW4odGV4dDEsIHRleHQyLCBjdXJzb3JfcG9zKSB7XG4gIC8vIENoZWNrIGZvciBlcXVhbGl0eSAoc3BlZWR1cCkuXG4gIGlmICh0ZXh0MSA9PSB0ZXh0Mikge1xuICAgIGlmICh0ZXh0MSkge1xuICAgICAgcmV0dXJuIFtbRElGRl9FUVVBTCwgdGV4dDFdXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gQ2hlY2sgY3Vyc29yX3BvcyB3aXRoaW4gYm91bmRzXG4gIGlmIChjdXJzb3JfcG9zIDwgMCB8fCB0ZXh0MS5sZW5ndGggPCBjdXJzb3JfcG9zKSB7XG4gICAgY3Vyc29yX3BvcyA9IG51bGw7XG4gIH1cblxuICAvLyBUcmltIG9mZiBjb21tb24gcHJlZml4IChzcGVlZHVwKS5cbiAgdmFyIGNvbW1vbmxlbmd0aCA9IGRpZmZfY29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mik7XG4gIHZhciBjb21tb25wcmVmaXggPSB0ZXh0MS5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcblxuICAvLyBUcmltIG9mZiBjb21tb24gc3VmZml4IChzcGVlZHVwKS5cbiAgY29tbW9ubGVuZ3RoID0gZGlmZl9jb21tb25TdWZmaXgodGV4dDEsIHRleHQyKTtcbiAgdmFyIGNvbW1vbnN1ZmZpeCA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZygwLCB0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0Mi5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuXG4gIC8vIENvbXB1dGUgdGhlIGRpZmYgb24gdGhlIG1pZGRsZSBibG9jay5cbiAgdmFyIGRpZmZzID0gZGlmZl9jb21wdXRlXyh0ZXh0MSwgdGV4dDIpO1xuXG4gIC8vIFJlc3RvcmUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICBpZiAoY29tbW9ucHJlZml4KSB7XG4gICAgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgY29tbW9ucHJlZml4XSk7XG4gIH1cbiAgaWYgKGNvbW1vbnN1ZmZpeCkge1xuICAgIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGNvbW1vbnN1ZmZpeF0pO1xuICB9XG4gIGRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgaWYgKGN1cnNvcl9wb3MgIT0gbnVsbCkge1xuICAgIGRpZmZzID0gZml4X2N1cnNvcihkaWZmcywgY3Vyc29yX3Bvcyk7XG4gIH1cbiAgZGlmZnMgPSBmaXhfZW1vamkoZGlmZnMpO1xuICByZXR1cm4gZGlmZnM7XG59O1xuXG5cbi8qKlxuICogRmluZCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGV4dHMuICBBc3N1bWVzIHRoYXQgdGhlIHRleHRzIGRvIG5vdFxuICogaGF2ZSBhbnkgY29tbW9uIHByZWZpeCBvciBzdWZmaXguXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmZ1bmN0aW9uIGRpZmZfY29tcHV0ZV8odGV4dDEsIHRleHQyKSB7XG4gIHZhciBkaWZmcztcblxuICBpZiAoIXRleHQxKSB7XG4gICAgLy8gSnVzdCBhZGQgc29tZSB0ZXh0IChzcGVlZHVwKS5cbiAgICByZXR1cm4gW1tESUZGX0lOU0VSVCwgdGV4dDJdXTtcbiAgfVxuXG4gIGlmICghdGV4dDIpIHtcbiAgICAvLyBKdXN0IGRlbGV0ZSBzb21lIHRleHQgKHNwZWVkdXApLlxuICAgIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV1dO1xuICB9XG5cbiAgdmFyIGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcbiAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIHZhciBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xuICBpZiAoaSAhPSAtMSkge1xuICAgIC8vIFNob3J0ZXIgdGV4dCBpcyBpbnNpZGUgdGhlIGxvbmdlciB0ZXh0IChzcGVlZHVwKS5cbiAgICBkaWZmcyA9IFtbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKV0sXG4gICAgICAgICAgICAgW0RJRkZfRVFVQUwsIHNob3J0dGV4dF0sXG4gICAgICAgICAgICAgW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHNob3J0dGV4dC5sZW5ndGgpXV07XG4gICAgLy8gU3dhcCBpbnNlcnRpb25zIGZvciBkZWxldGlvbnMgaWYgZGlmZiBpcyByZXZlcnNlZC5cbiAgICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKSB7XG4gICAgICBkaWZmc1swXVswXSA9IGRpZmZzWzJdWzBdID0gRElGRl9ERUxFVEU7XG4gICAgfVxuICAgIHJldHVybiBkaWZmcztcbiAgfVxuXG4gIGlmIChzaG9ydHRleHQubGVuZ3RoID09IDEpIHtcbiAgICAvLyBTaW5nbGUgY2hhcmFjdGVyIHN0cmluZy5cbiAgICAvLyBBZnRlciB0aGUgcHJldmlvdXMgc3BlZWR1cCwgdGhlIGNoYXJhY3RlciBjYW4ndCBiZSBhbiBlcXVhbGl0eS5cbiAgICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdLCBbRElGRl9JTlNFUlQsIHRleHQyXV07XG4gIH1cblxuICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIHByb2JsZW0gY2FuIGJlIHNwbGl0IGluIHR3by5cbiAgdmFyIGhtID0gZGlmZl9oYWxmTWF0Y2hfKHRleHQxLCB0ZXh0Mik7XG4gIGlmIChobSkge1xuICAgIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cbiAgICB2YXIgdGV4dDFfYSA9IGhtWzBdO1xuICAgIHZhciB0ZXh0MV9iID0gaG1bMV07XG4gICAgdmFyIHRleHQyX2EgPSBobVsyXTtcbiAgICB2YXIgdGV4dDJfYiA9IGhtWzNdO1xuICAgIHZhciBtaWRfY29tbW9uID0gaG1bNF07XG4gICAgLy8gU2VuZCBib3RoIHBhaXJzIG9mZiBmb3Igc2VwYXJhdGUgcHJvY2Vzc2luZy5cbiAgICB2YXIgZGlmZnNfYSA9IGRpZmZfbWFpbih0ZXh0MV9hLCB0ZXh0Ml9hKTtcbiAgICB2YXIgZGlmZnNfYiA9IGRpZmZfbWFpbih0ZXh0MV9iLCB0ZXh0Ml9iKTtcbiAgICAvLyBNZXJnZSB0aGUgcmVzdWx0cy5cbiAgICByZXR1cm4gZGlmZnNfYS5jb25jYXQoW1tESUZGX0VRVUFMLCBtaWRfY29tbW9uXV0sIGRpZmZzX2IpO1xuICB9XG5cbiAgcmV0dXJuIGRpZmZfYmlzZWN0Xyh0ZXh0MSwgdGV4dDIpO1xufTtcblxuXG4vKipcbiAqIEZpbmQgdGhlICdtaWRkbGUgc25ha2UnIG9mIGEgZGlmZiwgc3BsaXQgdGhlIHByb2JsZW0gaW4gdHdvXG4gKiBhbmQgcmV0dXJuIHRoZSByZWN1cnNpdmVseSBjb25zdHJ1Y3RlZCBkaWZmLlxuICogU2VlIE15ZXJzIDE5ODYgcGFwZXI6IEFuIE8oTkQpIERpZmZlcmVuY2UgQWxnb3JpdGhtIGFuZCBJdHMgVmFyaWF0aW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRpZmZfYmlzZWN0Xyh0ZXh0MSwgdGV4dDIpIHtcbiAgLy8gQ2FjaGUgdGhlIHRleHQgbGVuZ3RocyB0byBwcmV2ZW50IG11bHRpcGxlIGNhbGxzLlxuICB2YXIgdGV4dDFfbGVuZ3RoID0gdGV4dDEubGVuZ3RoO1xuICB2YXIgdGV4dDJfbGVuZ3RoID0gdGV4dDIubGVuZ3RoO1xuICB2YXIgbWF4X2QgPSBNYXRoLmNlaWwoKHRleHQxX2xlbmd0aCArIHRleHQyX2xlbmd0aCkgLyAyKTtcbiAgdmFyIHZfb2Zmc2V0ID0gbWF4X2Q7XG4gIHZhciB2X2xlbmd0aCA9IDIgKiBtYXhfZDtcbiAgdmFyIHYxID0gbmV3IEFycmF5KHZfbGVuZ3RoKTtcbiAgdmFyIHYyID0gbmV3IEFycmF5KHZfbGVuZ3RoKTtcbiAgLy8gU2V0dGluZyBhbGwgZWxlbWVudHMgdG8gLTEgaXMgZmFzdGVyIGluIENocm9tZSAmIEZpcmVmb3ggdGhhbiBtaXhpbmdcbiAgLy8gaW50ZWdlcnMgYW5kIHVuZGVmaW5lZC5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCB2X2xlbmd0aDsgeCsrKSB7XG4gICAgdjFbeF0gPSAtMTtcbiAgICB2Mlt4XSA9IC0xO1xuICB9XG4gIHYxW3Zfb2Zmc2V0ICsgMV0gPSAwO1xuICB2Mlt2X29mZnNldCArIDFdID0gMDtcbiAgdmFyIGRlbHRhID0gdGV4dDFfbGVuZ3RoIC0gdGV4dDJfbGVuZ3RoO1xuICAvLyBJZiB0aGUgdG90YWwgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaXMgb2RkLCB0aGVuIHRoZSBmcm9udCBwYXRoIHdpbGwgY29sbGlkZVxuICAvLyB3aXRoIHRoZSByZXZlcnNlIHBhdGguXG4gIHZhciBmcm9udCA9IChkZWx0YSAlIDIgIT0gMCk7XG4gIC8vIE9mZnNldHMgZm9yIHN0YXJ0IGFuZCBlbmQgb2YgayBsb29wLlxuICAvLyBQcmV2ZW50cyBtYXBwaW5nIG9mIHNwYWNlIGJleW9uZCB0aGUgZ3JpZC5cbiAgdmFyIGsxc3RhcnQgPSAwO1xuICB2YXIgazFlbmQgPSAwO1xuICB2YXIgazJzdGFydCA9IDA7XG4gIHZhciBrMmVuZCA9IDA7XG4gIGZvciAodmFyIGQgPSAwOyBkIDwgbWF4X2Q7IGQrKykge1xuICAgIC8vIFdhbGsgdGhlIGZyb250IHBhdGggb25lIHN0ZXAuXG4gICAgZm9yICh2YXIgazEgPSAtZCArIGsxc3RhcnQ7IGsxIDw9IGQgLSBrMWVuZDsgazEgKz0gMikge1xuICAgICAgdmFyIGsxX29mZnNldCA9IHZfb2Zmc2V0ICsgazE7XG4gICAgICB2YXIgeDE7XG4gICAgICBpZiAoazEgPT0gLWQgfHwgKGsxICE9IGQgJiYgdjFbazFfb2Zmc2V0IC0gMV0gPCB2MVtrMV9vZmZzZXQgKyAxXSkpIHtcbiAgICAgICAgeDEgPSB2MVtrMV9vZmZzZXQgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gdjFbazFfb2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgfVxuICAgICAgdmFyIHkxID0geDEgLSBrMTtcbiAgICAgIHdoaWxlICh4MSA8IHRleHQxX2xlbmd0aCAmJiB5MSA8IHRleHQyX2xlbmd0aCAmJlxuICAgICAgICAgICAgIHRleHQxLmNoYXJBdCh4MSkgPT0gdGV4dDIuY2hhckF0KHkxKSkge1xuICAgICAgICB4MSsrO1xuICAgICAgICB5MSsrO1xuICAgICAgfVxuICAgICAgdjFbazFfb2Zmc2V0XSA9IHgxO1xuICAgICAgaWYgKHgxID4gdGV4dDFfbGVuZ3RoKSB7XG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIHJpZ2h0IG9mIHRoZSBncmFwaC5cbiAgICAgICAgazFlbmQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoeTEgPiB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgYm90dG9tIG9mIHRoZSBncmFwaC5cbiAgICAgICAgazFzdGFydCArPSAyO1xuICAgICAgfSBlbHNlIGlmIChmcm9udCkge1xuICAgICAgICB2YXIgazJfb2Zmc2V0ID0gdl9vZmZzZXQgKyBkZWx0YSAtIGsxO1xuICAgICAgICBpZiAoazJfb2Zmc2V0ID49IDAgJiYgazJfb2Zmc2V0IDwgdl9sZW5ndGggJiYgdjJbazJfb2Zmc2V0XSAhPSAtMSkge1xuICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAgICAgIHZhciB4MiA9IHRleHQxX2xlbmd0aCAtIHYyW2syX29mZnNldF07XG4gICAgICAgICAgaWYgKHgxID49IHgyKSB7XG4gICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIGRpZmZfYmlzZWN0U3BsaXRfKHRleHQxLCB0ZXh0MiwgeDEsIHkxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXYWxrIHRoZSByZXZlcnNlIHBhdGggb25lIHN0ZXAuXG4gICAgZm9yICh2YXIgazIgPSAtZCArIGsyc3RhcnQ7IGsyIDw9IGQgLSBrMmVuZDsgazIgKz0gMikge1xuICAgICAgdmFyIGsyX29mZnNldCA9IHZfb2Zmc2V0ICsgazI7XG4gICAgICB2YXIgeDI7XG4gICAgICBpZiAoazIgPT0gLWQgfHwgKGsyICE9IGQgJiYgdjJbazJfb2Zmc2V0IC0gMV0gPCB2MltrMl9vZmZzZXQgKyAxXSkpIHtcbiAgICAgICAgeDIgPSB2MltrMl9vZmZzZXQgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdjJbazJfb2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgfVxuICAgICAgdmFyIHkyID0geDIgLSBrMjtcbiAgICAgIHdoaWxlICh4MiA8IHRleHQxX2xlbmd0aCAmJiB5MiA8IHRleHQyX2xlbmd0aCAmJlxuICAgICAgICAgICAgIHRleHQxLmNoYXJBdCh0ZXh0MV9sZW5ndGggLSB4MiAtIDEpID09XG4gICAgICAgICAgICAgdGV4dDIuY2hhckF0KHRleHQyX2xlbmd0aCAtIHkyIC0gMSkpIHtcbiAgICAgICAgeDIrKztcbiAgICAgICAgeTIrKztcbiAgICAgIH1cbiAgICAgIHYyW2syX29mZnNldF0gPSB4MjtcbiAgICAgIGlmICh4MiA+IHRleHQxX2xlbmd0aCkge1xuICAgICAgICAvLyBSYW4gb2ZmIHRoZSBsZWZ0IG9mIHRoZSBncmFwaC5cbiAgICAgICAgazJlbmQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPiB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgdG9wIG9mIHRoZSBncmFwaC5cbiAgICAgICAgazJzdGFydCArPSAyO1xuICAgICAgfSBlbHNlIGlmICghZnJvbnQpIHtcbiAgICAgICAgdmFyIGsxX29mZnNldCA9IHZfb2Zmc2V0ICsgZGVsdGEgLSBrMjtcbiAgICAgICAgaWYgKGsxX29mZnNldCA+PSAwICYmIGsxX29mZnNldCA8IHZfbGVuZ3RoICYmIHYxW2sxX29mZnNldF0gIT0gLTEpIHtcbiAgICAgICAgICB2YXIgeDEgPSB2MVtrMV9vZmZzZXRdO1xuICAgICAgICAgIHZhciB5MSA9IHZfb2Zmc2V0ICsgeDEgLSBrMV9vZmZzZXQ7XG4gICAgICAgICAgLy8gTWlycm9yIHgyIG9udG8gdG9wLWxlZnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICAgICAgeDIgPSB0ZXh0MV9sZW5ndGggLSB4MjtcbiAgICAgICAgICBpZiAoeDEgPj0geDIpIHtcbiAgICAgICAgICAgIC8vIE92ZXJsYXAgZGV0ZWN0ZWQuXG4gICAgICAgICAgICByZXR1cm4gZGlmZl9iaXNlY3RTcGxpdF8odGV4dDEsIHRleHQyLCB4MSwgeTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEaWZmIHRvb2sgdG9vIGxvbmcgYW5kIGhpdCB0aGUgZGVhZGxpbmUgb3JcbiAgLy8gbnVtYmVyIG9mIGRpZmZzIGVxdWFscyBudW1iZXIgb2YgY2hhcmFjdGVycywgbm8gY29tbW9uYWxpdHkgYXQgYWxsLlxuICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdLCBbRElGRl9JTlNFUlQsIHRleHQyXV07XG59O1xuXG5cbi8qKlxuICogR2l2ZW4gdGhlIGxvY2F0aW9uIG9mIHRoZSAnbWlkZGxlIHNuYWtlJywgc3BsaXQgdGhlIGRpZmYgaW4gdHdvIHBhcnRzXG4gKiBhbmQgcmVjdXJzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IEluZGV4IG9mIHNwbGl0IHBvaW50IGluIHRleHQxLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgSW5kZXggb2Ygc3BsaXQgcG9pbnQgaW4gdGV4dDIuXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmZ1bmN0aW9uIGRpZmZfYmlzZWN0U3BsaXRfKHRleHQxLCB0ZXh0MiwgeCwgeSkge1xuICB2YXIgdGV4dDFhID0gdGV4dDEuc3Vic3RyaW5nKDAsIHgpO1xuICB2YXIgdGV4dDJhID0gdGV4dDIuc3Vic3RyaW5nKDAsIHkpO1xuICB2YXIgdGV4dDFiID0gdGV4dDEuc3Vic3RyaW5nKHgpO1xuICB2YXIgdGV4dDJiID0gdGV4dDIuc3Vic3RyaW5nKHkpO1xuXG4gIC8vIENvbXB1dGUgYm90aCBkaWZmcyBzZXJpYWxseS5cbiAgdmFyIGRpZmZzID0gZGlmZl9tYWluKHRleHQxYSwgdGV4dDJhKTtcbiAgdmFyIGRpZmZzYiA9IGRpZmZfbWFpbih0ZXh0MWIsIHRleHQyYik7XG5cbiAgcmV0dXJuIGRpZmZzLmNvbmNhdChkaWZmc2IpO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSB0aGUgY29tbW9uIHByZWZpeCBvZiB0d28gc3RyaW5ncy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgc3RhcnQgb2YgZWFjaFxuICogICAgIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZGlmZl9jb21tb25QcmVmaXgodGV4dDEsIHRleHQyKSB7XG4gIC8vIFF1aWNrIGNoZWNrIGZvciBjb21tb24gbnVsbCBjYXNlcy5cbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDEuY2hhckF0KDApICE9IHRleHQyLmNoYXJBdCgwKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEJpbmFyeSBzZWFyY2guXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gIHZhciBwb2ludGVybWluID0gMDtcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgdmFyIHBvaW50ZXJzdGFydCA9IDA7XG4gIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xuICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSA9PVxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyc3RhcnQgPSBwb2ludGVybWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICB9XG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlcm1pZDtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBzdWZmaXggb2YgdHdvIHN0cmluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIGVuZCBvZiBlYWNoIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZGlmZl9jb21tb25TdWZmaXgodGV4dDEsIHRleHQyKSB7XG4gIC8vIFF1aWNrIGNoZWNrIGZvciBjb21tb24gbnVsbCBjYXNlcy5cbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHxcbiAgICAgIHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSAxKSAhPSB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0gMSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvLyBCaW5hcnkgc2VhcmNoLlxuICAvLyBQZXJmb3JtYW5jZSBhbmFseXNpczogaHR0cDovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xuICB2YXIgcG9pbnRlcm1pbiA9IDA7XG4gIHZhciBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xuICB2YXIgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XG4gIHZhciBwb2ludGVyZW5kID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyZW5kKSA9PVxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlcmVuZCkpIHtcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgcG9pbnRlcmVuZCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufTtcblxuXG4vKipcbiAqIERvIHRoZSB0d28gdGV4dHMgc2hhcmUgYSBzdWJzdHJpbmcgd2hpY2ggaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIHRoZVxuICogbG9uZ2VyIHRleHQ/XG4gKiBUaGlzIHNwZWVkdXAgY2FuIHByb2R1Y2Ugbm9uLW1pbmltYWwgZGlmZnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcbiAqICAgICB0ZXh0MSwgdGhlIHN1ZmZpeCBvZiB0ZXh0MSwgdGhlIHByZWZpeCBvZiB0ZXh0MiwgdGhlIHN1ZmZpeCBvZlxuICogICAgIHRleHQyIGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICovXG5mdW5jdGlvbiBkaWZmX2hhbGZNYXRjaF8odGV4dDEsIHRleHQyKSB7XG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICBpZiAobG9uZ3RleHQubGVuZ3RoIDwgNCB8fCBzaG9ydHRleHQubGVuZ3RoICogMiA8IGxvbmd0ZXh0Lmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsOyAgLy8gUG9pbnRsZXNzLlxuICB9XG5cbiAgLyoqXG4gICAqIERvZXMgYSBzdWJzdHJpbmcgb2Ygc2hvcnR0ZXh0IGV4aXN0IHdpdGhpbiBsb25ndGV4dCBzdWNoIHRoYXQgdGhlIHN1YnN0cmluZ1xuICAgKiBpcyBhdCBsZWFzdCBoYWxmIHRoZSBsZW5ndGggb2YgbG9uZ3RleHQ/XG4gICAqIENsb3N1cmUsIGJ1dCBkb2VzIG5vdCByZWZlcmVuY2UgYW55IGV4dGVybmFsIHZhcmlhYmxlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvbmd0ZXh0IExvbmdlciBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydHRleHQgU2hvcnRlciBzdHJpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIFN0YXJ0IGluZGV4IG9mIHF1YXJ0ZXIgbGVuZ3RoIHN1YnN0cmluZyB3aXRoaW4gbG9uZ3RleHQuXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBGaXZlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlIHByZWZpeCBvZlxuICAgKiAgICAgbG9uZ3RleHQsIHRoZSBzdWZmaXggb2YgbG9uZ3RleHQsIHRoZSBwcmVmaXggb2Ygc2hvcnR0ZXh0LCB0aGUgc3VmZml4XG4gICAqICAgICBvZiBzaG9ydHRleHQgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBkaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsIGkpIHtcbiAgICAvLyBTdGFydCB3aXRoIGEgMS80IGxlbmd0aCBzdWJzdHJpbmcgYXQgcG9zaXRpb24gaSBhcyBhIHNlZWQuXG4gICAgdmFyIHNlZWQgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSwgaSArIE1hdGguZmxvb3IobG9uZ3RleHQubGVuZ3RoIC8gNCkpO1xuICAgIHZhciBqID0gLTE7XG4gICAgdmFyIGJlc3RfY29tbW9uID0gJyc7XG4gICAgdmFyIGJlc3RfbG9uZ3RleHRfYSwgYmVzdF9sb25ndGV4dF9iLCBiZXN0X3Nob3J0dGV4dF9hLCBiZXN0X3Nob3J0dGV4dF9iO1xuICAgIHdoaWxlICgoaiA9IHNob3J0dGV4dC5pbmRleE9mKHNlZWQsIGogKyAxKSkgIT0gLTEpIHtcbiAgICAgIHZhciBwcmVmaXhMZW5ndGggPSBkaWZmX2NvbW1vblByZWZpeChsb25ndGV4dC5zdWJzdHJpbmcoaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZyhqKSk7XG4gICAgICB2YXIgc3VmZml4TGVuZ3RoID0gZGlmZl9jb21tb25TdWZmaXgobG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaikpO1xuICAgICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCA8IHN1ZmZpeExlbmd0aCArIHByZWZpeExlbmd0aCkge1xuICAgICAgICBiZXN0X2NvbW1vbiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiAtIHN1ZmZpeExlbmd0aCwgaikgK1xuICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZyhqLCBqICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9sb25ndGV4dF9hID0gbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkgLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X2xvbmd0ZXh0X2IgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EgPSBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGogLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X3Nob3J0dGV4dF9iID0gc2hvcnR0ZXh0LnN1YnN0cmluZyhqICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCAqIDIgPj0gbG9uZ3RleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW2Jlc3RfbG9uZ3RleHRfYSwgYmVzdF9sb25ndGV4dF9iLFxuICAgICAgICAgICAgICBiZXN0X3Nob3J0dGV4dF9hLCBiZXN0X3Nob3J0dGV4dF9iLCBiZXN0X2NvbW1vbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBzZWNvbmQgcXVhcnRlciBpcyB0aGUgc2VlZCBmb3IgYSBoYWxmLW1hdGNoLlxuICB2YXIgaG0xID0gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNlaWwobG9uZ3RleHQubGVuZ3RoIC8gNCkpO1xuICAvLyBDaGVjayBhZ2FpbiBiYXNlZCBvbiB0aGUgdGhpcmQgcXVhcnRlci5cbiAgdmFyIGhtMiA9IGRpZmZfaGFsZk1hdGNoSV8obG9uZ3RleHQsIHNob3J0dGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDIpKTtcbiAgdmFyIGhtO1xuICBpZiAoIWhtMSAmJiAhaG0yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIWhtMikge1xuICAgIGhtID0gaG0xO1xuICB9IGVsc2UgaWYgKCFobTEpIHtcbiAgICBobSA9IGhtMjtcbiAgfSBlbHNlIHtcbiAgICAvLyBCb3RoIG1hdGNoZWQuICBTZWxlY3QgdGhlIGxvbmdlc3QuXG4gICAgaG0gPSBobTFbNF0ubGVuZ3RoID4gaG0yWzRdLmxlbmd0aCA/IGhtMSA6IGhtMjtcbiAgfVxuXG4gIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cbiAgdmFyIHRleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2I7XG4gIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcbiAgICB0ZXh0MV9hID0gaG1bMF07XG4gICAgdGV4dDFfYiA9IGhtWzFdO1xuICAgIHRleHQyX2EgPSBobVsyXTtcbiAgICB0ZXh0Ml9iID0gaG1bM107XG4gIH0gZWxzZSB7XG4gICAgdGV4dDJfYSA9IGhtWzBdO1xuICAgIHRleHQyX2IgPSBobVsxXTtcbiAgICB0ZXh0MV9hID0gaG1bMl07XG4gICAgdGV4dDFfYiA9IGhtWzNdO1xuICB9XG4gIHZhciBtaWRfY29tbW9uID0gaG1bNF07XG4gIHJldHVybiBbdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYiwgbWlkX2NvbW1vbl07XG59O1xuXG5cbi8qKlxuICogUmVvcmRlciBhbmQgbWVyZ2UgbGlrZSBlZGl0IHNlY3Rpb25zLiAgTWVyZ2UgZXF1YWxpdGllcy5cbiAqIEFueSBlZGl0IHNlY3Rpb24gY2FuIG1vdmUgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IGNyb3NzIGFuIGVxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheX0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmZ1bmN0aW9uIGRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKSB7XG4gIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsICcnXSk7ICAvLyBBZGQgYSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICB2YXIgcG9pbnRlciA9IDA7XG4gIHZhciBjb3VudF9kZWxldGUgPSAwO1xuICB2YXIgY291bnRfaW5zZXJ0ID0gMDtcbiAgdmFyIHRleHRfZGVsZXRlID0gJyc7XG4gIHZhciB0ZXh0X2luc2VydCA9ICcnO1xuICB2YXIgY29tbW9ubGVuZ3RoO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGNvdW50X2luc2VydCsrO1xuICAgICAgICB0ZXh0X2luc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50X2RlbGV0ZSsrO1xuICAgICAgICB0ZXh0X2RlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgLy8gVXBvbiByZWFjaGluZyBhbiBlcXVhbGl0eSwgY2hlY2sgZm9yIHByaW9yIHJlZHVuZGFuY2llcy5cbiAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCA+IDEpIHtcbiAgICAgICAgICBpZiAoY291bnRfZGVsZXRlICE9PSAwICYmIGNvdW50X2luc2VydCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gRmFjdG9yIG91dCBhbnkgY29tbW9uIHByZWZpeGllcy5cbiAgICAgICAgICAgIGNvbW1vbmxlbmd0aCA9IGRpZmZfY29tbW9uUHJlZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGlmICgocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCkgPiAwICYmXG4gICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMF0gPT1cbiAgICAgICAgICAgICAgICAgIERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMV0gKz1cbiAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKDAsIDAsIFtESUZGX0VRVUFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCldKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBzdWZmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSBkaWZmX2NvbW1vblN1ZmZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xuICAgICAgICAgICAgaWYgKGNvbW1vbmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZyh0ZXh0X2luc2VydC5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKSArIGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgICAgICB0ZXh0X2luc2VydCA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCB0ZXh0X2luc2VydC5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoMCwgdGV4dF9kZWxldGUubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIERlbGV0ZSB0aGUgb2ZmZW5kaW5nIHJlY29yZHMgYW5kIGFkZCB0aGUgbWVyZ2VkIG9uZXMuXG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSA9PT0gMCkge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9pbnNlcnQsXG4gICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9JTlNFUlQsIHRleHRfaW5zZXJ0XSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb3VudF9pbnNlcnQgPT09IDApIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlLFxuICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfREVMRVRFLCB0ZXh0X2RlbGV0ZV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0RFTEVURSwgdGV4dF9kZWxldGVdLFxuICAgICAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgdGV4dF9pbnNlcnRdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgK1xuICAgICAgICAgICAgICAgICAgICAoY291bnRfZGVsZXRlID8gMSA6IDApICsgKGNvdW50X2luc2VydCA/IDEgOiAwKSArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRlciAhPT0gMCAmJiBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgIC8vIE1lcmdlIHRoaXMgZXF1YWxpdHkgd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50X2luc2VydCA9IDA7XG4gICAgICAgIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgICAgIHRleHRfZGVsZXRlID0gJyc7XG4gICAgICAgIHRleHRfaW5zZXJ0ID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gPT09ICcnKSB7XG4gICAgZGlmZnMucG9wKCk7ICAvLyBSZW1vdmUgdGhlIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gIH1cblxuICAvLyBTZWNvbmQgcGFzczogbG9vayBmb3Igc2luZ2xlIGVkaXRzIHN1cnJvdW5kZWQgb24gYm90aCBzaWRlcyBieSBlcXVhbGl0aWVzXG4gIC8vIHdoaWNoIGNhbiBiZSBzaGlmdGVkIHNpZGV3YXlzIHRvIGVsaW1pbmF0ZSBhbiBlcXVhbGl0eS5cbiAgLy8gZS5nOiBBPGlucz5CQTwvaW5zPkMgLT4gPGlucz5BQjwvaW5zPkFDXG4gIHZhciBjaGFuZ2VzID0gZmFsc2U7XG4gIHBvaW50ZXIgPSAxO1xuICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZSB0aGUgZmlyc3QgYW5kIGxhc3QgZWxlbWVudCAoZG9uJ3QgbmVlZCBjaGVja2luZykuXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCAmJlxuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT0gRElGRl9FUVVBTCkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBlZGl0IHN1cnJvdW5kZWQgYnkgZXF1YWxpdGllcy5cbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC1cbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSA9PSBkaWZmc1twb2ludGVyIC0gMV1bMV0pIHtcbiAgICAgICAgLy8gU2hpZnQgdGhlIGVkaXQgb3ZlciB0aGUgcHJldmlvdXMgZXF1YWxpdHkuXG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICtcbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpO1xuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgPT1cbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0pIHtcbiAgICAgICAgLy8gU2hpZnQgdGhlIGVkaXQgb3ZlciB0aGUgbmV4dCBlcXVhbGl0eS5cbiAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPVxuICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpICtcbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICAvLyBJZiBzaGlmdHMgd2VyZSBtYWRlLCB0aGUgZGlmZiBuZWVkcyByZW9yZGVyaW5nIGFuZCBhbm90aGVyIHNoaWZ0IHN3ZWVwLlxuICBpZiAoY2hhbmdlcykge1xuICAgIGRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgfVxufTtcblxuXG52YXIgZGlmZiA9IGRpZmZfbWFpbjtcbmRpZmYuSU5TRVJUID0gRElGRl9JTlNFUlQ7XG5kaWZmLkRFTEVURSA9IERJRkZfREVMRVRFO1xuZGlmZi5FUVVBTCA9IERJRkZfRVFVQUw7XG5cbm1vZHVsZS5leHBvcnRzID0gZGlmZjtcblxuLypcbiAqIE1vZGlmeSBhIGRpZmYgc3VjaCB0aGF0IHRoZSBjdXJzb3IgcG9zaXRpb24gcG9pbnRzIHRvIHRoZSBzdGFydCBvZiBhIGNoYW5nZTpcbiAqIEUuZy5cbiAqICAgY3Vyc29yX25vcm1hbGl6ZV9kaWZmKFtbRElGRl9FUVVBTCwgJ2FiYyddXSwgMSlcbiAqICAgICA9PiBbMSwgW1tESUZGX0VRVUFMLCAnYSddLCBbRElGRl9FUVVBTCwgJ2JjJ11dXVxuICogICBjdXJzb3Jfbm9ybWFsaXplX2RpZmYoW1tESUZGX0lOU0VSVCwgJ25ldyddLCBbRElGRl9ERUxFVEUsICd4eXonXV0sIDIpXG4gKiAgICAgPT4gWzIsIFtbRElGRl9JTlNFUlQsICduZXcnXSwgW0RJRkZfREVMRVRFLCAneHknXSwgW0RJRkZfREVMRVRFLCAneiddXV1cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICogQHBhcmFtIHtJbnR9IGN1cnNvcl9wb3MgU3VnZ2VzdGVkIGVkaXQgcG9zaXRpb24uIE11c3Qgbm90IGJlIG91dCBvZiBib3VuZHMhXG4gKiBAcmV0dXJuIHtBcnJheX0gQSB0dXBsZSBbY3Vyc29yIGxvY2F0aW9uIGluIHRoZSBtb2RpZmllZCBkaWZmLCBtb2RpZmllZCBkaWZmXVxuICovXG5mdW5jdGlvbiBjdXJzb3Jfbm9ybWFsaXplX2RpZmYgKGRpZmZzLCBjdXJzb3JfcG9zKSB7XG4gIGlmIChjdXJzb3JfcG9zID09PSAwKSB7XG4gICAgcmV0dXJuIFtESUZGX0VRVUFMLCBkaWZmc107XG4gIH1cbiAgZm9yICh2YXIgY3VycmVudF9wb3MgPSAwLCBpID0gMDsgaSA8IGRpZmZzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGQgPSBkaWZmc1tpXTtcbiAgICBpZiAoZFswXSA9PT0gRElGRl9ERUxFVEUgfHwgZFswXSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgdmFyIG5leHRfcG9zID0gY3VycmVudF9wb3MgKyBkWzFdLmxlbmd0aDtcbiAgICAgIGlmIChjdXJzb3JfcG9zID09PSBuZXh0X3Bvcykge1xuICAgICAgICByZXR1cm4gW2kgKyAxLCBkaWZmc107XG4gICAgICB9IGVsc2UgaWYgKGN1cnNvcl9wb3MgPCBuZXh0X3Bvcykge1xuICAgICAgICAvLyBjb3B5IHRvIHByZXZlbnQgc2lkZSBlZmZlY3RzXG4gICAgICAgIGRpZmZzID0gZGlmZnMuc2xpY2UoKTtcbiAgICAgICAgLy8gc3BsaXQgZCBpbnRvIHR3byBkaWZmIGNoYW5nZXNcbiAgICAgICAgdmFyIHNwbGl0X3BvcyA9IGN1cnNvcl9wb3MgLSBjdXJyZW50X3BvcztcbiAgICAgICAgdmFyIGRfbGVmdCA9IFtkWzBdLCBkWzFdLnNsaWNlKDAsIHNwbGl0X3BvcyldO1xuICAgICAgICB2YXIgZF9yaWdodCA9IFtkWzBdLCBkWzFdLnNsaWNlKHNwbGl0X3BvcyldO1xuICAgICAgICBkaWZmcy5zcGxpY2UoaSwgMSwgZF9sZWZ0LCBkX3JpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFtpICsgMSwgZGlmZnNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudF9wb3MgPSBuZXh0X3BvcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdjdXJzb3JfcG9zIGlzIG91dCBvZiBib3VuZHMhJylcbn1cblxuLypcbiAqIE1vZGlmeSBhIGRpZmYgc3VjaCB0aGF0IHRoZSBlZGl0IHBvc2l0aW9uIGlzIFwic2hpZnRlZFwiIHRvIHRoZSBwcm9wb3NlZCBlZGl0IGxvY2F0aW9uIChjdXJzb3JfcG9zaXRpb24pLlxuICpcbiAqIENhc2UgMSlcbiAqICAgQ2hlY2sgaWYgYSBuYWl2ZSBzaGlmdCBpcyBwb3NzaWJsZTpcbiAqICAgICBbMCwgWF0sIFsgMSwgWV0gLT4gWyAxLCBZXSwgWzAsIFhdICAgIChpZiBYICsgWSA9PT0gWSArIFgpXG4gKiAgICAgWzAsIFhdLCBbLTEsIFldIC0+IFstMSwgWV0sIFswLCBYXSAgICAoaWYgWCArIFkgPT09IFkgKyBYKSAtIGhvbGRzIHNhbWUgcmVzdWx0XG4gKiBDYXNlIDIpXG4gKiAgIENoZWNrIGlmIHRoZSBmb2xsb3dpbmcgc2hpZnRzIGFyZSBwb3NzaWJsZTpcbiAqICAgICBbMCwgJ3ByZSddLCBbIDEsICdwcmVmaXgnXSAtPiBbIDEsICdwcmUnXSwgWzAsICdwcmUnXSwgWyAxLCAnZml4J11cbiAqICAgICBbMCwgJ3ByZSddLCBbLTEsICdwcmVmaXgnXSAtPiBbLTEsICdwcmUnXSwgWzAsICdwcmUnXSwgWy0xLCAnZml4J11cbiAqICAgICAgICAgXiAgICAgICAgICAgIF5cbiAqICAgICAgICAgZCAgICAgICAgICBkX25leHRcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICogQHBhcmFtIHtJbnR9IGN1cnNvcl9wb3MgU3VnZ2VzdGVkIGVkaXQgcG9zaXRpb24uIE11c3Qgbm90IGJlIG91dCBvZiBib3VuZHMhXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqL1xuZnVuY3Rpb24gZml4X2N1cnNvciAoZGlmZnMsIGN1cnNvcl9wb3MpIHtcbiAgdmFyIG5vcm0gPSBjdXJzb3Jfbm9ybWFsaXplX2RpZmYoZGlmZnMsIGN1cnNvcl9wb3MpO1xuICB2YXIgbmRpZmZzID0gbm9ybVsxXTtcbiAgdmFyIGN1cnNvcl9wb2ludGVyID0gbm9ybVswXTtcbiAgdmFyIGQgPSBuZGlmZnNbY3Vyc29yX3BvaW50ZXJdO1xuICB2YXIgZF9uZXh0ID0gbmRpZmZzW2N1cnNvcl9wb2ludGVyICsgMV07XG5cbiAgaWYgKGQgPT0gbnVsbCkge1xuICAgIC8vIFRleHQgd2FzIGRlbGV0ZWQgZnJvbSBlbmQgb2Ygb3JpZ2luYWwgc3RyaW5nLFxuICAgIC8vIGN1cnNvciBpcyBub3cgb3V0IG9mIGJvdW5kcyBpbiBuZXcgc3RyaW5nXG4gICAgcmV0dXJuIGRpZmZzO1xuICB9IGVsc2UgaWYgKGRbMF0gIT09IERJRkZfRVFVQUwpIHtcbiAgICAvLyBBIG1vZGlmaWNhdGlvbiBoYXBwZW5lZCBhdCB0aGUgY3Vyc29yIGxvY2F0aW9uLlxuICAgIC8vIFRoaXMgaXMgdGhlIGV4cGVjdGVkIG91dGNvbWUsIHNvIHdlIGNhbiByZXR1cm4gdGhlIG9yaWdpbmFsIGRpZmYuXG4gICAgcmV0dXJuIGRpZmZzO1xuICB9IGVsc2Uge1xuICAgIGlmIChkX25leHQgIT0gbnVsbCAmJiBkWzFdICsgZF9uZXh0WzFdID09PSBkX25leHRbMV0gKyBkWzFdKSB7XG4gICAgICAvLyBDYXNlIDEpXG4gICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0byBwZXJmb3JtIGEgbmFpdmUgc2hpZnRcbiAgICAgIG5kaWZmcy5zcGxpY2UoY3Vyc29yX3BvaW50ZXIsIDIsIGRfbmV4dCwgZClcbiAgICAgIHJldHVybiBtZXJnZV90dXBsZXMobmRpZmZzLCBjdXJzb3JfcG9pbnRlciwgMilcbiAgICB9IGVsc2UgaWYgKGRfbmV4dCAhPSBudWxsICYmIGRfbmV4dFsxXS5pbmRleE9mKGRbMV0pID09PSAwKSB7XG4gICAgICAvLyBDYXNlIDIpXG4gICAgICAvLyBkWzFdIGlzIGEgcHJlZml4IG9mIGRfbmV4dFsxXVxuICAgICAgLy8gV2UgY2FuIGFzc3VtZSB0aGF0IGRfbmV4dFswXSAhPT0gMCwgc2luY2UgZFswXSA9PT0gMFxuICAgICAgLy8gU2hpZnQgZWRpdCBsb2NhdGlvbnMuLlxuICAgICAgbmRpZmZzLnNwbGljZShjdXJzb3JfcG9pbnRlciwgMiwgW2RfbmV4dFswXSwgZFsxXV0sIFswLCBkWzFdXSk7XG4gICAgICB2YXIgc3VmZml4ID0gZF9uZXh0WzFdLnNsaWNlKGRbMV0ubGVuZ3RoKTtcbiAgICAgIGlmIChzdWZmaXgubGVuZ3RoID4gMCkge1xuICAgICAgICBuZGlmZnMuc3BsaWNlKGN1cnNvcl9wb2ludGVyICsgMiwgMCwgW2RfbmV4dFswXSwgc3VmZml4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VfdHVwbGVzKG5kaWZmcywgY3Vyc29yX3BvaW50ZXIsIDMpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vdCBwb3NzaWJsZSB0byBwZXJmb3JtIGFueSBtb2RpZmljYXRpb25cbiAgICAgIHJldHVybiBkaWZmcztcbiAgICB9XG4gIH1cbn1cblxuLypcbiAqIENoZWNrIGRpZmYgZGlkIG5vdCBzcGxpdCBzdXJyb2dhdGUgcGFpcnMuXG4gKiBFeC4gWzAsICdcXHVEODNEJ10sIFstMSwgJ1xcdURDMzYnXSwgWzEsICdcXHVEQzJGJ10gLT4gWy0xLCAnXFx1RDgzRFxcdURDMzYnXSwgWzEsICdcXHVEODNEXFx1REMyRiddXG4gKiAgICAgJ1xcdUQ4M0RcXHVEQzM2JyA9PT0gJ/CfkLYnLCAnXFx1RDgzRFxcdURDMkYnID09PSAn8J+QrydcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKi9cbmZ1bmN0aW9uIGZpeF9lbW9qaSAoZGlmZnMpIHtcbiAgdmFyIGNvbXBhY3QgPSBmYWxzZTtcbiAgdmFyIHN0YXJ0c193aXRoX3BhaXJfZW5kID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KDApID49IDB4REMwMCAmJiBzdHIuY2hhckNvZGVBdCgwKSA8PSAweERGRkY7XG4gIH1cbiAgdmFyIGVuZHNfd2l0aF9wYWlyX3N0YXJ0ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGgtMSkgPj0gMHhEODAwICYmIHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGgtMSkgPD0gMHhEQkZGO1xuICB9XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgZGlmZnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoZGlmZnNbaS0yXVswXSA9PT0gRElGRl9FUVVBTCAmJiBlbmRzX3dpdGhfcGFpcl9zdGFydChkaWZmc1tpLTJdWzFdKSAmJlxuICAgICAgICBkaWZmc1tpLTFdWzBdID09PSBESUZGX0RFTEVURSAmJiBzdGFydHNfd2l0aF9wYWlyX2VuZChkaWZmc1tpLTFdWzFdKSAmJlxuICAgICAgICBkaWZmc1tpXVswXSA9PT0gRElGRl9JTlNFUlQgJiYgc3RhcnRzX3dpdGhfcGFpcl9lbmQoZGlmZnNbaV1bMV0pKSB7XG4gICAgICBjb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgZGlmZnNbaS0xXVsxXSA9IGRpZmZzW2ktMl1bMV0uc2xpY2UoLTEpICsgZGlmZnNbaS0xXVsxXTtcbiAgICAgIGRpZmZzW2ldWzFdID0gZGlmZnNbaS0yXVsxXS5zbGljZSgtMSkgKyBkaWZmc1tpXVsxXTtcblxuICAgICAgZGlmZnNbaS0yXVsxXSA9IGRpZmZzW2ktMl1bMV0uc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgfVxuICBpZiAoIWNvbXBhY3QpIHtcbiAgICByZXR1cm4gZGlmZnM7XG4gIH1cbiAgdmFyIGZpeGVkX2RpZmZzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoZGlmZnNbaV1bMV0ubGVuZ3RoID4gMCkge1xuICAgICAgZml4ZWRfZGlmZnMucHVzaChkaWZmc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaXhlZF9kaWZmcztcbn1cblxuLypcbiAqIFRyeSB0byBtZXJnZSB0dXBsZXMgd2l0aCB0aGVpciBuZWlnYm9ycyBpbiBhIGdpdmVuIHJhbmdlLlxuICogRS5nLiBbMCwgJ2EnXSwgWzAsICdiJ10gLT4gWzAsICdhYiddXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcGFyYW0ge0ludH0gc3RhcnQgUG9zaXRpb24gb2YgdGhlIGZpcnN0IGVsZW1lbnQgdG8gbWVyZ2UgKGRpZmZzW3N0YXJ0XSBpcyBhbHNvIG1lcmdlZCB3aXRoIGRpZmZzW3N0YXJ0IC0gMV0pLlxuICogQHBhcmFtIHtJbnR9IGxlbmd0aCBOdW1iZXIgb2YgY29uc2VjdXRpdmUgZWxlbWVudHMgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgbWVyZ2VkIGRpZmYgdHVwbGVzLlxuICovXG5mdW5jdGlvbiBtZXJnZV90dXBsZXMgKGRpZmZzLCBzdGFydCwgbGVuZ3RoKSB7XG4gIC8vIENoZWNrIGZyb20gKHN0YXJ0LTEpIHRvIChzdGFydCtsZW5ndGgpLlxuICBmb3IgKHZhciBpID0gc3RhcnQgKyBsZW5ndGggLSAxOyBpID49IDAgJiYgaSA+PSBzdGFydCAtIDE7IGktLSkge1xuICAgIGlmIChpICsgMSA8IGRpZmZzLmxlbmd0aCkge1xuICAgICAgdmFyIGxlZnRfZCA9IGRpZmZzW2ldO1xuICAgICAgdmFyIHJpZ2h0X2QgPSBkaWZmc1tpKzFdO1xuICAgICAgaWYgKGxlZnRfZFswXSA9PT0gcmlnaHRfZFsxXSkge1xuICAgICAgICBkaWZmcy5zcGxpY2UoaSwgMiwgW2xlZnRfZFswXSwgbGVmdF9kWzFdICsgcmlnaHRfZFsxXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZnM7XG59XG5cblxuLyoqKi8gfSksXG4vKiA1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPSAoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHMpXG59KSgpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID8gc3VwcG9ydGVkIDogdW5zdXBwb3J0ZWQ7XG5cbmV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuZnVuY3Rpb24gc3VwcG9ydGVkKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG5leHBvcnRzLnVuc3VwcG9ydGVkID0gdW5zdXBwb3J0ZWQ7XG5mdW5jdGlvbiB1bnN1cHBvcnRlZChvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBvYmplY3QubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpICYmXG4gICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsICdjYWxsZWUnKSB8fFxuICAgIGZhbHNlO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtCb29sZWFufSBleGlzdHMgT25seSBjaGVjayBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0FycmF5fEJvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCwgZXhpc3RzKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBhdmFpbGFibGUgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoZXhpc3RzKSByZXR1cm4gISFhdmFpbGFibGU7XG4gIGlmICghYXZhaWxhYmxlKSByZXR1cm4gW107XG4gIGlmIChhdmFpbGFibGUuZm4pIHJldHVybiBbYXZhaWxhYmxlLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGF2YWlsYWJsZS5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBhdmFpbGFibGVbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHRoaXMuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIHRoaXMuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XS5mbikgdGhpcy5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgdGhpcy5fZXZlbnRzW2V2dF0gPSBbdGhpcy5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCB0aGlzLCB0cnVlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCB0aGlzLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghdGhpcy5fZXZlbnRzW2V2dF0uZm4pIHRoaXMuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIHRoaXMuX2V2ZW50c1tldnRdID0gW3RoaXMuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fZXZlbnRzW2V2dF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm5cbiAgICAgICYmICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSlcbiAgICAgICYmICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgICBlbHNlIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmblxuICAgICAgICB8fCAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpXG4gICAgICAgIHx8IChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSB7XG4gICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgICAgZWxzZSBkZWxldGUgdGhpcy5fZXZlbnRzW2V2dF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBkb2Vzbid0IGFwcGx5IGFueW1vcmUuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1hdGNoVGV4dCA9IGV4cG9ydHMubWF0Y2hTcGFjaW5nID0gZXhwb3J0cy5tYXRjaE5ld2xpbmUgPSBleHBvcnRzLm1hdGNoQmxvdCA9IGV4cG9ydHMubWF0Y2hBdHRyaWJ1dG9yID0gZXhwb3J0cy5kZWZhdWx0ID0gdW5kZWZpbmVkO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9leHRlbmQyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9leHRlbmQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kMik7XG5cbnZhciBfcXVpbGxEZWx0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfcXVpbGxEZWx0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbERlbHRhKTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX3F1aWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9xdWlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbCk7XG5cbnZhciBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ2dlcik7XG5cbnZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxudmFyIF9hbGlnbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXG52YXIgX2JhY2tncm91bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxudmFyIF9jb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBfY29kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2RlKTtcblxudmFyIF9jb2xvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG52YXIgX2RpcmVjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXG52YXIgX2ZvbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblxudmFyIF9zaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRlYnVnID0gKDAsIF9sb2dnZXIyLmRlZmF1bHQpKCdxdWlsbDpjbGlwYm9hcmQnKTtcblxudmFyIERPTV9LRVkgPSAnX19xbC1tYXRjaGVyJztcblxudmFyIENMSVBCT0FSRF9DT05GSUcgPSBbW05vZGUuVEVYVF9OT0RFLCBtYXRjaFRleHRdLCBbTm9kZS5URVhUX05PREUsIG1hdGNoTmV3bGluZV0sIFsnYnInLCBtYXRjaEJyZWFrXSwgW05vZGUuRUxFTUVOVF9OT0RFLCBtYXRjaE5ld2xpbmVdLCBbTm9kZS5FTEVNRU5UX05PREUsIG1hdGNoQmxvdF0sIFtOb2RlLkVMRU1FTlRfTk9ERSwgbWF0Y2hTcGFjaW5nXSwgW05vZGUuRUxFTUVOVF9OT0RFLCBtYXRjaEF0dHJpYnV0b3JdLCBbTm9kZS5FTEVNRU5UX05PREUsIG1hdGNoU3R5bGVzXSwgWydsaScsIG1hdGNoSW5kZW50XSwgWydiJywgbWF0Y2hBbGlhcy5iaW5kKG1hdGNoQWxpYXMsICdib2xkJyldLCBbJ2knLCBtYXRjaEFsaWFzLmJpbmQobWF0Y2hBbGlhcywgJ2l0YWxpYycpXSwgWydzdHlsZScsIG1hdGNoSWdub3JlXV07XG5cbnZhciBBVFRSSUJVVEVfQVRUUklCVVRPUlMgPSBbX2FsaWduLkFsaWduQXR0cmlidXRlLCBfZGlyZWN0aW9uLkRpcmVjdGlvbkF0dHJpYnV0ZV0ucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBhdHRyKSB7XG4gIG1lbW9bYXR0ci5rZXlOYW1lXSA9IGF0dHI7XG4gIHJldHVybiBtZW1vO1xufSwge30pO1xuXG52YXIgU1RZTEVfQVRUUklCVVRPUlMgPSBbX2FsaWduLkFsaWduU3R5bGUsIF9iYWNrZ3JvdW5kLkJhY2tncm91bmRTdHlsZSwgX2NvbG9yLkNvbG9yU3R5bGUsIF9kaXJlY3Rpb24uRGlyZWN0aW9uU3R5bGUsIF9mb250LkZvbnRTdHlsZSwgX3NpemUuU2l6ZVN0eWxlXS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGF0dHIpIHtcbiAgbWVtb1thdHRyLmtleU5hbWVdID0gYXR0cjtcbiAgcmV0dXJuIG1lbW87XG59LCB7fSk7XG5cbnZhciBDbGlwYm9hcmQgPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuICBfaW5oZXJpdHMoQ2xpcGJvYXJkLCBfTW9kdWxlKTtcblxuICBmdW5jdGlvbiBDbGlwYm9hcmQocXVpbGwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpcGJvYXJkKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDbGlwYm9hcmQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDbGlwYm9hcmQpKS5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5xdWlsbC5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgX3RoaXMub25QYXN0ZS5iaW5kKF90aGlzKSk7XG4gICAgX3RoaXMuY29udGFpbmVyID0gX3RoaXMucXVpbGwuYWRkQ29udGFpbmVyKCdxbC1jbGlwYm9hcmQnKTtcbiAgICBfdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCB0cnVlKTtcbiAgICBfdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcbiAgICBfdGhpcy5tYXRjaGVycyA9IFtdO1xuICAgIENMSVBCT0FSRF9DT05GSUcuY29uY2F0KF90aGlzLm9wdGlvbnMubWF0Y2hlcnMpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgIHNlbGVjdG9yID0gX3JlZjJbMF0sXG4gICAgICAgICAgbWF0Y2hlciA9IF9yZWYyWzFdO1xuXG4gICAgICBpZiAoIW9wdGlvbnMubWF0Y2hWaXN1YWwgJiYgbWF0Y2hlciA9PT0gbWF0Y2hTcGFjaW5nKSByZXR1cm47XG4gICAgICBfdGhpcy5hZGRNYXRjaGVyKHNlbGVjdG9yLCBtYXRjaGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2xpcGJvYXJkLCBbe1xuICAgIGtleTogJ2FkZE1hdGNoZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNYXRjaGVyKHNlbGVjdG9yLCBtYXRjaGVyKSB7XG4gICAgICB0aGlzLm1hdGNoZXJzLnB1c2goW3NlbGVjdG9yLCBtYXRjaGVyXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29udmVydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnQoaHRtbCkge1xuICAgICAgaWYgKHR5cGVvZiBodG1sID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sLnJlcGxhY2UoL1xcPlxccj9cXG4gK1xcPC9nLCAnPjwnKTsgLy8gUmVtb3ZlIHNwYWNlcyBiZXR3ZWVuIHRhZ3NcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZvcm1hdHMgPSB0aGlzLnF1aWxsLmdldEZvcm1hdCh0aGlzLnF1aWxsLnNlbGVjdGlvbi5zYXZlZFJhbmdlLmluZGV4KTtcbiAgICAgIGlmIChmb3JtYXRzW19jb2RlMi5kZWZhdWx0LmJsb3ROYW1lXSkge1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuY29udGFpbmVyLmlubmVyVGV4dDtcbiAgICAgICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHJldHVybiBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5pbnNlcnQodGV4dCwgX2RlZmluZVByb3BlcnR5KHt9LCBfY29kZTIuZGVmYXVsdC5ibG90TmFtZSwgZm9ybWF0c1tfY29kZTIuZGVmYXVsdC5ibG90TmFtZV0pKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcmVwYXJlTWF0Y2hpbmcgPSB0aGlzLnByZXBhcmVNYXRjaGluZygpLFxuICAgICAgICAgIF9wcmVwYXJlTWF0Y2hpbmcyID0gX3NsaWNlZFRvQXJyYXkoX3ByZXBhcmVNYXRjaGluZywgMiksXG4gICAgICAgICAgZWxlbWVudE1hdGNoZXJzID0gX3ByZXBhcmVNYXRjaGluZzJbMF0sXG4gICAgICAgICAgdGV4dE1hdGNoZXJzID0gX3ByZXBhcmVNYXRjaGluZzJbMV07XG5cbiAgICAgIHZhciBkZWx0YSA9IHRyYXZlcnNlKHRoaXMuY29udGFpbmVyLCBlbGVtZW50TWF0Y2hlcnMsIHRleHRNYXRjaGVycyk7XG4gICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgbmV3bGluZVxuICAgICAgaWYgKGRlbHRhRW5kc1dpdGgoZGVsdGEsICdcXG4nKSAmJiBkZWx0YS5vcHNbZGVsdGEub3BzLmxlbmd0aCAtIDFdLmF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgICAgICBkZWx0YSA9IGRlbHRhLmNvbXBvc2UobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGRlbHRhLmxlbmd0aCgpIC0gMSkuZGVsZXRlKDEpKTtcbiAgICAgIH1cbiAgICAgIGRlYnVnLmxvZygnY29udmVydCcsIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCwgZGVsdGEpO1xuICAgICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGFuZ2Vyb3VzbHlQYXN0ZUhUTUwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYW5nZXJvdXNseVBhc3RlSFRNTChpbmRleCwgaHRtbCkge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuQVBJO1xuXG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnF1aWxsLnNldENvbnRlbnRzKHRoaXMuY29udmVydChpbmRleCksIGh0bWwpO1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbigwLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhc3RlID0gdGhpcy5jb252ZXJ0KGh0bWwpO1xuICAgICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihpbmRleCkuY29uY2F0KHBhc3RlKSwgc291cmNlKTtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oaW5kZXggKyBwYXN0ZS5sZW5ndGgoKSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblBhc3RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25QYXN0ZShlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCB8fCAhdGhpcy5xdWlsbC5pc0VuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHZhciBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihyYW5nZS5pbmRleCk7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5xdWlsbC5zY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5jb250YWluZXIuZm9jdXMoKTtcbiAgICAgIHRoaXMucXVpbGwuc2VsZWN0aW9uLnVwZGF0ZShfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlbHRhID0gZGVsdGEuY29uY2F0KF90aGlzMi5jb252ZXJ0KCkpLmRlbGV0ZShyYW5nZS5sZW5ndGgpO1xuICAgICAgICBfdGhpczIucXVpbGwudXBkYXRlQ29udGVudHMoZGVsdGEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAvLyByYW5nZS5sZW5ndGggY29udHJpYnV0ZXMgdG8gZGVsdGEubGVuZ3RoKClcbiAgICAgICAgX3RoaXMyLnF1aWxsLnNldFNlbGVjdGlvbihkZWx0YS5sZW5ndGgoKSAtIHJhbmdlLmxlbmd0aCwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgICAgX3RoaXMyLnF1aWxsLnNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIF90aGlzMi5xdWlsbC5mb2N1cygpO1xuICAgICAgfSwgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHJlcGFyZU1hdGNoaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZU1hdGNoaW5nKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBlbGVtZW50TWF0Y2hlcnMgPSBbXSxcbiAgICAgICAgICB0ZXh0TWF0Y2hlcnMgPSBbXTtcbiAgICAgIHRoaXMubWF0Y2hlcnMuZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuICAgICAgICB2YXIgX3BhaXIgPSBfc2xpY2VkVG9BcnJheShwYWlyLCAyKSxcbiAgICAgICAgICAgIHNlbGVjdG9yID0gX3BhaXJbMF0sXG4gICAgICAgICAgICBtYXRjaGVyID0gX3BhaXJbMV07XG5cbiAgICAgICAgc3dpdGNoIChzZWxlY3Rvcikge1xuICAgICAgICAgIGNhc2UgTm9kZS5URVhUX05PREU6XG4gICAgICAgICAgICB0ZXh0TWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG4gICAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwoX3RoaXMzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETyB1c2Ugd2Vha21hcFxuICAgICAgICAgICAgICBub2RlW0RPTV9LRVldID0gbm9kZVtET01fS0VZXSB8fCBbXTtcbiAgICAgICAgICAgICAgbm9kZVtET01fS0VZXS5wdXNoKG1hdGNoZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW2VsZW1lbnRNYXRjaGVycywgdGV4dE1hdGNoZXJzXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2xpcGJvYXJkO1xufShfbW9kdWxlMi5kZWZhdWx0KTtcblxuQ2xpcGJvYXJkLkRFRkFVTFRTID0ge1xuICBtYXRjaGVyczogW10sXG4gIG1hdGNoVmlzdWFsOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBhcHBseUZvcm1hdChkZWx0YSwgZm9ybWF0LCB2YWx1ZSkge1xuICBpZiAoKHR5cGVvZiBmb3JtYXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGZvcm1hdCkpID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhmb3JtYXQpLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIGtleSkge1xuICAgICAgcmV0dXJuIGFwcGx5Rm9ybWF0KGRlbHRhLCBrZXksIGZvcm1hdFtrZXldKTtcbiAgICB9LCBkZWx0YSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRlbHRhLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIG9wKSB7XG4gICAgICBpZiAob3AuYXR0cmlidXRlcyAmJiBvcC5hdHRyaWJ1dGVzW2Zvcm1hdF0pIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhLnB1c2gob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhLmluc2VydChvcC5pbnNlcnQsICgwLCBfZXh0ZW5kMy5kZWZhdWx0KSh7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBmb3JtYXQsIHZhbHVlKSwgb3AuYXR0cmlidXRlcykpO1xuICAgICAgfVxuICAgIH0sIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGUobm9kZSkge1xuICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHJldHVybiB7fTtcbiAgdmFyIERPTV9LRVkgPSAnX19xbC1jb21wdXRlZC1zdHlsZSc7XG4gIHJldHVybiBub2RlW0RPTV9LRVldIHx8IChub2RlW0RPTV9LRVldID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSkpO1xufVxuXG5mdW5jdGlvbiBkZWx0YUVuZHNXaXRoKGRlbHRhLCB0ZXh0KSB7XG4gIHZhciBlbmRUZXh0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IGRlbHRhLm9wcy5sZW5ndGggLSAxOyBpID49IDAgJiYgZW5kVGV4dC5sZW5ndGggPCB0ZXh0Lmxlbmd0aDsgLS1pKSB7XG4gICAgdmFyIG9wID0gZGVsdGEub3BzW2ldO1xuICAgIGlmICh0eXBlb2Ygb3AuaW5zZXJ0ICE9PSAnc3RyaW5nJykgYnJlYWs7XG4gICAgZW5kVGV4dCA9IG9wLmluc2VydCArIGVuZFRleHQ7XG4gIH1cbiAgcmV0dXJuIGVuZFRleHQuc2xpY2UoLTEgKiB0ZXh0Lmxlbmd0aCkgPT09IHRleHQ7XG59XG5cbmZ1bmN0aW9uIGlzTGluZShub2RlKSB7XG4gIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7IC8vIEV4Y2x1ZGUgZW1iZWQgYmxvY2tzXG4gIHZhciBzdHlsZSA9IGNvbXB1dGVTdHlsZShub2RlKTtcbiAgcmV0dXJuIFsnYmxvY2snLCAnbGlzdC1pdGVtJ10uaW5kZXhPZihzdHlsZS5kaXNwbGF5KSA+IC0xO1xufVxuXG5mdW5jdGlvbiB0cmF2ZXJzZShub2RlLCBlbGVtZW50TWF0Y2hlcnMsIHRleHRNYXRjaGVycykge1xuICAvLyBQb3N0LW9yZGVyXG4gIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlLlRFWFRfTk9ERSkge1xuICAgIHJldHVybiB0ZXh0TWF0Y2hlcnMucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgbWF0Y2hlcikge1xuICAgICAgcmV0dXJuIG1hdGNoZXIobm9kZSwgZGVsdGEpO1xuICAgIH0sIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpKTtcbiAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBbXS5yZWR1Y2UuY2FsbChub2RlLmNoaWxkTm9kZXMgfHwgW10sIGZ1bmN0aW9uIChkZWx0YSwgY2hpbGROb2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW5EZWx0YSA9IHRyYXZlcnNlKGNoaWxkTm9kZSwgZWxlbWVudE1hdGNoZXJzLCB0ZXh0TWF0Y2hlcnMpO1xuICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgY2hpbGRyZW5EZWx0YSA9IGVsZW1lbnRNYXRjaGVycy5yZWR1Y2UoZnVuY3Rpb24gKGNoaWxkcmVuRGVsdGEsIG1hdGNoZXIpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hlcihjaGlsZE5vZGUsIGNoaWxkcmVuRGVsdGEpO1xuICAgICAgICB9LCBjaGlsZHJlbkRlbHRhKTtcbiAgICAgICAgY2hpbGRyZW5EZWx0YSA9IChjaGlsZE5vZGVbRE9NX0tFWV0gfHwgW10pLnJlZHVjZShmdW5jdGlvbiAoY2hpbGRyZW5EZWx0YSwgbWF0Y2hlcikge1xuICAgICAgICAgIHJldHVybiBtYXRjaGVyKGNoaWxkTm9kZSwgY2hpbGRyZW5EZWx0YSk7XG4gICAgICAgIH0sIGNoaWxkcmVuRGVsdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbHRhLmNvbmNhdChjaGlsZHJlbkRlbHRhKTtcbiAgICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoQWxpYXMoZm9ybWF0LCBub2RlLCBkZWx0YSkge1xuICByZXR1cm4gYXBwbHlGb3JtYXQoZGVsdGEsIGZvcm1hdCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoQXR0cmlidXRvcihub2RlLCBkZWx0YSkge1xuICB2YXIgYXR0cmlidXRlcyA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5BdHRyaWJ1dGUua2V5cyhub2RlKTtcbiAgdmFyIGNsYXNzZXMgPSBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQ2xhc3Mua2V5cyhub2RlKTtcbiAgdmFyIHN0eWxlcyA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5TdHlsZS5rZXlzKG5vZGUpO1xuICB2YXIgZm9ybWF0cyA9IHt9O1xuICBhdHRyaWJ1dGVzLmNvbmNhdChjbGFzc2VzKS5jb25jYXQoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGF0dHIgPSBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KG5hbWUsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQVRUUklCVVRFKTtcbiAgICBpZiAoYXR0ciAhPSBudWxsKSB7XG4gICAgICBmb3JtYXRzW2F0dHIuYXR0ck5hbWVdID0gYXR0ci52YWx1ZShub2RlKTtcbiAgICAgIGlmIChmb3JtYXRzW2F0dHIuYXR0ck5hbWVdKSByZXR1cm47XG4gICAgfVxuICAgIGF0dHIgPSBBVFRSSUJVVEVfQVRUUklCVVRPUlNbbmFtZV07XG4gICAgaWYgKGF0dHIgIT0gbnVsbCAmJiAoYXR0ci5hdHRyTmFtZSA9PT0gbmFtZSB8fCBhdHRyLmtleU5hbWUgPT09IG5hbWUpKSB7XG4gICAgICBmb3JtYXRzW2F0dHIuYXR0ck5hbWVdID0gYXR0ci52YWx1ZShub2RlKSB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGF0dHIgPSBTVFlMRV9BVFRSSUJVVE9SU1tuYW1lXTtcbiAgICBpZiAoYXR0ciAhPSBudWxsICYmIChhdHRyLmF0dHJOYW1lID09PSBuYW1lIHx8IGF0dHIua2V5TmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgIGF0dHIgPSBTVFlMRV9BVFRSSUJVVE9SU1tuYW1lXTtcbiAgICAgIGZvcm1hdHNbYXR0ci5hdHRyTmFtZV0gPSBhdHRyLnZhbHVlKG5vZGUpIHx8IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xuICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID4gMCkge1xuICAgIGRlbHRhID0gYXBwbHlGb3JtYXQoZGVsdGEsIGZvcm1hdHMpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hCbG90KG5vZGUsIGRlbHRhKSB7XG4gIHZhciBtYXRjaCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobm9kZSk7XG4gIGlmIChtYXRjaCA9PSBudWxsKSByZXR1cm4gZGVsdGE7XG4gIGlmIChtYXRjaC5wcm90b3R5cGUgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKSB7XG4gICAgdmFyIGVtYmVkID0ge307XG4gICAgdmFyIHZhbHVlID0gbWF0Y2gudmFsdWUobm9kZSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGVtYmVkW21hdGNoLmJsb3ROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5pbnNlcnQoZW1iZWQsIG1hdGNoLmZvcm1hdHMobm9kZSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgbWF0Y2guZm9ybWF0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlbHRhID0gYXBwbHlGb3JtYXQoZGVsdGEsIG1hdGNoLmJsb3ROYW1lLCBtYXRjaC5mb3JtYXRzKG5vZGUpKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoQnJlYWsobm9kZSwgZGVsdGEpIHtcbiAgaWYgKCFkZWx0YUVuZHNXaXRoKGRlbHRhLCAnXFxuJykpIHtcbiAgICBkZWx0YS5pbnNlcnQoJ1xcbicpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hJZ25vcmUoKSB7XG4gIHJldHVybiBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hJbmRlbnQobm9kZSwgZGVsdGEpIHtcbiAgdmFyIG1hdGNoID0gX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShub2RlKTtcbiAgaWYgKG1hdGNoID09IG51bGwgfHwgbWF0Y2guYmxvdE5hbWUgIT09ICdsaXN0LWl0ZW0nIHx8ICFkZWx0YUVuZHNXaXRoKGRlbHRhLCAnXFxuJykpIHtcbiAgICByZXR1cm4gZGVsdGE7XG4gIH1cbiAgdmFyIGluZGVudCA9IC0xLFxuICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICB3aGlsZSAoIXBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWNsaXBib2FyZCcpKSB7XG4gICAgaWYgKChfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KHBhcmVudCkgfHwge30pLmJsb3ROYW1lID09PSAnbGlzdCcpIHtcbiAgICAgIGluZGVudCArPSAxO1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuICBpZiAoaW5kZW50IDw9IDApIHJldHVybiBkZWx0YTtcbiAgcmV0dXJuIGRlbHRhLmNvbXBvc2UobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGRlbHRhLmxlbmd0aCgpIC0gMSkucmV0YWluKDEsIHsgaW5kZW50OiBpbmRlbnQgfSkpO1xufVxuXG5mdW5jdGlvbiBtYXRjaE5ld2xpbmUobm9kZSwgZGVsdGEpIHtcbiAgaWYgKCFkZWx0YUVuZHNXaXRoKGRlbHRhLCAnXFxuJykpIHtcbiAgICBpZiAoaXNMaW5lKG5vZGUpIHx8IGRlbHRhLmxlbmd0aCgpID4gMCAmJiBub2RlLm5leHRTaWJsaW5nICYmIGlzTGluZShub2RlLm5leHRTaWJsaW5nKSkge1xuICAgICAgZGVsdGEuaW5zZXJ0KCdcXG4nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBtYXRjaFNwYWNpbmcobm9kZSwgZGVsdGEpIHtcbiAgaWYgKGlzTGluZShub2RlKSAmJiBub2RlLm5leHRFbGVtZW50U2libGluZyAhPSBudWxsICYmICFkZWx0YUVuZHNXaXRoKGRlbHRhLCAnXFxuXFxuJykpIHtcbiAgICB2YXIgbm9kZUhlaWdodCA9IG5vZGUub2Zmc2V0SGVpZ2h0ICsgcGFyc2VGbG9hdChjb21wdXRlU3R5bGUobm9kZSkubWFyZ2luVG9wKSArIHBhcnNlRmxvYXQoY29tcHV0ZVN0eWxlKG5vZGUpLm1hcmdpbkJvdHRvbSk7XG4gICAgaWYgKG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nLm9mZnNldFRvcCA+IG5vZGUub2Zmc2V0VG9wICsgbm9kZUhlaWdodCAqIDEuNSkge1xuICAgICAgZGVsdGEuaW5zZXJ0KCdcXG4nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBtYXRjaFN0eWxlcyhub2RlLCBkZWx0YSkge1xuICB2YXIgZm9ybWF0cyA9IHt9O1xuICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlIHx8IHt9O1xuICBpZiAoc3R5bGUuZm9udFN0eWxlICYmIGNvbXB1dGVTdHlsZShub2RlKS5mb250U3R5bGUgPT09ICdpdGFsaWMnKSB7XG4gICAgZm9ybWF0cy5pdGFsaWMgPSB0cnVlO1xuICB9XG4gIGlmIChzdHlsZS5mb250V2VpZ2h0ICYmIChjb21wdXRlU3R5bGUobm9kZSkuZm9udFdlaWdodC5zdGFydHNXaXRoKCdib2xkJykgfHwgcGFyc2VJbnQoY29tcHV0ZVN0eWxlKG5vZGUpLmZvbnRXZWlnaHQpID49IDcwMCkpIHtcbiAgICBmb3JtYXRzLmJvbGQgPSB0cnVlO1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyhmb3JtYXRzKS5sZW5ndGggPiAwKSB7XG4gICAgZGVsdGEgPSBhcHBseUZvcm1hdChkZWx0YSwgZm9ybWF0cyk7XG4gIH1cbiAgaWYgKHBhcnNlRmxvYXQoc3R5bGUudGV4dEluZGVudCB8fCAwKSA+IDApIHtcbiAgICAvLyBDb3VsZCBiZSAwLjVpblxuICAgIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkuaW5zZXJ0KCdcXHQnKS5jb25jYXQoZGVsdGEpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hUZXh0KG5vZGUsIGRlbHRhKSB7XG4gIHZhciB0ZXh0ID0gbm9kZS5kYXRhO1xuICAvLyBXb3JkIHJlcHJlc2VudHMgZW1wdHkgbGluZSB3aXRoIDxvOnA+Jm5ic3A7PC9vOnA+XG4gIGlmIChub2RlLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ086UCcpIHtcbiAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KHRleHQudHJpbSgpKTtcbiAgfVxuICBpZiAodGV4dC50cmltKCkubGVuZ3RoID09PSAwICYmIG5vZGUucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWNsaXBib2FyZCcpKSB7XG4gICAgcmV0dXJuIGRlbHRhO1xuICB9XG4gIGlmICghY29tcHV0ZVN0eWxlKG5vZGUucGFyZW50Tm9kZSkud2hpdGVTcGFjZS5zdGFydHNXaXRoKCdwcmUnKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLXN0eWxlXG4gICAgdmFyIHJlcGxhY2VyID0gZnVuY3Rpb24gcmVwbGFjZXIoY29sbGFwc2UsIG1hdGNoKSB7XG4gICAgICBtYXRjaCA9IG1hdGNoLnJlcGxhY2UoL1teXFx1MDBhMF0vZywgJycpOyAvLyBcXHUwMGEwIGlzIG5ic3A7XG4gICAgICByZXR1cm4gbWF0Y2gubGVuZ3RoIDwgMSAmJiBjb2xsYXBzZSA/ICcgJyA6IG1hdGNoO1xuICAgIH07XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxuL2csICcgJykucmVwbGFjZSgvXFxuL2csICcgJyk7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxzXFxzKy9nLCByZXBsYWNlci5iaW5kKHJlcGxhY2VyLCB0cnVlKSk7IC8vIGNvbGxhcHNlIHdoaXRlc3BhY2VcbiAgICBpZiAobm9kZS5wcmV2aW91c1NpYmxpbmcgPT0gbnVsbCAmJiBpc0xpbmUobm9kZS5wYXJlbnROb2RlKSB8fCBub2RlLnByZXZpb3VzU2libGluZyAhPSBudWxsICYmIGlzTGluZShub2RlLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL15cXHMrLywgcmVwbGFjZXIuYmluZChyZXBsYWNlciwgZmFsc2UpKTtcbiAgICB9XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcgPT0gbnVsbCAmJiBpc0xpbmUobm9kZS5wYXJlbnROb2RlKSB8fCBub2RlLm5leHRTaWJsaW5nICE9IG51bGwgJiYgaXNMaW5lKG5vZGUubmV4dFNpYmxpbmcpKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHMrJC8sIHJlcGxhY2VyLmJpbmQocmVwbGFjZXIsIGZhbHNlKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWx0YS5pbnNlcnQodGV4dCk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENsaXBib2FyZDtcbmV4cG9ydHMubWF0Y2hBdHRyaWJ1dG9yID0gbWF0Y2hBdHRyaWJ1dG9yO1xuZXhwb3J0cy5tYXRjaEJsb3QgPSBtYXRjaEJsb3Q7XG5leHBvcnRzLm1hdGNoTmV3bGluZSA9IG1hdGNoTmV3bGluZTtcbmV4cG9ydHMubWF0Y2hTcGFjaW5nID0gbWF0Y2hTcGFjaW5nO1xuZXhwb3J0cy5tYXRjaFRleHQgPSBtYXRjaFRleHQ7XG5cbi8qKiovIH0pLFxuLyogNTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEJvbGQgPSBmdW5jdGlvbiAoX0lubGluZSkge1xuICBfaW5oZXJpdHMoQm9sZCwgX0lubGluZSk7XG5cbiAgZnVuY3Rpb24gQm9sZCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm9sZCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJvbGQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb2xkKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQm9sZCwgW3tcbiAgICBrZXk6ICdvcHRpbWl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKGNvbnRleHQpIHtcbiAgICAgIF9nZXQoQm9sZC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb2xkLnByb3RvdHlwZSksICdvcHRpbWl6ZScsIHRoaXMpLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICBpZiAodGhpcy5kb21Ob2RlLnRhZ05hbWUgIT09IHRoaXMuc3RhdGljcy50YWdOYW1lWzBdKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZVdpdGgodGhpcy5zdGF0aWNzLmJsb3ROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiBfZ2V0KEJvbGQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb2xkKSwgJ2NyZWF0ZScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQm9sZDtcbn0oX2lubGluZTIuZGVmYXVsdCk7XG5cbkJvbGQuYmxvdE5hbWUgPSAnYm9sZCc7XG5Cb2xkLnRhZ05hbWUgPSBbJ1NUUk9ORycsICdCJ107XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJvbGQ7XG5cbi8qKiovIH0pLFxuLyogNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWRkQ29udHJvbHMgPSBleHBvcnRzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9xdWlsbERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9xdWlsbERlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsRGVsdGEpO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfcXVpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX3F1aWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsKTtcblxudmFyIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcblxudmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBkZWJ1ZyA9ICgwLCBfbG9nZ2VyMi5kZWZhdWx0KSgncXVpbGw6dG9vbGJhcicpO1xuXG52YXIgVG9vbGJhciA9IGZ1bmN0aW9uIChfTW9kdWxlKSB7XG4gIF9pbmhlcml0cyhUb29sYmFyLCBfTW9kdWxlKTtcblxuICBmdW5jdGlvbiBUb29sYmFyKHF1aWxsLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2xiYXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFRvb2xiYXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUb29sYmFyKSkuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucykpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX3RoaXMub3B0aW9ucy5jb250YWluZXIpKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBhZGRDb250cm9scyhjb250YWluZXIsIF90aGlzLm9wdGlvbnMuY29udGFpbmVyKTtcbiAgICAgIHF1aWxsLmNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjb250YWluZXIsIHF1aWxsLmNvbnRhaW5lcik7XG4gICAgICBfdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgX3RoaXMub3B0aW9ucy5jb250YWluZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBfdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuY29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuY29udGFpbmVyID0gX3RoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgfVxuICAgIGlmICghKF90aGlzLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgdmFyIF9yZXQ7XG5cbiAgICAgIHJldHVybiBfcmV0ID0gZGVidWcuZXJyb3IoJ0NvbnRhaW5lciByZXF1aXJlZCBmb3IgdG9vbGJhcicsIF90aGlzLm9wdGlvbnMpLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gICAgfVxuICAgIF90aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdxbC10b29sYmFyJyk7XG4gICAgX3RoaXMuY29udHJvbHMgPSBbXTtcbiAgICBfdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF90aGlzLm9wdGlvbnMuaGFuZGxlcnMpLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgX3RoaXMuYWRkSGFuZGxlcihmb3JtYXQsIF90aGlzLm9wdGlvbnMuaGFuZGxlcnNbZm9ybWF0XSk7XG4gICAgfSk7XG4gICAgW10uZm9yRWFjaC5jYWxsKF90aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdidXR0b24sIHNlbGVjdCcpLCBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIF90aGlzLmF0dGFjaChpbnB1dCk7XG4gICAgfSk7XG4gICAgX3RoaXMucXVpbGwub24oX3F1aWxsMi5kZWZhdWx0LmV2ZW50cy5FRElUT1JfQ0hBTkdFLCBmdW5jdGlvbiAodHlwZSwgcmFuZ2UpIHtcbiAgICAgIGlmICh0eXBlID09PSBfcXVpbGwyLmRlZmF1bHQuZXZlbnRzLlNFTEVDVElPTl9DSEFOR0UpIHtcbiAgICAgICAgX3RoaXMudXBkYXRlKHJhbmdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpcy5xdWlsbC5vbihfcXVpbGwyLmRlZmF1bHQuZXZlbnRzLlNDUk9MTF9PUFRJTUlaRSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHF1aWxsJHNlbGVjdGlvbiA9IF90aGlzLnF1aWxsLnNlbGVjdGlvbi5nZXRSYW5nZSgpLFxuICAgICAgICAgIF90aGlzJHF1aWxsJHNlbGVjdGlvbjIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRxdWlsbCRzZWxlY3Rpb24sIDEpLFxuICAgICAgICAgIHJhbmdlID0gX3RoaXMkcXVpbGwkc2VsZWN0aW9uMlswXTsgLy8gcXVpbGwuZ2V0U2VsZWN0aW9uIHRyaWdnZXJzIHVwZGF0ZVxuXG5cbiAgICAgIF90aGlzLnVwZGF0ZShyYW5nZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRvb2xiYXIsIFt7XG4gICAga2V5OiAnYWRkSGFuZGxlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEhhbmRsZXIoZm9ybWF0LCBoYW5kbGVyKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW2Zvcm1hdF0gPSBoYW5kbGVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F0dGFjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaChpbnB1dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtYXQgPSBbXS5maW5kLmNhbGwoaW5wdXQuY2xhc3NMaXN0LCBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIHJldHVybiBjbGFzc05hbWUuaW5kZXhPZigncWwtJykgPT09IDA7XG4gICAgICB9KTtcbiAgICAgIGlmICghZm9ybWF0KSByZXR1cm47XG4gICAgICBmb3JtYXQgPSBmb3JtYXQuc2xpY2UoJ3FsLScubGVuZ3RoKTtcbiAgICAgIGlmIChpbnB1dC50YWdOYW1lID09PSAnQlVUVE9OJykge1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYW5kbGVyc1tmb3JtYXRdID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMucXVpbGwuc2Nyb2xsLndoaXRlbGlzdCAhPSBudWxsICYmIHRoaXMucXVpbGwuc2Nyb2xsLndoaXRlbGlzdFtmb3JtYXRdID09IG51bGwpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKCdpZ25vcmluZyBhdHRhY2hpbmcgdG8gZGlzYWJsZWQgZm9ybWF0JywgZm9ybWF0LCBpbnB1dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KGZvcm1hdCkgPT0gbnVsbCkge1xuICAgICAgICAgIGRlYnVnLndhcm4oJ2lnbm9yaW5nIGF0dGFjaGluZyB0byBub25leGlzdGVudCBmb3JtYXQnLCBmb3JtYXQsIGlucHV0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBldmVudE5hbWUgPSBpbnB1dC50YWdOYW1lID09PSAnU0VMRUNUJyA/ICdjaGFuZ2UnIDogJ2NsaWNrJztcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChpbnB1dC50YWdOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICAgIGlmIChpbnB1dC5zZWxlY3RlZEluZGV4IDwgMCkgcmV0dXJuO1xuICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGlucHV0Lm9wdGlvbnNbaW5wdXQuc2VsZWN0ZWRJbmRleF07XG4gICAgICAgICAgaWYgKHNlbGVjdGVkLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBzZWxlY3RlZC52YWx1ZSB8fCBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNsYXNzTGlzdC5jb250YWlucygncWwtYWN0aXZlJykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gaW5wdXQudmFsdWUgfHwgIWlucHV0Lmhhc0F0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzMi5xdWlsbC5mb2N1cygpO1xuXG4gICAgICAgIHZhciBfcXVpbGwkc2VsZWN0aW9uJGdldFIgPSBfdGhpczIucXVpbGwuc2VsZWN0aW9uLmdldFJhbmdlKCksXG4gICAgICAgICAgICBfcXVpbGwkc2VsZWN0aW9uJGdldFIyID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJHNlbGVjdGlvbiRnZXRSLCAxKSxcbiAgICAgICAgICAgIHJhbmdlID0gX3F1aWxsJHNlbGVjdGlvbiRnZXRSMlswXTtcblxuICAgICAgICBpZiAoX3RoaXMyLmhhbmRsZXJzW2Zvcm1hdF0gIT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzMi5oYW5kbGVyc1tmb3JtYXRdLmNhbGwoX3RoaXMyLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShmb3JtYXQpLnByb3RvdHlwZSBpbnN0YW5jZW9mIF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQpIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb21wdCgnRW50ZXIgJyArIGZvcm1hdCk7XG4gICAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuICAgICAgICAgIF90aGlzMi5xdWlsbC51cGRhdGVDb250ZW50cyhuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpLmRlbGV0ZShyYW5nZS5sZW5ndGgpLmluc2VydChfZGVmaW5lUHJvcGVydHkoe30sIGZvcm1hdCwgdmFsdWUpKSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMyLnF1aWxsLmZvcm1hdChmb3JtYXQsIHZhbHVlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczIudXBkYXRlKHJhbmdlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gVE9ETyB1c2Ugd2Vha21hcFxuICAgICAgdGhpcy5jb250cm9scy5wdXNoKFtmb3JtYXQsIGlucHV0XSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHJhbmdlKSB7XG4gICAgICB2YXIgZm9ybWF0cyA9IHJhbmdlID09IG51bGwgPyB7fSA6IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KHJhbmdlKTtcbiAgICAgIHRoaXMuY29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuICAgICAgICB2YXIgX3BhaXIgPSBfc2xpY2VkVG9BcnJheShwYWlyLCAyKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IF9wYWlyWzBdLFxuICAgICAgICAgICAgaW5wdXQgPSBfcGFpclsxXTtcblxuICAgICAgICBpZiAoaW5wdXQudGFnTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgICB2YXIgb3B0aW9uID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb24gPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0c1tmb3JtYXRdID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbiA9IGlucHV0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvbltzZWxlY3RlZF0nKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGZvcm1hdHNbZm9ybWF0XSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZvcm1hdHNbZm9ybWF0XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcIi9nLCAnXFxcXFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb24gPSBpbnB1dC5xdWVyeVNlbGVjdG9yKCdvcHRpb25bdmFsdWU9XCInICsgdmFsdWUgKyAnXCJdJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSAnJzsgLy8gVE9ETyBtYWtlIGNvbmZpZ3VyYWJsZT9cbiAgICAgICAgICAgIGlucHV0LnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJhbmdlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoJ3FsLWFjdGl2ZScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICAvLyBib3RoIGJlaW5nIG51bGwgc2hvdWxkIG1hdGNoIChkZWZhdWx0IHZhbHVlcylcbiAgICAgICAgICAgIC8vICcxJyBzaG91bGQgbWF0Y2ggd2l0aCAxIChoZWFkZXJzKVxuICAgICAgICAgICAgdmFyIGlzQWN0aXZlID0gZm9ybWF0c1tmb3JtYXRdID09PSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgZm9ybWF0c1tmb3JtYXRdICE9IG51bGwgJiYgZm9ybWF0c1tmb3JtYXRdLnRvU3RyaW5nKCkgPT09IGlucHV0LmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCBmb3JtYXRzW2Zvcm1hdF0gPT0gbnVsbCAmJiAhaW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LnRvZ2dsZSgncWwtYWN0aXZlJywgaXNBY3RpdmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QudG9nZ2xlKCdxbC1hY3RpdmUnLCBmb3JtYXRzW2Zvcm1hdF0gIT0gbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVG9vbGJhcjtcbn0oX21vZHVsZTIuZGVmYXVsdCk7XG5cblRvb2xiYXIuREVGQVVMVFMgPSB7fTtcblxuZnVuY3Rpb24gYWRkQnV0dG9uKGNvbnRhaW5lciwgZm9ybWF0LCB2YWx1ZSkge1xuICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgaW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdxbC0nICsgZm9ybWF0KTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIGFkZENvbnRyb2xzKGNvbnRhaW5lciwgZ3JvdXBzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShncm91cHNbMF0pKSB7XG4gICAgZ3JvdXBzID0gW2dyb3Vwc107XG4gIH1cbiAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xzKSB7XG4gICAgdmFyIGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGdyb3VwLmNsYXNzTGlzdC5hZGQoJ3FsLWZvcm1hdHMnKTtcbiAgICBjb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbnRyb2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFkZEJ1dHRvbihncm91cCwgY29udHJvbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZm9ybWF0ID0gT2JqZWN0LmtleXMoY29udHJvbClbMF07XG4gICAgICAgIHZhciB2YWx1ZSA9IGNvbnRyb2xbZm9ybWF0XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgYWRkU2VsZWN0KGdyb3VwLCBmb3JtYXQsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRCdXR0b24oZ3JvdXAsIGZvcm1hdCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGdyb3VwKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFNlbGVjdChjb250YWluZXIsIGZvcm1hdCwgdmFsdWVzKSB7XG4gIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdxbC0nICsgZm9ybWF0KTtcbiAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb24uc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICdzZWxlY3RlZCcpO1xuICAgIH1cbiAgICBpbnB1dC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICB9KTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlucHV0KTtcbn1cblxuVG9vbGJhci5ERUZBVUxUUyA9IHtcbiAgY29udGFpbmVyOiBudWxsLFxuICBoYW5kbGVyczoge1xuICAgIGNsZWFuOiBmdW5jdGlvbiBjbGVhbigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKHJhbmdlID09IG51bGwpIHJldHVybjtcbiAgICAgIGlmIChyYW5nZS5sZW5ndGggPT0gMCkge1xuICAgICAgICB2YXIgZm9ybWF0cyA9IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KCk7XG4gICAgICAgIE9iamVjdC5rZXlzKGZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAvLyBDbGVhbiBmdW5jdGlvbmFsaXR5IGluIGV4aXN0aW5nIGFwcHMgb25seSBjbGVhbiBpbmxpbmUgZm9ybWF0c1xuICAgICAgICAgIGlmIChfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KG5hbWUsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuSU5MSU5FKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpczMucXVpbGwuZm9ybWF0KG5hbWUsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdWlsbC5yZW1vdmVGb3JtYXQocmFuZ2UsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlyZWN0aW9uOiBmdW5jdGlvbiBkaXJlY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBhbGlnbiA9IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KClbJ2FsaWduJ107XG4gICAgICBpZiAodmFsdWUgPT09ICdydGwnICYmIGFsaWduID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2FsaWduJywgJ3JpZ2h0JywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9IGVsc2UgaWYgKCF2YWx1ZSAmJiBhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnYWxpZ24nLCBmYWxzZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnZGlyZWN0aW9uJywgdmFsdWUsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgIH0sXG4gICAgaW5kZW50OiBmdW5jdGlvbiBpbmRlbnQodmFsdWUpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB2YXIgZm9ybWF0cyA9IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KHJhbmdlKTtcbiAgICAgIHZhciBpbmRlbnQgPSBwYXJzZUludChmb3JtYXRzLmluZGVudCB8fCAwKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJysxJyB8fCB2YWx1ZSA9PT0gJy0xJykge1xuICAgICAgICB2YXIgbW9kaWZpZXIgPSB2YWx1ZSA9PT0gJysxJyA/IDEgOiAtMTtcbiAgICAgICAgaWYgKGZvcm1hdHMuZGlyZWN0aW9uID09PSAncnRsJykgbW9kaWZpZXIgKj0gLTE7XG4gICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdpbmRlbnQnLCBpbmRlbnQgKyBtb2RpZmllciwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbiBsaW5rKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgdmFsdWUgPSBwcm9tcHQoJ0VudGVyIGxpbmsgVVJMOicpO1xuICAgICAgfVxuICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2xpbmsnLCB2YWx1ZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgfSxcbiAgICBsaXN0OiBmdW5jdGlvbiBsaXN0KHZhbHVlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuICAgICAgdmFyIGZvcm1hdHMgPSB0aGlzLnF1aWxsLmdldEZvcm1hdChyYW5nZSk7XG4gICAgICBpZiAodmFsdWUgPT09ICdjaGVjaycpIHtcbiAgICAgICAgaWYgKGZvcm1hdHNbJ2xpc3QnXSA9PT0gJ2NoZWNrZWQnIHx8IGZvcm1hdHNbJ2xpc3QnXSA9PT0gJ3VuY2hlY2tlZCcpIHtcbiAgICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGlzdCcsIGZhbHNlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGlzdCcsICd1bmNoZWNrZWQnLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2xpc3QnLCB2YWx1ZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUb29sYmFyO1xuZXhwb3J0cy5hZGRDb250cm9scyA9IGFkZENvbnRyb2xzO1xuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwb2x5bGluZSBjbGFzcz1cXFwicWwtZXZlbiBxbC1zdHJva2VcXFwiIHBvaW50cz1cXFwiNSA3IDMgOSA1IDExXFxcIj48L3BvbHlsaW5lPiA8cG9seWxpbmUgY2xhc3M9XFxcInFsLWV2ZW4gcWwtc3Ryb2tlXFxcIiBwb2ludHM9XFxcIjEzIDcgMTUgOSAxMyAxMVxcXCI+PC9wb2x5bGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTEwIHgyPTggeTE9NSB5Mj0xMz48L2xpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9waWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxudmFyIF9waWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGlja2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ29sb3JQaWNrZXIgPSBmdW5jdGlvbiAoX1BpY2tlcikge1xuICBfaW5oZXJpdHMoQ29sb3JQaWNrZXIsIF9QaWNrZXIpO1xuXG4gIGZ1bmN0aW9uIENvbG9yUGlja2VyKHNlbGVjdCwgbGFiZWwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3JQaWNrZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbG9yUGlja2VyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29sb3JQaWNrZXIpKS5jYWxsKHRoaXMsIHNlbGVjdCkpO1xuXG4gICAgX3RoaXMubGFiZWwuaW5uZXJIVE1MID0gbGFiZWw7XG4gICAgX3RoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3FsLWNvbG9yLXBpY2tlcicpO1xuICAgIFtdLnNsaWNlLmNhbGwoX3RoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5xbC1waWNrZXItaXRlbScpLCAwLCA3KS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3FsLXByaW1hcnknKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29sb3JQaWNrZXIsIFt7XG4gICAga2V5OiAnYnVpbGRJdGVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRJdGVtKG9wdGlvbikge1xuICAgICAgdmFyIGl0ZW0gPSBfZ2V0KENvbG9yUGlja2VyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbG9yUGlja2VyLnByb3RvdHlwZSksICdidWlsZEl0ZW0nLCB0aGlzKS5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICBpdGVtLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG9wdGlvbi5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgJyc7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZWxlY3RJdGVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0SXRlbShpdGVtLCB0cmlnZ2VyKSB7XG4gICAgICBfZ2V0KENvbG9yUGlja2VyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbG9yUGlja2VyLnByb3RvdHlwZSksICdzZWxlY3RJdGVtJywgdGhpcykuY2FsbCh0aGlzLCBpdGVtLCB0cmlnZ2VyKTtcbiAgICAgIHZhciBjb2xvckxhYmVsID0gdGhpcy5sYWJlbC5xdWVyeVNlbGVjdG9yKCcucWwtY29sb3ItbGFiZWwnKTtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZW0gPyBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpIHx8ICcnIDogJyc7XG4gICAgICBpZiAoY29sb3JMYWJlbCkge1xuICAgICAgICBpZiAoY29sb3JMYWJlbC50YWdOYW1lID09PSAnbGluZScpIHtcbiAgICAgICAgICBjb2xvckxhYmVsLnN0eWxlLnN0cm9rZSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbG9yTGFiZWwuc3R5bGUuZmlsbCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbG9yUGlja2VyO1xufShfcGlja2VyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ29sb3JQaWNrZXI7XG5cbi8qKiovIH0pLFxuLyogNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG52YXIgX3BpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9waWNrZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBJY29uUGlja2VyID0gZnVuY3Rpb24gKF9QaWNrZXIpIHtcbiAgX2luaGVyaXRzKEljb25QaWNrZXIsIF9QaWNrZXIpO1xuXG4gIGZ1bmN0aW9uIEljb25QaWNrZXIoc2VsZWN0LCBpY29ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJY29uUGlja2VyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJY29uUGlja2VyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWNvblBpY2tlcikpLmNhbGwodGhpcywgc2VsZWN0KSk7XG5cbiAgICBfdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgncWwtaWNvbi1waWNrZXInKTtcbiAgICBbXS5mb3JFYWNoLmNhbGwoX3RoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5xbC1waWNrZXItaXRlbScpLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaXRlbS5pbm5lckhUTUwgPSBpY29uc1tpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpIHx8ICcnXTtcbiAgICB9KTtcbiAgICBfdGhpcy5kZWZhdWx0SXRlbSA9IF90aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucWwtc2VsZWN0ZWQnKTtcbiAgICBfdGhpcy5zZWxlY3RJdGVtKF90aGlzLmRlZmF1bHRJdGVtKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSWNvblBpY2tlciwgW3tcbiAgICBrZXk6ICdzZWxlY3RJdGVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0SXRlbShpdGVtLCB0cmlnZ2VyKSB7XG4gICAgICBfZ2V0KEljb25QaWNrZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWNvblBpY2tlci5wcm90b3R5cGUpLCAnc2VsZWN0SXRlbScsIHRoaXMpLmNhbGwodGhpcywgaXRlbSwgdHJpZ2dlcik7XG4gICAgICBpdGVtID0gaXRlbSB8fCB0aGlzLmRlZmF1bHRJdGVtO1xuICAgICAgdGhpcy5sYWJlbC5pbm5lckhUTUwgPSBpdGVtLmlubmVySFRNTDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSWNvblBpY2tlcjtcbn0oX3BpY2tlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEljb25QaWNrZXI7XG5cbi8qKiovIH0pLFxuLyogNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvb2x0aXAocXVpbGwsIGJvdW5kc0NvbnRhaW5lcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XG5cbiAgICB0aGlzLnF1aWxsID0gcXVpbGw7XG4gICAgdGhpcy5ib3VuZHNDb250YWluZXIgPSBib3VuZHNDb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICB0aGlzLnJvb3QgPSBxdWlsbC5hZGRDb250YWluZXIoJ3FsLXRvb2x0aXAnKTtcbiAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gdGhpcy5jb25zdHJ1Y3Rvci5URU1QTEFURTtcbiAgICBpZiAodGhpcy5xdWlsbC5yb290ID09PSB0aGlzLnF1aWxsLnNjcm9sbGluZ0NvbnRhaW5lcikge1xuICAgICAgdGhpcy5xdWlsbC5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucm9vdC5zdHlsZS5tYXJnaW5Ub3AgPSAtMSAqIF90aGlzLnF1aWxsLnJvb3Quc2Nyb2xsVG9wICsgJ3B4JztcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmhpZGUoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUb29sdGlwLCBbe1xuICAgIGtleTogJ2hpZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5hZGQoJ3FsLWhpZGRlbicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Bvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb24ocmVmZXJlbmNlKSB7XG4gICAgICB2YXIgbGVmdCA9IHJlZmVyZW5jZS5sZWZ0ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIHRoaXMucm9vdC5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAvLyByb290LnNjcm9sbFRvcCBzaG91bGQgYmUgMCBpZiBzY3JvbGxDb250YWluZXIgIT09IHJvb3RcbiAgICAgIHZhciB0b3AgPSByZWZlcmVuY2UuYm90dG9tICsgdGhpcy5xdWlsbC5yb290LnNjcm9sbFRvcDtcbiAgICAgIHRoaXMucm9vdC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgICB0aGlzLnJvb3Quc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgIHRoaXMucm9vdC5jbGFzc0xpc3QucmVtb3ZlKCdxbC1mbGlwJyk7XG4gICAgICB2YXIgY29udGFpbmVyQm91bmRzID0gdGhpcy5ib3VuZHNDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgcm9vdEJvdW5kcyA9IHRoaXMucm9vdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzaGlmdCA9IDA7XG4gICAgICBpZiAocm9vdEJvdW5kcy5yaWdodCA+IGNvbnRhaW5lckJvdW5kcy5yaWdodCkge1xuICAgICAgICBzaGlmdCA9IGNvbnRhaW5lckJvdW5kcy5yaWdodCAtIHJvb3RCb3VuZHMucmlnaHQ7XG4gICAgICAgIHRoaXMucm9vdC5zdHlsZS5sZWZ0ID0gbGVmdCArIHNoaWZ0ICsgJ3B4JztcbiAgICAgIH1cbiAgICAgIGlmIChyb290Qm91bmRzLmxlZnQgPCBjb250YWluZXJCb3VuZHMubGVmdCkge1xuICAgICAgICBzaGlmdCA9IGNvbnRhaW5lckJvdW5kcy5sZWZ0IC0gcm9vdEJvdW5kcy5sZWZ0O1xuICAgICAgICB0aGlzLnJvb3Quc3R5bGUubGVmdCA9IGxlZnQgKyBzaGlmdCArICdweCc7XG4gICAgICB9XG4gICAgICBpZiAocm9vdEJvdW5kcy5ib3R0b20gPiBjb250YWluZXJCb3VuZHMuYm90dG9tKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSByb290Qm91bmRzLmJvdHRvbSAtIHJvb3RCb3VuZHMudG9wO1xuICAgICAgICB2YXIgdmVydGljYWxTaGlmdCA9IHJlZmVyZW5jZS5ib3R0b20gLSByZWZlcmVuY2UudG9wICsgaGVpZ2h0O1xuICAgICAgICB0aGlzLnJvb3Quc3R5bGUudG9wID0gdG9wIC0gdmVydGljYWxTaGlmdCArICdweCc7XG4gICAgICAgIHRoaXMucm9vdC5jbGFzc0xpc3QuYWRkKCdxbC1mbGlwJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hpZnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2hvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB0aGlzLnJvb3QuY2xhc3NMaXN0LnJlbW92ZSgncWwtZWRpdGluZycpO1xuICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5yZW1vdmUoJ3FsLWhpZGRlbicpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUb29sdGlwO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUb29sdGlwO1xuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZXh0ZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZCk7XG5cbnZhciBfZW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfZW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbWl0dGVyKTtcblxudmFyIF9iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG5cbnZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcblxudmFyIF9saW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbnZhciBfbGluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saW5rKTtcblxudmFyIF9zZWxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9pY29ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuXG52YXIgX2ljb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ljb25zKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVE9PTEJBUl9DT05GSUcgPSBbW3sgaGVhZGVyOiBbJzEnLCAnMicsICczJywgZmFsc2VdIH1dLCBbJ2JvbGQnLCAnaXRhbGljJywgJ3VuZGVybGluZScsICdsaW5rJ10sIFt7IGxpc3Q6ICdvcmRlcmVkJyB9LCB7IGxpc3Q6ICdidWxsZXQnIH1dLCBbJ2NsZWFuJ11dO1xuXG52YXIgU25vd1RoZW1lID0gZnVuY3Rpb24gKF9CYXNlVGhlbWUpIHtcbiAgX2luaGVyaXRzKFNub3dUaGVtZSwgX0Jhc2VUaGVtZSk7XG5cbiAgZnVuY3Rpb24gU25vd1RoZW1lKHF1aWxsLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNub3dUaGVtZSk7XG5cbiAgICBpZiAob3B0aW9ucy5tb2R1bGVzLnRvb2xiYXIgIT0gbnVsbCAmJiBvcHRpb25zLm1vZHVsZXMudG9vbGJhci5jb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5tb2R1bGVzLnRvb2xiYXIuY29udGFpbmVyID0gVE9PTEJBUl9DT05GSUc7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNub3dUaGVtZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNub3dUaGVtZSkpLmNhbGwodGhpcywgcXVpbGwsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnF1aWxsLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdxbC1zbm93Jyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNub3dUaGVtZSwgW3tcbiAgICBrZXk6ICdleHRlbmRUb29sYmFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kVG9vbGJhcih0b29sYmFyKSB7XG4gICAgICB0b29sYmFyLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdxbC1zbm93Jyk7XG4gICAgICB0aGlzLmJ1aWxkQnV0dG9ucyhbXS5zbGljZS5jYWxsKHRvb2xiYXIuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpKSwgX2ljb25zMi5kZWZhdWx0KTtcbiAgICAgIHRoaXMuYnVpbGRQaWNrZXJzKFtdLnNsaWNlLmNhbGwodG9vbGJhci5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0JykpLCBfaWNvbnMyLmRlZmF1bHQpO1xuICAgICAgdGhpcy50b29sdGlwID0gbmV3IFNub3dUb29sdGlwKHRoaXMucXVpbGwsIHRoaXMub3B0aW9ucy5ib3VuZHMpO1xuICAgICAgaWYgKHRvb2xiYXIuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5xbC1saW5rJykpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5rZXlib2FyZC5hZGRCaW5kaW5nKHsga2V5OiAnSycsIHNob3J0S2V5OiB0cnVlIH0sIGZ1bmN0aW9uIChyYW5nZSwgY29udGV4dCkge1xuICAgICAgICAgIHRvb2xiYXIuaGFuZGxlcnNbJ2xpbmsnXS5jYWxsKHRvb2xiYXIsICFjb250ZXh0LmZvcm1hdC5saW5rKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNub3dUaGVtZTtcbn0oX2Jhc2UyLmRlZmF1bHQpO1xuXG5Tbm93VGhlbWUuREVGQVVMVFMgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkodHJ1ZSwge30sIF9iYXNlMi5kZWZhdWx0LkRFRkFVTFRTLCB7XG4gIG1vZHVsZXM6IHtcbiAgICB0b29sYmFyOiB7XG4gICAgICBoYW5kbGVyczoge1xuICAgICAgICBsaW5rOiBmdW5jdGlvbiBsaW5rKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHJhbmdlID09IG51bGwgfHwgcmFuZ2UubGVuZ3RoID09IDApIHJldHVybjtcbiAgICAgICAgICAgIHZhciBwcmV2aWV3ID0gdGhpcy5xdWlsbC5nZXRUZXh0KHJhbmdlKTtcbiAgICAgICAgICAgIGlmICgvXlxcUytAXFxTK1xcLlxcUyskLy50ZXN0KHByZXZpZXcpICYmIHByZXZpZXcuaW5kZXhPZignbWFpbHRvOicpICE9PSAwKSB7XG4gICAgICAgICAgICAgIHByZXZpZXcgPSAnbWFpbHRvOicgKyBwcmV2aWV3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRvb2x0aXAgPSB0aGlzLnF1aWxsLnRoZW1lLnRvb2x0aXA7XG4gICAgICAgICAgICB0b29sdGlwLmVkaXQoJ2xpbmsnLCBwcmV2aWV3KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2xpbmsnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxudmFyIFNub3dUb29sdGlwID0gZnVuY3Rpb24gKF9CYXNlVG9vbHRpcCkge1xuICBfaW5oZXJpdHMoU25vd1Rvb2x0aXAsIF9CYXNlVG9vbHRpcCk7XG5cbiAgZnVuY3Rpb24gU25vd1Rvb2x0aXAocXVpbGwsIGJvdW5kcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbm93VG9vbHRpcCk7XG5cbiAgICB2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNub3dUb29sdGlwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU25vd1Rvb2x0aXApKS5jYWxsKHRoaXMsIHF1aWxsLCBib3VuZHMpKTtcblxuICAgIF90aGlzMi5wcmV2aWV3ID0gX3RoaXMyLnJvb3QucXVlcnlTZWxlY3RvcignYS5xbC1wcmV2aWV3Jyk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTbm93VG9vbHRpcCwgW3tcbiAgICBrZXk6ICdsaXN0ZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW4oKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgX2dldChTbm93VG9vbHRpcC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTbm93VG9vbHRpcC5wcm90b3R5cGUpLCAnbGlzdGVuJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKCdhLnFsLWFjdGlvbicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfdGhpczMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWVkaXRpbmcnKSkge1xuICAgICAgICAgIF90aGlzMy5zYXZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMzLmVkaXQoJ2xpbmsnLCBfdGhpczMucHJldmlldy50ZXh0Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3IoJ2EucWwtcmVtb3ZlJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKF90aGlzMy5saW5rUmFuZ2UgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciByYW5nZSA9IF90aGlzMy5saW5rUmFuZ2U7XG4gICAgICAgICAgX3RoaXMzLnJlc3RvcmVGb2N1cygpO1xuICAgICAgICAgIF90aGlzMy5xdWlsbC5mb3JtYXRUZXh0KHJhbmdlLCAnbGluaycsIGZhbHNlLCBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczMubGlua1JhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIF90aGlzMy5oaWRlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucXVpbGwub24oX2VtaXR0ZXIyLmRlZmF1bHQuZXZlbnRzLlNFTEVDVElPTl9DSEFOR0UsIGZ1bmN0aW9uIChyYW5nZSwgb2xkUmFuZ2UsIHNvdXJjZSkge1xuICAgICAgICBpZiAocmFuZ2UgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAocmFuZ2UubGVuZ3RoID09PSAwICYmIHNvdXJjZSA9PT0gX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSKSB7XG4gICAgICAgICAgdmFyIF9xdWlsbCRzY3JvbGwkZGVzY2VuZCA9IF90aGlzMy5xdWlsbC5zY3JvbGwuZGVzY2VuZGFudChfbGluazIuZGVmYXVsdCwgcmFuZ2UuaW5kZXgpLFxuICAgICAgICAgICAgICBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQyID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJHNjcm9sbCRkZXNjZW5kLCAyKSxcbiAgICAgICAgICAgICAgbGluayA9IF9xdWlsbCRzY3JvbGwkZGVzY2VuZDJbMF0sXG4gICAgICAgICAgICAgIG9mZnNldCA9IF9xdWlsbCRzY3JvbGwkZGVzY2VuZDJbMV07XG5cbiAgICAgICAgICBpZiAobGluayAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpczMubGlua1JhbmdlID0gbmV3IF9zZWxlY3Rpb24uUmFuZ2UocmFuZ2UuaW5kZXggLSBvZmZzZXQsIGxpbmsubGVuZ3RoKCkpO1xuICAgICAgICAgICAgdmFyIHByZXZpZXcgPSBfbGluazIuZGVmYXVsdC5mb3JtYXRzKGxpbmsuZG9tTm9kZSk7XG4gICAgICAgICAgICBfdGhpczMucHJldmlldy50ZXh0Q29udGVudCA9IHByZXZpZXc7XG4gICAgICAgICAgICBfdGhpczMucHJldmlldy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBwcmV2aWV3KTtcbiAgICAgICAgICAgIF90aGlzMy5zaG93KCk7XG4gICAgICAgICAgICBfdGhpczMucG9zaXRpb24oX3RoaXMzLnF1aWxsLmdldEJvdW5kcyhfdGhpczMubGlua1JhbmdlKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczMubGlua1JhbmdlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzMy5oaWRlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzaG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIF9nZXQoU25vd1Rvb2x0aXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU25vd1Rvb2x0aXAucHJvdG90eXBlKSwgJ3Nob3cnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5yb290LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tb2RlJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNub3dUb29sdGlwO1xufShfYmFzZS5CYXNlVG9vbHRpcCk7XG5cblNub3dUb29sdGlwLlRFTVBMQVRFID0gWyc8YSBjbGFzcz1cInFsLXByZXZpZXdcIiByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCIgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cImFib3V0OmJsYW5rXCI+PC9hPicsICc8aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLWZvcm11bGE9XCJlPW1jXjJcIiBkYXRhLWxpbms9XCJodHRwczovL3F1aWxsanMuY29tXCIgZGF0YS12aWRlbz1cIkVtYmVkIFVSTFwiPicsICc8YSBjbGFzcz1cInFsLWFjdGlvblwiPjwvYT4nLCAnPGEgY2xhc3M9XCJxbC1yZW1vdmVcIj48L2E+J10uam9pbignJyk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNub3dUaGVtZTtcblxuLyoqKi8gfSksXG4vKiA2MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxudmFyIF9jb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcmUpO1xuXG52YXIgX2FsaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbnZhciBfZGlyZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cbnZhciBfaW5kZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG5cbnZhciBfYmxvY2txdW90ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xuXG52YXIgX2Jsb2NrcXVvdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2txdW90ZSk7XG5cbnZhciBfaGVhZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG5cbnZhciBfaGVhZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlYWRlcik7XG5cbnZhciBfbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xuXG52YXIgX2xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGlzdCk7XG5cbnZhciBfYmFja2dyb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXG52YXIgX2NvbG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbnZhciBfZm9udCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG52YXIgX3NpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblxudmFyIF9ib2xkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG5cbnZhciBfYm9sZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ib2xkKTtcblxudmFyIF9pdGFsaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxudmFyIF9pdGFsaWMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRhbGljKTtcblxudmFyIF9saW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbnZhciBfbGluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saW5rKTtcblxudmFyIF9zY3JpcHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblxudmFyIF9zY3JpcHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2NyaXB0KTtcblxudmFyIF9zdHJpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxudmFyIF9zdHJpa2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaWtlKTtcblxudmFyIF91bmRlcmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxudmFyIF91bmRlcmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdW5kZXJsaW5lKTtcblxudmFyIF9pbWFnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xuXG52YXIgX2ltYWdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ltYWdlKTtcblxudmFyIF92aWRlbyA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xuXG52YXIgX3ZpZGVvMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvKTtcblxudmFyIF9jb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBfY29kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2RlKTtcblxudmFyIF9mb3JtdWxhID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cbnZhciBfZm9ybXVsYTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb3JtdWxhKTtcblxudmFyIF9zeW50YXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblxudmFyIF9zeW50YXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ludGF4KTtcblxudmFyIF90b29sYmFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XG5cbnZhciBfdG9vbGJhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b29sYmFyKTtcblxudmFyIF9pY29ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuXG52YXIgX2ljb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ljb25zKTtcblxudmFyIF9waWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxudmFyIF9waWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGlja2VyKTtcblxudmFyIF9jb2xvclBpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuXG52YXIgX2NvbG9yUGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbG9yUGlja2VyKTtcblxudmFyIF9pY29uUGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG5cbnZhciBfaWNvblBpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pY29uUGlja2VyKTtcblxudmFyIF90b29sdGlwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XG5cbnZhciBfdG9vbHRpcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b29sdGlwKTtcblxudmFyIF9idWJibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOCk7XG5cbnZhciBfYnViYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1YmJsZSk7XG5cbnZhciBfc25vdyA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xuXG52YXIgX3Nub3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc25vdyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbl9jb3JlMi5kZWZhdWx0LnJlZ2lzdGVyKHtcbiAgJ2F0dHJpYnV0b3JzL2F0dHJpYnV0ZS9kaXJlY3Rpb24nOiBfZGlyZWN0aW9uLkRpcmVjdGlvbkF0dHJpYnV0ZSxcblxuICAnYXR0cmlidXRvcnMvY2xhc3MvYWxpZ24nOiBfYWxpZ24uQWxpZ25DbGFzcyxcbiAgJ2F0dHJpYnV0b3JzL2NsYXNzL2JhY2tncm91bmQnOiBfYmFja2dyb3VuZC5CYWNrZ3JvdW5kQ2xhc3MsXG4gICdhdHRyaWJ1dG9ycy9jbGFzcy9jb2xvcic6IF9jb2xvci5Db2xvckNsYXNzLFxuICAnYXR0cmlidXRvcnMvY2xhc3MvZGlyZWN0aW9uJzogX2RpcmVjdGlvbi5EaXJlY3Rpb25DbGFzcyxcbiAgJ2F0dHJpYnV0b3JzL2NsYXNzL2ZvbnQnOiBfZm9udC5Gb250Q2xhc3MsXG4gICdhdHRyaWJ1dG9ycy9jbGFzcy9zaXplJzogX3NpemUuU2l6ZUNsYXNzLFxuXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS9hbGlnbic6IF9hbGlnbi5BbGlnblN0eWxlLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvYmFja2dyb3VuZCc6IF9iYWNrZ3JvdW5kLkJhY2tncm91bmRTdHlsZSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2NvbG9yJzogX2NvbG9yLkNvbG9yU3R5bGUsXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS9kaXJlY3Rpb24nOiBfZGlyZWN0aW9uLkRpcmVjdGlvblN0eWxlLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvZm9udCc6IF9mb250LkZvbnRTdHlsZSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL3NpemUnOiBfc2l6ZS5TaXplU3R5bGVcbn0sIHRydWUpO1xuXG5fY29yZTIuZGVmYXVsdC5yZWdpc3Rlcih7XG4gICdmb3JtYXRzL2FsaWduJzogX2FsaWduLkFsaWduQ2xhc3MsXG4gICdmb3JtYXRzL2RpcmVjdGlvbic6IF9kaXJlY3Rpb24uRGlyZWN0aW9uQ2xhc3MsXG4gICdmb3JtYXRzL2luZGVudCc6IF9pbmRlbnQuSW5kZW50Q2xhc3MsXG5cbiAgJ2Zvcm1hdHMvYmFja2dyb3VuZCc6IF9iYWNrZ3JvdW5kLkJhY2tncm91bmRTdHlsZSxcbiAgJ2Zvcm1hdHMvY29sb3InOiBfY29sb3IuQ29sb3JTdHlsZSxcbiAgJ2Zvcm1hdHMvZm9udCc6IF9mb250LkZvbnRDbGFzcyxcbiAgJ2Zvcm1hdHMvc2l6ZSc6IF9zaXplLlNpemVDbGFzcyxcblxuICAnZm9ybWF0cy9ibG9ja3F1b3RlJzogX2Jsb2NrcXVvdGUyLmRlZmF1bHQsXG4gICdmb3JtYXRzL2NvZGUtYmxvY2snOiBfY29kZTIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvaGVhZGVyJzogX2hlYWRlcjIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvbGlzdCc6IF9saXN0Mi5kZWZhdWx0LFxuXG4gICdmb3JtYXRzL2JvbGQnOiBfYm9sZDIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvY29kZSc6IF9jb2RlLkNvZGUsXG4gICdmb3JtYXRzL2l0YWxpYyc6IF9pdGFsaWMyLmRlZmF1bHQsXG4gICdmb3JtYXRzL2xpbmsnOiBfbGluazIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvc2NyaXB0JzogX3NjcmlwdDIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvc3RyaWtlJzogX3N0cmlrZTIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvdW5kZXJsaW5lJzogX3VuZGVybGluZTIuZGVmYXVsdCxcblxuICAnZm9ybWF0cy9pbWFnZSc6IF9pbWFnZTIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvdmlkZW8nOiBfdmlkZW8yLmRlZmF1bHQsXG5cbiAgJ2Zvcm1hdHMvbGlzdC9pdGVtJzogX2xpc3QuTGlzdEl0ZW0sXG5cbiAgJ21vZHVsZXMvZm9ybXVsYSc6IF9mb3JtdWxhMi5kZWZhdWx0LFxuICAnbW9kdWxlcy9zeW50YXgnOiBfc3ludGF4Mi5kZWZhdWx0LFxuICAnbW9kdWxlcy90b29sYmFyJzogX3Rvb2xiYXIyLmRlZmF1bHQsXG5cbiAgJ3RoZW1lcy9idWJibGUnOiBfYnViYmxlMi5kZWZhdWx0LFxuICAndGhlbWVzL3Nub3cnOiBfc25vdzIuZGVmYXVsdCxcblxuICAndWkvaWNvbnMnOiBfaWNvbnMyLmRlZmF1bHQsXG4gICd1aS9waWNrZXInOiBfcGlja2VyMi5kZWZhdWx0LFxuICAndWkvaWNvbi1waWNrZXInOiBfaWNvblBpY2tlcjIuZGVmYXVsdCxcbiAgJ3VpL2NvbG9yLXBpY2tlcic6IF9jb2xvclBpY2tlcjIuZGVmYXVsdCxcbiAgJ3VpL3Rvb2x0aXAnOiBfdG9vbHRpcDIuZGVmYXVsdFxufSwgdHJ1ZSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9jb3JlMi5kZWZhdWx0O1xuXG4vKioqLyB9KSxcbi8qIDY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkluZGVudENsYXNzID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSWRlbnRBdHRyaWJ1dG9yID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkQXR0cmlidXRvcikge1xuICBfaW5oZXJpdHMoSWRlbnRBdHRyaWJ1dG9yLCBfUGFyY2htZW50JEF0dHJpYnV0b3IpO1xuXG4gIGZ1bmN0aW9uIElkZW50QXR0cmlidXRvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWRlbnRBdHRyaWJ1dG9yKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSWRlbnRBdHRyaWJ1dG9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWRlbnRBdHRyaWJ1dG9yKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSWRlbnRBdHRyaWJ1dG9yLCBbe1xuICAgIGtleTogJ2FkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAnKzEnIHx8IHZhbHVlID09PSAnLTEnKSB7XG4gICAgICAgIHZhciBpbmRlbnQgPSB0aGlzLnZhbHVlKG5vZGUpIHx8IDA7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICcrMScgPyBpbmRlbnQgKyAxIDogaW5kZW50IC0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLnJlbW92ZShub2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX2dldChJZGVudEF0dHJpYnV0b3IucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWRlbnRBdHRyaWJ1dG9yLnByb3RvdHlwZSksICdhZGQnLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYW5BZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5BZGQobm9kZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBfZ2V0KElkZW50QXR0cmlidXRvci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJZGVudEF0dHJpYnV0b3IucHJvdG90eXBlKSwgJ2NhbkFkZCcsIHRoaXMpLmNhbGwodGhpcywgbm9kZSwgdmFsdWUpIHx8IF9nZXQoSWRlbnRBdHRyaWJ1dG9yLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKElkZW50QXR0cmlidXRvci5wcm90b3R5cGUpLCAnY2FuQWRkJywgdGhpcykuY2FsbCh0aGlzLCBub2RlLCBwYXJzZUludCh2YWx1ZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobm9kZSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KF9nZXQoSWRlbnRBdHRyaWJ1dG9yLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKElkZW50QXR0cmlidXRvci5wcm90b3R5cGUpLCAndmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUpKSB8fCB1bmRlZmluZWQ7IC8vIERvbid0IHJldHVybiBOYU5cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSWRlbnRBdHRyaWJ1dG9yO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQ2xhc3MpO1xuXG52YXIgSW5kZW50Q2xhc3MgPSBuZXcgSWRlbnRBdHRyaWJ1dG9yKCdpbmRlbnQnLCAncWwtaW5kZW50Jywge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSyxcbiAgd2hpdGVsaXN0OiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOF1cbn0pO1xuXG5leHBvcnRzLkluZGVudENsYXNzID0gSW5kZW50Q2xhc3M7XG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfYmxvY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2spO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBCbG9ja3F1b3RlID0gZnVuY3Rpb24gKF9CbG9jaykge1xuICBfaW5oZXJpdHMoQmxvY2txdW90ZSwgX0Jsb2NrKTtcblxuICBmdW5jdGlvbiBCbG9ja3F1b3RlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCbG9ja3F1b3RlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQmxvY2txdW90ZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrcXVvdGUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBCbG9ja3F1b3RlO1xufShfYmxvY2syLmRlZmF1bHQpO1xuXG5CbG9ja3F1b3RlLmJsb3ROYW1lID0gJ2Jsb2NrcXVvdGUnO1xuQmxvY2txdW90ZS50YWdOYW1lID0gJ2Jsb2NrcXVvdGUnO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCbG9ja3F1b3RlO1xuXG4vKioqLyB9KSxcbi8qIDY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSGVhZGVyID0gZnVuY3Rpb24gKF9CbG9jaykge1xuICBfaW5oZXJpdHMoSGVhZGVyLCBfQmxvY2spO1xuXG4gIGZ1bmN0aW9uIEhlYWRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGVhZGVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSGVhZGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSGVhZGVyKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSGVhZGVyLCBudWxsLCBbe1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRhZ05hbWUuaW5kZXhPZihkb21Ob2RlLnRhZ05hbWUpICsgMTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGVhZGVyO1xufShfYmxvY2syLmRlZmF1bHQpO1xuXG5IZWFkZXIuYmxvdE5hbWUgPSAnaGVhZGVyJztcbkhlYWRlci50YWdOYW1lID0gWydIMScsICdIMicsICdIMycsICdINCcsICdINScsICdINiddO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBIZWFkZXI7XG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuTGlzdEl0ZW0gPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX2Jsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9ibG9jazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ibG9jayk7XG5cbnZhciBfY29udGFpbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbnZhciBfY29udGFpbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRhaW5lcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIExpc3RJdGVtID0gZnVuY3Rpb24gKF9CbG9jaykge1xuICBfaW5oZXJpdHMoTGlzdEl0ZW0sIF9CbG9jayk7XG5cbiAgZnVuY3Rpb24gTGlzdEl0ZW0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpc3RJdGVtKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTGlzdEl0ZW0uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0SXRlbSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpc3RJdGVtLCBbe1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKG5hbWUgPT09IExpc3QuYmxvdE5hbWUgJiYgIXZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZVdpdGgoX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUodGhpcy5zdGF0aWNzLnNjb3BlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KExpc3RJdGVtLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3RJdGVtLnByb3RvdHlwZSksICdmb3JtYXQnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBpZiAodGhpcy5wcmV2ID09IG51bGwgJiYgdGhpcy5uZXh0ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KExpc3RJdGVtLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3RJdGVtLnByb3RvdHlwZSksICdyZW1vdmUnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlcGxhY2VXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVdpdGgobmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMucGFyZW50Lmlzb2xhdGUodGhpcy5vZmZzZXQodGhpcy5wYXJlbnQpLCB0aGlzLmxlbmd0aCgpKTtcbiAgICAgIGlmIChuYW1lID09PSB0aGlzLnBhcmVudC5zdGF0aWNzLmJsb3ROYW1lKSB7XG4gICAgICAgIHRoaXMucGFyZW50LnJlcGxhY2VXaXRoKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudC51bndyYXAoKTtcbiAgICAgICAgcmV0dXJuIF9nZXQoTGlzdEl0ZW0ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdEl0ZW0ucHJvdG90eXBlKSwgJ3JlcGxhY2VXaXRoJywgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdmb3JtYXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cyhkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gZG9tTm9kZS50YWdOYW1lID09PSB0aGlzLnRhZ05hbWUgPyB1bmRlZmluZWQgOiBfZ2V0KExpc3RJdGVtLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdEl0ZW0pLCAnZm9ybWF0cycsIHRoaXMpLmNhbGwodGhpcywgZG9tTm9kZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpc3RJdGVtO1xufShfYmxvY2syLmRlZmF1bHQpO1xuXG5MaXN0SXRlbS5ibG90TmFtZSA9ICdsaXN0LWl0ZW0nO1xuTGlzdEl0ZW0udGFnTmFtZSA9ICdMSSc7XG5cbnZhciBMaXN0ID0gZnVuY3Rpb24gKF9Db250YWluZXIpIHtcbiAgX2luaGVyaXRzKExpc3QsIF9Db250YWluZXIpO1xuXG4gIF9jcmVhdGVDbGFzcyhMaXN0LCBudWxsLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIHRhZ05hbWUgPSB2YWx1ZSA9PT0gJ29yZGVyZWQnID8gJ09MJyA6ICdVTCc7XG4gICAgICB2YXIgbm9kZSA9IF9nZXQoTGlzdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3QpLCAnY3JlYXRlJywgdGhpcykuY2FsbCh0aGlzLCB0YWdOYW1lKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJ2NoZWNrZWQnIHx8IHZhbHVlID09PSAndW5jaGVja2VkJykge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1jaGVja2VkJywgdmFsdWUgPT09ICdjaGVja2VkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cyhkb21Ob2RlKSB7XG4gICAgICBpZiAoZG9tTm9kZS50YWdOYW1lID09PSAnT0wnKSByZXR1cm4gJ29yZGVyZWQnO1xuICAgICAgaWYgKGRvbU5vZGUudGFnTmFtZSA9PT0gJ1VMJykge1xuICAgICAgICBpZiAoZG9tTm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtY2hlY2tlZCcpKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWNoZWNrZWQnKSA9PT0gJ3RydWUnID8gJ2NoZWNrZWQnIDogJ3VuY2hlY2tlZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICdidWxsZXQnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIExpc3QoZG9tTm9kZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaXN0KTtcblxuICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTGlzdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3QpKS5jYWxsKHRoaXMsIGRvbU5vZGUpKTtcblxuICAgIHZhciBsaXN0RXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gbGlzdEV2ZW50SGFuZGxlcihlKSB7XG4gICAgICBpZiAoZS50YXJnZXQucGFyZW50Tm9kZSAhPT0gZG9tTm9kZSkgcmV0dXJuO1xuICAgICAgdmFyIGZvcm1hdCA9IF90aGlzMi5zdGF0aWNzLmZvcm1hdHMoZG9tTm9kZSk7XG4gICAgICB2YXIgYmxvdCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuZmluZChlLnRhcmdldCk7XG4gICAgICBpZiAoZm9ybWF0ID09PSAnY2hlY2tlZCcpIHtcbiAgICAgICAgYmxvdC5mb3JtYXQoJ2xpc3QnLCAndW5jaGVja2VkJyk7XG4gICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ3VuY2hlY2tlZCcpIHtcbiAgICAgICAgYmxvdC5mb3JtYXQoJ2xpc3QnLCAnY2hlY2tlZCcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBkb21Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBsaXN0RXZlbnRIYW5kbGVyKTtcbiAgICBkb21Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGxpc3RFdmVudEhhbmRsZXIpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGlzdCwgW3tcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi50YWlsLmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoKSB7XG4gICAgICAvLyBXZSBkb24ndCBpbmhlcml0IGZyb20gRm9ybWF0QmxvdFxuICAgICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgdGhpcy5zdGF0aWNzLmJsb3ROYW1lLCB0aGlzLnN0YXRpY3MuZm9ybWF0cyh0aGlzLmRvbU5vZGUpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRCZWZvcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoYmxvdCwgcmVmKSB7XG4gICAgICBpZiAoYmxvdCBpbnN0YW5jZW9mIExpc3RJdGVtKSB7XG4gICAgICAgIF9nZXQoTGlzdC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0LnByb3RvdHlwZSksICdpbnNlcnRCZWZvcmUnLCB0aGlzKS5jYWxsKHRoaXMsIGJsb3QsIHJlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW5kZXggPSByZWYgPT0gbnVsbCA/IHRoaXMubGVuZ3RoKCkgOiByZWYub2Zmc2V0KHRoaXMpO1xuICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLnNwbGl0KGluZGV4KTtcbiAgICAgICAgYWZ0ZXIucGFyZW50Lmluc2VydEJlZm9yZShibG90LCBhZnRlcik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb3B0aW1pemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZShjb250ZXh0KSB7XG4gICAgICBfZ2V0KExpc3QucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdC5wcm90b3R5cGUpLCAnb3B0aW1pemUnLCB0aGlzKS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgdmFyIG5leHQgPSB0aGlzLm5leHQ7XG4gICAgICBpZiAobmV4dCAhPSBudWxsICYmIG5leHQucHJldiA9PT0gdGhpcyAmJiBuZXh0LnN0YXRpY3MuYmxvdE5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSAmJiBuZXh0LmRvbU5vZGUudGFnTmFtZSA9PT0gdGhpcy5kb21Ob2RlLnRhZ05hbWUgJiYgbmV4dC5kb21Ob2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1jaGVja2VkJykgPT09IHRoaXMuZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2hlY2tlZCcpKSB7XG4gICAgICAgIG5leHQubW92ZUNoaWxkcmVuKHRoaXMpO1xuICAgICAgICBuZXh0LnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlcGxhY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKHRhcmdldCkge1xuICAgICAgaWYgKHRhcmdldC5zdGF0aWNzLmJsb3ROYW1lICE9PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh0aGlzLnN0YXRpY3MuZGVmYXVsdENoaWxkKTtcbiAgICAgICAgdGFyZ2V0Lm1vdmVDaGlsZHJlbihpdGVtKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgIH1cbiAgICAgIF9nZXQoTGlzdC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0LnByb3RvdHlwZSksICdyZXBsYWNlJywgdGhpcykuY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaXN0O1xufShfY29udGFpbmVyMi5kZWZhdWx0KTtcblxuTGlzdC5ibG90TmFtZSA9ICdsaXN0Jztcbkxpc3Quc2NvcGUgPSBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLX0JMT1Q7XG5MaXN0LnRhZ05hbWUgPSBbJ09MJywgJ1VMJ107XG5MaXN0LmRlZmF1bHRDaGlsZCA9ICdsaXN0LWl0ZW0nO1xuTGlzdC5hbGxvd2VkQ2hpbGRyZW4gPSBbTGlzdEl0ZW1dO1xuXG5leHBvcnRzLkxpc3RJdGVtID0gTGlzdEl0ZW07XG5leHBvcnRzLmRlZmF1bHQgPSBMaXN0O1xuXG4vKioqLyB9KSxcbi8qIDY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfYm9sZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xuXG52YXIgX2JvbGQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYm9sZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEl0YWxpYyA9IGZ1bmN0aW9uIChfQm9sZCkge1xuICBfaW5oZXJpdHMoSXRhbGljLCBfQm9sZCk7XG5cbiAgZnVuY3Rpb24gSXRhbGljKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJdGFsaWMpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJdGFsaWMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJdGFsaWMpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBJdGFsaWM7XG59KF9ib2xkMi5kZWZhdWx0KTtcblxuSXRhbGljLmJsb3ROYW1lID0gJ2l0YWxpYyc7XG5JdGFsaWMudGFnTmFtZSA9IFsnRU0nLCAnSSddO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJdGFsaWM7XG5cbi8qKiovIH0pLFxuLyogNjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFNjcmlwdCA9IGZ1bmN0aW9uIChfSW5saW5lKSB7XG4gIF9pbmhlcml0cyhTY3JpcHQsIF9JbmxpbmUpO1xuXG4gIGZ1bmN0aW9uIFNjcmlwdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NyaXB0KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2NyaXB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2NyaXB0KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2NyaXB0LCBudWxsLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAnc3VwZXInKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdXAnKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICdzdWInKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdWInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfZ2V0KFNjcmlwdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcmlwdCksICdjcmVhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cyhkb21Ob2RlKSB7XG4gICAgICBpZiAoZG9tTm9kZS50YWdOYW1lID09PSAnU1VCJykgcmV0dXJuICdzdWInO1xuICAgICAgaWYgKGRvbU5vZGUudGFnTmFtZSA9PT0gJ1NVUCcpIHJldHVybiAnc3VwZXInO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2NyaXB0O1xufShfaW5saW5lMi5kZWZhdWx0KTtcblxuU2NyaXB0LmJsb3ROYW1lID0gJ3NjcmlwdCc7XG5TY3JpcHQudGFnTmFtZSA9IFsnU1VCJywgJ1NVUCddO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTY3JpcHQ7XG5cbi8qKiovIH0pLFxuLyogNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9pbmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX2lubGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmxpbmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBTdHJpa2UgPSBmdW5jdGlvbiAoX0lubGluZSkge1xuICBfaW5oZXJpdHMoU3RyaWtlLCBfSW5saW5lKTtcblxuICBmdW5jdGlvbiBTdHJpa2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmlrZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFN0cmlrZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0cmlrZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIFN0cmlrZTtcbn0oX2lubGluZTIuZGVmYXVsdCk7XG5cblN0cmlrZS5ibG90TmFtZSA9ICdzdHJpa2UnO1xuU3RyaWtlLnRhZ05hbWUgPSAnUyc7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN0cmlrZTtcblxuLyoqKi8gfSksXG4vKiA3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFVuZGVybGluZSA9IGZ1bmN0aW9uIChfSW5saW5lKSB7XG4gIF9pbmhlcml0cyhVbmRlcmxpbmUsIF9JbmxpbmUpO1xuXG4gIGZ1bmN0aW9uIFVuZGVybGluZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVW5kZXJsaW5lKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVW5kZXJsaW5lLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVW5kZXJsaW5lKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gVW5kZXJsaW5lO1xufShfaW5saW5lMi5kZWZhdWx0KTtcblxuVW5kZXJsaW5lLmJsb3ROYW1lID0gJ3VuZGVybGluZSc7XG5VbmRlcmxpbmUudGFnTmFtZSA9ICdVJztcblxuZXhwb3J0cy5kZWZhdWx0ID0gVW5kZXJsaW5lO1xuXG4vKioqLyB9KSxcbi8qIDcyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX2xpbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQVRUUklCVVRFUyA9IFsnYWx0JywgJ2hlaWdodCcsICd3aWR0aCddO1xuXG52YXIgSW1hZ2UgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRFbWJlZCkge1xuICBfaW5oZXJpdHMoSW1hZ2UsIF9QYXJjaG1lbnQkRW1iZWQpO1xuXG4gIGZ1bmN0aW9uIEltYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEltYWdlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSW1hZ2UpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbWFnZSwgW3tcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChBVFRSSUJVVEVTLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmRvbU5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRvbU5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KEltYWdlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEltYWdlLnByb3RvdHlwZSksICdmb3JtYXQnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIG5vZGUgPSBfZ2V0KEltYWdlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSW1hZ2UpLCAnY3JlYXRlJywgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3JjJywgdGhpcy5zYW5pdGl6ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIEFUVFJJQlVURVMucmVkdWNlKGZ1bmN0aW9uIChmb3JtYXRzLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICBmb3JtYXRzW2F0dHJpYnV0ZV0gPSBkb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21hdGNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2godXJsKSB7XG4gICAgICByZXR1cm4gKC9cXC4oanBlP2d8Z2lmfHBuZykkLy50ZXN0KHVybCkgfHwgL15kYXRhOmltYWdlXFwvLis7YmFzZTY0Ly50ZXN0KHVybClcbiAgICAgICk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2FuaXRpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYW5pdGl6ZSh1cmwpIHtcbiAgICAgIHJldHVybiAoMCwgX2xpbmsuc2FuaXRpemUpKHVybCwgWydodHRwJywgJ2h0dHBzJywgJ2RhdGEnXSkgPyB1cmwgOiAnLy86MCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbWFnZTtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCk7XG5cbkltYWdlLmJsb3ROYW1lID0gJ2ltYWdlJztcbkltYWdlLnRhZ05hbWUgPSAnSU1HJztcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW1hZ2U7XG5cbi8qKiovIH0pLFxuLyogNzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2Jsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9saW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbnZhciBfbGluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saW5rKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQVRUUklCVVRFUyA9IFsnaGVpZ2h0JywgJ3dpZHRoJ107XG5cbnZhciBWaWRlbyA9IGZ1bmN0aW9uIChfQmxvY2tFbWJlZCkge1xuICBfaW5oZXJpdHMoVmlkZW8sIF9CbG9ja0VtYmVkKTtcblxuICBmdW5jdGlvbiBWaWRlbygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW8pO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChWaWRlby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFZpZGVvKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVmlkZW8sIFt7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5kb21Ob2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChWaWRlby5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihWaWRlby5wcm90b3R5cGUpLCAnZm9ybWF0JywgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIHZhciBub2RlID0gX2dldChWaWRlby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFZpZGVvKSwgJ2NyZWF0ZScsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2ZyYW1lYm9yZGVyJywgJzAnKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdhbGxvd2Z1bGxzY3JlZW4nLCB0cnVlKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzcmMnLCB0aGlzLnNhbml0aXplKHZhbHVlKSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cyhkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gQVRUUklCVVRFUy5yZWR1Y2UoZnVuY3Rpb24gKGZvcm1hdHMsIGF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoZG9tTm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xuICAgICAgICAgIGZvcm1hdHNbYXR0cmlidXRlXSA9IGRvbU5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2FuaXRpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYW5pdGl6ZSh1cmwpIHtcbiAgICAgIHJldHVybiBfbGluazIuZGVmYXVsdC5zYW5pdGl6ZSh1cmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmlkZW87XG59KF9ibG9jay5CbG9ja0VtYmVkKTtcblxuVmlkZW8uYmxvdE5hbWUgPSAndmlkZW8nO1xuVmlkZW8uY2xhc3NOYW1lID0gJ3FsLXZpZGVvJztcblZpZGVvLnRhZ05hbWUgPSAnSUZSQU1FJztcblxuZXhwb3J0cy5kZWZhdWx0ID0gVmlkZW87XG5cbi8qKiovIH0pLFxuLyogNzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuRm9ybXVsYUJsb3QgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9lbWJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXG52YXIgX2VtYmVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VtYmVkKTtcblxudmFyIF9xdWlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfcXVpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGwpO1xuXG52YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEZvcm11bGFCbG90ID0gZnVuY3Rpb24gKF9FbWJlZCkge1xuICBfaW5oZXJpdHMoRm9ybXVsYUJsb3QsIF9FbWJlZCk7XG5cbiAgZnVuY3Rpb24gRm9ybXVsYUJsb3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm11bGFCbG90KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRm9ybXVsYUJsb3QuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JtdWxhQmxvdCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZvcm11bGFCbG90LCBudWxsLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIG5vZGUgPSBfZ2V0KEZvcm11bGFCbG90Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9ybXVsYUJsb3QpLCAnY3JlYXRlJywgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB3aW5kb3cua2F0ZXgucmVuZGVyKHZhbHVlLCBub2RlLCB7XG4gICAgICAgICAgdGhyb3dPbkVycm9yOiBmYWxzZSxcbiAgICAgICAgICBlcnJvckNvbG9yOiAnI2YwMCdcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJywgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9ybXVsYUJsb3Q7XG59KF9lbWJlZDIuZGVmYXVsdCk7XG5cbkZvcm11bGFCbG90LmJsb3ROYW1lID0gJ2Zvcm11bGEnO1xuRm9ybXVsYUJsb3QuY2xhc3NOYW1lID0gJ3FsLWZvcm11bGEnO1xuRm9ybXVsYUJsb3QudGFnTmFtZSA9ICdTUEFOJztcblxudmFyIEZvcm11bGEgPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuICBfaW5oZXJpdHMoRm9ybXVsYSwgX01vZHVsZSk7XG5cbiAgX2NyZWF0ZUNsYXNzKEZvcm11bGEsIG51bGwsIFt7XG4gICAga2V5OiAncmVnaXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICAgIF9xdWlsbDIuZGVmYXVsdC5yZWdpc3RlcihGb3JtdWxhQmxvdCwgdHJ1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gRm9ybXVsYSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9ybXVsYSk7XG5cbiAgICB2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZvcm11bGEuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JtdWxhKSkuY2FsbCh0aGlzKSk7XG5cbiAgICBpZiAod2luZG93LmthdGV4ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybXVsYSBtb2R1bGUgcmVxdWlyZXMgS2FUZVguJyk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICByZXR1cm4gRm9ybXVsYTtcbn0oX21vZHVsZTIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuRm9ybXVsYUJsb3QgPSBGb3JtdWxhQmxvdDtcbmV4cG9ydHMuZGVmYXVsdCA9IEZvcm11bGE7XG5cbi8qKiovIH0pLFxuLyogNzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuQ29kZVRva2VuID0gZXhwb3J0cy5Db2RlQmxvY2sgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX3F1aWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9xdWlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbCk7XG5cbnZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxudmFyIF9jb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBfY29kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2RlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU3ludGF4Q29kZUJsb2NrID0gZnVuY3Rpb24gKF9Db2RlQmxvY2spIHtcbiAgX2luaGVyaXRzKFN5bnRheENvZGVCbG9jaywgX0NvZGVCbG9jayk7XG5cbiAgZnVuY3Rpb24gU3ludGF4Q29kZUJsb2NrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTeW50YXhDb2RlQmxvY2spO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTeW50YXhDb2RlQmxvY2suX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTeW50YXhDb2RlQmxvY2spKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTeW50YXhDb2RlQmxvY2ssIFt7XG4gICAga2V5OiAncmVwbGFjZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlV2l0aChibG9jaykge1xuICAgICAgdGhpcy5kb21Ob2RlLnRleHRDb250ZW50ID0gdGhpcy5kb21Ob2RlLnRleHRDb250ZW50O1xuICAgICAgdGhpcy5hdHRhY2goKTtcbiAgICAgIF9nZXQoU3ludGF4Q29kZUJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN5bnRheENvZGVCbG9jay5wcm90b3R5cGUpLCAncmVwbGFjZVdpdGgnLCB0aGlzKS5jYWxsKHRoaXMsIGJsb2NrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoaWdobGlnaHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWdobGlnaHQoX2hpZ2hsaWdodCkge1xuICAgICAgdmFyIHRleHQgPSB0aGlzLmRvbU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICBpZiAodGhpcy5jYWNoZWRUZXh0ICE9PSB0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0LnRyaW0oKS5sZW5ndGggPiAwIHx8IHRoaXMuY2FjaGVkVGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5kb21Ob2RlLmlubmVySFRNTCA9IF9oaWdobGlnaHQodGV4dCk7XG4gICAgICAgICAgdGhpcy5kb21Ob2RlLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgIHRoaXMuYXR0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZWRUZXh0ID0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3ludGF4Q29kZUJsb2NrO1xufShfY29kZTIuZGVmYXVsdCk7XG5cblN5bnRheENvZGVCbG9jay5jbGFzc05hbWUgPSAncWwtc3ludGF4JztcblxudmFyIENvZGVUb2tlbiA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQ2xhc3MoJ3Rva2VuJywgJ2hsanMnLCB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORVxufSk7XG5cbnZhciBTeW50YXggPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuICBfaW5oZXJpdHMoU3ludGF4LCBfTW9kdWxlKTtcblxuICBfY3JlYXRlQ2xhc3MoU3ludGF4LCBudWxsLCBbe1xuICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgICBfcXVpbGwyLmRlZmF1bHQucmVnaXN0ZXIoQ29kZVRva2VuLCB0cnVlKTtcbiAgICAgIF9xdWlsbDIuZGVmYXVsdC5yZWdpc3RlcihTeW50YXhDb2RlQmxvY2ssIHRydWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFN5bnRheChxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTeW50YXgpO1xuXG4gICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTeW50YXguX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTeW50YXgpKS5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKSk7XG5cbiAgICBpZiAodHlwZW9mIF90aGlzMi5vcHRpb25zLmhpZ2hsaWdodCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTeW50YXggbW9kdWxlIHJlcXVpcmVzIGhpZ2hsaWdodC5qcy4gUGxlYXNlIGluY2x1ZGUgdGhlIGxpYnJhcnkgb24gdGhlIHBhZ2UgYmVmb3JlIFF1aWxsLicpO1xuICAgIH1cbiAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgIF90aGlzMi5xdWlsbC5vbihfcXVpbGwyLmRlZmF1bHQuZXZlbnRzLlNDUk9MTF9PUFRJTUlaRSwgZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5oaWdobGlnaHQoKTtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgfSwgX3RoaXMyLm9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgIH0pO1xuICAgIF90aGlzMi5oaWdobGlnaHQoKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN5bnRheCwgW3tcbiAgICBrZXk6ICdoaWdobGlnaHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWdobGlnaHQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucXVpbGwuc2VsZWN0aW9uLmNvbXBvc2luZykgcmV0dXJuO1xuICAgICAgdGhpcy5xdWlsbC51cGRhdGUoX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuICAgICAgdGhpcy5xdWlsbC5zY3JvbGwuZGVzY2VuZGFudHMoU3ludGF4Q29kZUJsb2NrKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIGNvZGUuaGlnaGxpZ2h0KF90aGlzMy5vcHRpb25zLmhpZ2hsaWdodCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucXVpbGwudXBkYXRlKF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICBpZiAocmFuZ2UgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3ludGF4O1xufShfbW9kdWxlMi5kZWZhdWx0KTtcblxuU3ludGF4LkRFRkFVTFRTID0ge1xuICBoaWdobGlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod2luZG93LmhsanMgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gd2luZG93LmhsanMuaGlnaGxpZ2h0QXV0byh0ZXh0KTtcbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfTtcbiAgfSgpLFxuICBpbnRlcnZhbDogMTAwMFxufTtcblxuZXhwb3J0cy5Db2RlQmxvY2sgPSBTeW50YXhDb2RlQmxvY2s7XG5leHBvcnRzLkNvZGVUb2tlbiA9IENvZGVUb2tlbjtcbmV4cG9ydHMuZGVmYXVsdCA9IFN5bnRheDtcblxuLyoqKi8gfSksXG4vKiA3NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0xNSB5MT05IHkyPTk+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0xMyB5MT0xNCB5Mj0xND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTkgeTE9NCB5Mj00PjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogNzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE1IHgyPTMgeTE9OSB5Mj05PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE0IHgyPTQgeTE9MTQgeTI9MTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTIgeDI9NiB5MT00IHkyPTQ+PC9saW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA3OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTUgeDI9MyB5MT05IHkyPTk+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTUgeDI9NSB5MT0xNCB5Mj0xND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xNSB4Mj05IHkxPTQgeTI9ND48L2xpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDc5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xNSB4Mj0zIHkxPTkgeTI9OT48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xNSB4Mj0zIHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE1IHgyPTMgeTE9NCB5Mj00PjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGcgY2xhc3M9XFxcInFsLWZpbGwgcWwtY29sb3ItbGFiZWxcXFwiPiA8cG9seWdvbiBwb2ludHM9XFxcIjYgNi44NjggNiA2IDUgNiA1IDcgNS45NDIgNyA2IDYuODY4XFxcIj48L3BvbHlnb24+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD00IHk9ND48L3JlY3Q+IDxwb2x5Z29uIHBvaW50cz1cXFwiNi44MTcgNSA2IDUgNiA2IDYuMzggNiA2LjgxNyA1XFxcIj48L3BvbHlnb24+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0yIHk9Nj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0zIHk9NT48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD00IHk9Nz48L3JlY3Q+IDxwb2x5Z29uIHBvaW50cz1cXFwiNCAxMS40MzkgNCAxMSAzIDExIDMgMTIgMy43NTUgMTIgNCAxMS40MzlcXFwiPjwvcG9seWdvbj4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTIgeT0xMj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0yIHk9OT48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0yIHk9MTU+PC9yZWN0PiA8cG9seWdvbiBwb2ludHM9XFxcIjQuNjMgMTAgNCAxMCA0IDExIDQuMTkyIDExIDQuNjMgMTBcXFwiPjwvcG9seWdvbj4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTMgeT04PjwvcmVjdD4gPHBhdGggZD1NMTAuODMyLDQuMkwxMSw0LjU4MlY0SDEwLjcwOEExLjk0OCwxLjk0OCwwLDAsMSwxMC44MzIsNC4yWj48L3BhdGg+IDxwYXRoIGQ9TTcsNC41ODJMNy4xNjgsNC4yQTEuOTI5LDEuOTI5LDAsMCwxLDcuMjkyLDRIN1Y0LjU4Mlo+PC9wYXRoPiA8cGF0aCBkPU04LDEzSDcuNjgzbC0wLjM1MS44YTEuOTMzLDEuOTMzLDAsMCwxLS4xMjQuMkg4VjEzWj48L3BhdGg+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xMiB5PTI+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTEgeT0zPjwvcmVjdD4gPHBhdGggZD1NOSwzSDhWMy4yODJBMS45ODUsMS45ODUsMCwwLDEsOSwzWj48L3BhdGg+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0yIHk9Mz48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD02IHk9Mj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0zIHk9Mj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD01IHk9Mz48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD05IHk9Mj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xNSB5PTE0PjwvcmVjdD4gPHBvbHlnb24gcG9pbnRzPVxcXCIxMy40NDcgMTAuMTc0IDEzLjQ2OSAxMC4yMjUgMTMuNDcyIDEwLjIzMiAxMy44MDggMTEgMTQgMTEgMTQgMTAgMTMuMzcgMTAgMTMuNDQ3IDEwLjE3NFxcXCI+PC9wb2x5Z29uPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTMgeT03PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE1IHk9NT48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xNCB5PTY+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTUgeT04PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE0IHk9OT48L3JlY3Q+IDxwYXRoIGQ9TTMuNzc1LDE0SDN2MUg0VjE0LjMxNEExLjk3LDEuOTcsMCwwLDEsMy43NzUsMTRaPjwvcGF0aD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE0IHk9Mz48L3JlY3Q+IDxwb2x5Z29uIHBvaW50cz1cXFwiMTIgNi44NjggMTIgNiAxMS42MiA2IDEyIDYuODY4XFxcIj48L3BvbHlnb24+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xNSB5PTI+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTIgeT01PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTEzIHk9ND48L3JlY3Q+IDxwb2x5Z29uIHBvaW50cz1cXFwiMTIuOTMzIDkgMTMgOSAxMyA4IDEyLjQ5NSA4IDEyLjkzMyA5XFxcIj48L3BvbHlnb24+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD05IHk9MTQ+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9OCB5PTE1PjwvcmVjdD4gPHBhdGggZD1NNiwxNC45MjZWMTVIN1YxNC4zMTZBMS45OTMsMS45OTMsMCwwLDEsNiwxNC45MjZaPjwvcGF0aD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTUgeT0xNT48L3JlY3Q+IDxwYXRoIGQ9TTEwLjY2OCwxMy44TDEwLjMxNywxM0gxMHYxaDAuNzkyQTEuOTQ3LDEuOTQ3LDAsMCwxLDEwLjY2OCwxMy44Wj48L3BhdGg+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xMSB5PTE1PjwvcmVjdD4gPHBhdGggZD1NMTQuMzMyLDEyLjJhMS45OSwxLjk5LDAsMCwxLC4xNjYuOEgxNVYxMkgxNC4yNDVaPjwvcGF0aD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE0IHk9MTU+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTUgeT0xMT48L3JlY3Q+IDwvZz4gPHBvbHlsaW5lIGNsYXNzPXFsLXN0cm9rZSBwb2ludHM9XFxcIjUuNSAxMyA5IDUgMTIuNSAxM1xcXCI+PC9wb2x5bGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTExLjYzIHgyPTYuMzggeTE9MTEgeTI9MTE+PC9saW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cmVjdCBjbGFzcz1cXFwicWwtZmlsbCBxbC1zdHJva2VcXFwiIGhlaWdodD0zIHdpZHRoPTMgeD00IHk9NT48L3JlY3Q+IDxyZWN0IGNsYXNzPVxcXCJxbC1maWxsIHFsLXN0cm9rZVxcXCIgaGVpZ2h0PTMgd2lkdGg9MyB4PTExIHk9NT48L3JlY3Q+IDxwYXRoIGNsYXNzPVxcXCJxbC1ldmVuIHFsLWZpbGwgcWwtc3Ryb2tlXFxcIiBkPU03LDhjMCw0LjAzMS0zLDUtMyw1PjwvcGF0aD4gPHBhdGggY2xhc3M9XFxcInFsLWV2ZW4gcWwtZmlsbCBxbC1zdHJva2VcXFwiIGQ9TTE0LDhjMCw0LjAzMS0zLDUtMyw1PjwvcGF0aD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtc3Ryb2tlIGQ9TTUsNEg5LjVBMi41LDIuNSwwLDAsMSwxMiw2LjV2MEEyLjUsMi41LDAsMCwxLDkuNSw5SDVBMCwwLDAsMCwxLDUsOVY0QTAsMCwwLDAsMSw1LDRaPjwvcGF0aD4gPHBhdGggY2xhc3M9cWwtc3Ryb2tlIGQ9TTUsOWg1LjVBMi41LDIuNSwwLDAsMSwxMywxMS41djBBMi41LDIuNSwwLDAsMSwxMC41LDE0SDVhMCwwLDAsMCwxLDAsMFY5QTAsMCwwLDAsMSw1LDlaPjwvcGF0aD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgY2xhc3M9XFxcIlxcXCIgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTUgeDI9MTMgeTE9MyB5Mj0zPjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTYgeDI9OS4zNSB5MT0xMiB5Mj0zPjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTExIHgyPTE1IHkxPTExIHkyPTE1PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE1IHgyPTExIHkxPTExIHkyPTE1PjwvbGluZT4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSByeD0wLjUgcnk9MC41IHdpZHRoPTcgeD0yIHk9MTQ+PC9yZWN0PiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1cXFwicWwtY29sb3ItbGFiZWwgcWwtc3Ryb2tlIHFsLXRyYW5zcGFyZW50XFxcIiB4MT0zIHgyPTE1IHkxPTE1IHkyPTE1PjwvbGluZT4gPHBvbHlsaW5lIGNsYXNzPXFsLXN0cm9rZSBwb2ludHM9XFxcIjUuNSAxMSA5IDMgMTIuNSAxMVxcXCI+PC9wb2x5bGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTExLjYzIHgyPTYuMzggeTE9OSB5Mj05PjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBvbHlnb24gY2xhc3M9XFxcInFsLXN0cm9rZSBxbC1maWxsXFxcIiBwb2ludHM9XFxcIjMgMTEgNSA5IDMgNyAzIDExXFxcIj48L3BvbHlnb24+IDxsaW5lIGNsYXNzPVxcXCJxbC1zdHJva2UgcWwtZmlsbFxcXCIgeDE9MTUgeDI9MTEgeTE9NCB5Mj00PjwvbGluZT4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xMSwzYTMsMywwLDAsMCwwLDZoMVYzSDExWj48L3BhdGg+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTExIHdpZHRoPTEgeD0xMSB5PTQ+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xMSB3aWR0aD0xIHg9MTMgeT00PjwvcmVjdD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBvbHlnb24gY2xhc3M9XFxcInFsLXN0cm9rZSBxbC1maWxsXFxcIiBwb2ludHM9XFxcIjE1IDEyIDEzIDEwIDE1IDggMTUgMTJcXFwiPjwvcG9seWdvbj4gPGxpbmUgY2xhc3M9XFxcInFsLXN0cm9rZSBxbC1maWxsXFxcIiB4MT05IHgyPTUgeTE9NCB5Mj00PjwvbGluZT4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU01LDNBMywzLDAsMCwwLDUsOUg2VjNINVo+PC9wYXRoPiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xMSB3aWR0aD0xIHg9NSB5PTQ+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xMSB3aWR0aD0xIHg9NyB5PTQ+PC9yZWN0PiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTE0LDE2SDRhMSwxLDAsMCwxLDAtMkgxNEExLDEsMCwwLDEsMTQsMTZaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTQsNEg0QTEsMSwwLDAsMSw0LDJIMTRBMSwxLDAsMCwxLDE0LDRaIC8+IDxyZWN0IGNsYXNzPXFsLWZpbGwgeD0zIHk9NiB3aWR0aD0xMiBoZWlnaHQ9NiByeD0xIHJ5PTEgLz4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xMywxNkg1YTEsMSwwLDAsMSwwLTJoOEExLDEsMCwwLDEsMTMsMTZaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTMsNEg1QTEsMSwwLDAsMSw1LDJoOEExLDEsMCwwLDEsMTMsNFogLz4gPHJlY3QgY2xhc3M9cWwtZmlsbCB4PTIgeT02IHdpZHRoPTE0IGhlaWdodD02IHJ4PTEgcnk9MSAvPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTE1LDhIMTNhMSwxLDAsMCwxLDAtMmgyQTEsMSwwLDAsMSwxNSw4WiAvPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTE1LDEySDEzYTEsMSwwLDAsMSwwLTJoMkExLDEsMCwwLDEsMTUsMTJaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTUsMTZINWExLDEsMCwwLDEsMC0ySDE1QTEsMSwwLDAsMSwxNSwxNlogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xNSw0SDVBMSwxLDAsMCwxLDUsMkgxNUExLDEsMCwwLDEsMTUsNFogLz4gPHJlY3QgY2xhc3M9cWwtZmlsbCB4PTIgeT02IHdpZHRoPTggaGVpZ2h0PTYgcng9MSByeT0xIC8+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NNSw4SDNBMSwxLDAsMCwxLDMsNkg1QTEsMSwwLDAsMSw1LDhaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NNSwxMkgzYTEsMSwwLDAsMSwwLTJINUExLDEsMCwwLDEsNSwxMlogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xMywxNkgzYTEsMSwwLDAsMSwwLTJIMTNBMSwxLDAsMCwxLDEzLDE2WiAvPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTEzLDRIM0ExLDEsMCwwLDEsMywySDEzQTEsMSwwLDAsMSwxMyw0WiAvPiA8cmVjdCBjbGFzcz1xbC1maWxsIHg9OCB5PTYgd2lkdGg9OCBoZWlnaHQ9NiByeD0xIHJ5PTEgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMjQgMTgpIHJvdGF0ZSgtMTgwKVxcXCIvPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTExLjc1OSwyLjQ4MmEyLjU2MSwyLjU2MSwwLDAsMC0zLjUzLjYwN0E3LjY1Niw3LjY1NiwwLDAsMCw2LjgsNi4yQzYuMTA5LDkuMTg4LDUuMjc1LDE0LjY3Nyw0LjE1LDE0LjkyN2ExLjU0NSwxLjU0NSwwLDAsMC0xLjMtLjkzM0EwLjkyMiwwLjkyMiwwLDAsMCwyLDE1LjAzNlMxLjk1NCwxNiw0LjExOSwxNnMzLjA5MS0yLjY5MSwzLjctNS41NTNjMC4xNzctLjgyNi4zNi0xLjcyNiwwLjU1NC0yLjZMOC43NzUsNi4yYzAuMzgxLTEuNDIxLjgwNy0yLjUyMSwxLjMwNi0yLjY3NmExLjAxNCwxLjAxNCwwLDAsMCwxLjAyLjU2QTAuOTY2LDAuOTY2LDAsMCwwLDExLjc1OSwyLjQ4Mlo+PC9wYXRoPiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xLjYgcng9MC44IHJ5PTAuOCB3aWR0aD01IHg9NS4xNSB5PTYuMj48L3JlY3Q+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTMuNjYzLDEyLjAyN2ExLjY2MiwxLjY2MiwwLDAsMSwuMjY2LTAuMjc2cTAuMTkzLDAuMDY5LjQ1NiwwLjEzOGEyLjEsMi4xLDAsMCwwLC41MzUuMDY5LDEuMDc1LDEuMDc1LDAsMCwwLC43NjctMC4zLDEuMDQ0LDEuMDQ0LDAsMCwwLC4zMTQtMC44LDAuODQsMC44NCwwLDAsMC0uMjM4LTAuNjE5LDAuOCwwLjgsMCwwLDAtLjU5NC0wLjIzOSwxLjE1NCwxLjE1NCwwLDAsMC0uNzgxLjMsNC42MDcsNC42MDcsMCwwLDAtLjc4MSwxcS0wLjA5MS4xNS0uMjE4LDAuMzQ2bC0wLjI0Ni4zOGMtMC4wNjgtLjI4OC0wLjEzNy0wLjU4Mi0wLjIxMi0wLjg4NS0wLjQ1OS0xLjg0Ny0yLjQ5NC0uOTg0LTIuOTQxLTAuOC0wLjQ4Mi4yLS4zNTMsMC42NDctMC4wOTQsMC41MjlhMC44NjksMC44NjksMCwwLDEsMS4yODEuNTg1YzAuMjE3LDAuNzUxLjM3NywxLjQzNiwwLjUyNywyLjAzOGE1LjY4OCw1LjY4OCwwLDAsMS0uMzYyLjQ2NywyLjY5LDIuNjksMCwwLDEtLjI2NC4yNzFxLTAuMjIxLS4wOC0wLjQ3MS0wLjE0N2EyLjAyOSwyLjAyOSwwLDAsMC0uNTIyLTAuMDY2LDEuMDc5LDEuMDc5LDAsMCwwLS43NjguM0ExLjA1OCwxLjA1OCwwLDAsMCw5LDE1LjEzMWEwLjgyLDAuODIsMCwwLDAsLjgzMi44NTIsMS4xMzQsMS4xMzQsMCwwLDAsLjc4Ny0wLjMsNS4xMSw1LjExLDAsMCwwLC43NzYtMC45OTNxMC4xNDEtLjIxOS4yMTUtMC4zNGMwLjA0Ni0uMDc2LjEyMi0wLjE5NCwwLjIyMy0wLjM0NmEyLjc4NiwyLjc4NiwwLDAsMCwuOTE4LDEuNzI2LDIuNTgyLDIuNTgyLDAsMCwwLDIuMzc2LS4xODVjMC4zMTctLjE4MS4yMTItMC41NjUsMC0wLjQ5NEEwLjgwNywwLjgwNywwLDAsMSwxNC4xNzYsMTVhNS4xNTksNS4xNTksMCwwLDEtLjkxMy0yLjQ0NmwwLDBRMTMuNDg3LDEyLjI0LDEzLjY2MywxMi4wMjdaPjwvcGF0aD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld0JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xMCw0VjE0YTEsMSwwLDAsMS0yLDBWMTBIM3Y0YTEsMSwwLDAsMS0yLDBWNEExLDEsMCwwLDEsMyw0VjhIOFY0YTEsMSwwLDAsMSwyLDBabTYuMDY3ODcsOS4yMDlIMTQuOTg5NzVWNy41OTg2M2EuNTQwODUuNTQwODUsMCwwLDAtLjYwNS0uNjA1NDdoLS42Mjc0NGExLjAxMTE5LDEuMDExMTksMCwwLDAtLjc0OC4yOTY4OEwxMS42NDUsOC41NjY0MWEuNTQzNS41NDM1LDAsMCwwLS4wMjIuODU4NGwuMjg2MTMuMzA3NjJhLjUzODYxLjUzODYxLDAsMCwwLC44NDcxNy4wMzMybC4wOTkxMi0uMDg3ODlhMS4yMTM3LDEuMjEzNywwLDAsMCwuMjQxNy0uMzUyNTRoLjAyMjQ2cy0uMDExMjMuMzA4NTktLjAxMTIzLjYwNTQ3VjEzLjIwOUgxMi4wNDFhLjU0MDg1LjU0MDg1LDAsMCwwLS42MDUuNjA1NDd2LjQzOTQ1YS41NDA4NS41NDA4NSwwLDAsMCwuNjA1LjYwNTQ3aDQuMDI2ODZhLjU0MDg1LjU0MDg1LDAsMCwwLC42MDUtLjYwNTQ3di0uNDM5NDVBLjU0MDg1LjU0MDg1LDAsMCwwLDE2LjA2Nzg3LDEzLjIwOVogLz4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld0JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xNi43Mzk3NSwxMy44MTQ0NXYuNDM5NDVhLjU0MDg1LjU0MDg1LDAsMCwxLS42MDUuNjA1NDdIMTEuODU1YS41ODM5Mi41ODM5MiwwLDAsMS0uNjQ4OTMtLjYwNTQ3VjE0LjAxMjdjMC0yLjkwNTI3LDMuMzk5NDEtMy40MjE4NywzLjM5OTQxLTQuNTU0NjlhLjc3Njc1Ljc3Njc1LDAsMCwwLS44NDcxNy0uNzgxMjUsMS4xNzY4NCwxLjE3Njg0LDAsMCwwLS44MzU5NC4zODQ3N2MtLjI3NDkuMjYzNjctLjU2MS4zNzQtLjg1NzkxLjEzMTg0bC0uNDI5Mi0uMzQwODJjLS4zMDgxMS0uMjQyMTktLjM4NTI1LS41MTc1OC0uMTU0My0uODE0NDVhMi45NzE1NSwyLjk3MTU1LDAsMCwxLDIuNDUzNjEtMS4xNzY3NiwyLjQ1MzkzLDIuNDUzOTMsMCwwLDEsMi42ODQwOCwyLjQwOTE4YzAsMi40NTMxMi0zLjE3OTIsMi45MjY3Ni0zLjI3ODMyLDMuOTM4NDhoMi43OTQ0M0EuNTQwODUuNTQwODUsMCwwLDEsMTYuNzM5NzUsMTMuODE0NDVaTTksM0EuOTk5NzQuOTk5NzQsMCwwLDAsOCw0VjhIM1Y0QTEsMSwwLDAsMCwxLDRWMTRhMSwxLDAsMCwwLDIsMFYxMEg4djRhMSwxLDAsMCwwLDIsMFY0QS45OTk3NC45OTk3NCwwLDAsMCw5LDNaIC8+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDk0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT03IHgyPTEzIHkxPTQgeTI9ND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT01IHgyPTExIHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTggeDI9MTAgeTE9MTQgeTI9ND48L2xpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDk1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxyZWN0IGNsYXNzPXFsLXN0cm9rZSBoZWlnaHQ9MTAgd2lkdGg9MTIgeD0zIHk9ND48L3JlY3Q+IDxjaXJjbGUgY2xhc3M9cWwtZmlsbCBjeD02IGN5PTcgcj0xPjwvY2lyY2xlPiA8cG9seWxpbmUgY2xhc3M9XFxcInFsLWV2ZW4gcWwtZmlsbFxcXCIgcG9pbnRzPVxcXCI1IDEyIDUgMTEgNyA5IDggMTAgMTEgNyAxMyA5IDEzIDEyIDUgMTJcXFwiPjwvcG9seWxpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTE1IHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTMgeDI9MTUgeTE9NCB5Mj00PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTkgeDI9MTUgeTE9OSB5Mj05PjwvbGluZT4gPHBvbHlsaW5lIGNsYXNzPVxcXCJxbC1maWxsIHFsLXN0cm9rZVxcXCIgcG9pbnRzPVxcXCIzIDcgMyAxMSA1IDkgMyA3XFxcIj48L3BvbHlsaW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0xNSB5MT0xNCB5Mj0xND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTE1IHkxPTQgeTI9ND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT05IHgyPTE1IHkxPTkgeTI9OT48L2xpbmU+IDxwb2x5bGluZSBjbGFzcz1xbC1zdHJva2UgcG9pbnRzPVxcXCI1IDcgNSAxMSAzIDkgNSA3XFxcIj48L3BvbHlsaW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9NyB4Mj0xMSB5MT03IHkyPTExPjwvbGluZT4gPHBhdGggY2xhc3M9XFxcInFsLWV2ZW4gcWwtc3Ryb2tlXFxcIiBkPU04LjksNC41NzdhMy40NzYsMy40NzYsMCwwLDEsLjM2LDQuNjc5QTMuNDc2LDMuNDc2LDAsMCwxLDQuNTc3LDguOUMzLjE4NSw3LjUsMi4wMzUsNi40LDQuMjE3LDQuMjE3UzcuNSwzLjE4NSw4LjksNC41NzdaPjwvcGF0aD4gPHBhdGggY2xhc3M9XFxcInFsLWV2ZW4gcWwtc3Ryb2tlXFxcIiBkPU0xMy40MjMsOS4xYTMuNDc2LDMuNDc2LDAsMCwwLTQuNjc5LS4zNiwzLjQ3NiwzLjQ3NiwwLDAsMCwuMzYsNC42NzljMS4zOTIsMS4zOTIsMi41LDIuNTQyLDQuNjc5LjM2UzE0LjgxNSwxMC41LDEzLjQyMyw5LjFaPjwvcGF0aD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTcgeDI9MTUgeTE9NCB5Mj00PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTcgeDI9MTUgeTE9OSB5Mj05PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTcgeDI9MTUgeTE9MTQgeTI9MTQ+PC9saW5lPiA8bGluZSBjbGFzcz1cXFwicWwtc3Ryb2tlIHFsLXRoaW5cXFwiIHgxPTIuNSB4Mj00LjUgeTE9NS41IHkyPTUuNT48L2xpbmU+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMy41LDZBMC41LDAuNSwwLDAsMSwzLDUuNVYzLjA4NWwtMC4yNzYuMTM4QTAuNSwwLjUsMCwwLDEsMi4wNTMsM2MtMC4xMjQtLjI0Ny0wLjAyMy0wLjMyNC4yMjQtMC40NDdsMS0uNUEwLjUsMC41LDAsMCwxLDQsMi41djNBMC41LDAuNSwwLDAsMSwzLjUsNlo+PC9wYXRoPiA8cGF0aCBjbGFzcz1cXFwicWwtc3Ryb2tlIHFsLXRoaW5cXFwiIGQ9TTQuNSwxMC41aC0yYzAtLjIzNCwxLjg1LTEuMDc2LDEuODUtMi4yMzRBMC45NTksMC45NTksMCwwLDAsMi41LDguMTU2PjwvcGF0aD4gPHBhdGggY2xhc3M9XFxcInFsLXN0cm9rZSBxbC10aGluXFxcIiBkPU0yLjUsMTQuODQ2YTAuOTU5LDAuOTU5LDAsMCwwLDEuODUtLjEwOUEwLjcsMC43LDAsMCwwLDMuNzUsMTRhMC42ODgsMC42ODgsMCwwLDAsLjYtMC43MzYsMC45NTksMC45NTksMCwwLDAtMS44NS0uMTA5PjwvcGF0aD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT02IHgyPTE1IHkxPTQgeTI9ND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT02IHgyPTE1IHkxPTkgeTI9OT48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT02IHgyPTE1IHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTMgeDI9MyB5MT00IHkyPTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0zIHkxPTkgeTI9OT48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTMgeTE9MTQgeTI9MTQ+PC9saW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiAxMDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgY2xhc3M9XFxcIlxcXCIgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTkgeDI9MTUgeTE9NCB5Mj00PjwvbGluZT4gPHBvbHlsaW5lIGNsYXNzPXFsLXN0cm9rZSBwb2ludHM9XFxcIjMgNCA0IDUgNiAzXFxcIj48L3BvbHlsaW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9OSB4Mj0xNSB5MT0xNCB5Mj0xND48L2xpbmU+IDxwb2x5bGluZSBjbGFzcz1xbC1zdHJva2UgcG9pbnRzPVxcXCIzIDE0IDQgMTUgNiAxM1xcXCI+PC9wb2x5bGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTkgeDI9MTUgeTE9OSB5Mj05PjwvbGluZT4gPHBvbHlsaW5lIGNsYXNzPXFsLXN0cm9rZSBwb2ludHM9XFxcIjMgOSA0IDEwIDYgOFxcXCI+PC9wb2x5bGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTUuNSwxNUgxMy44NjFhMy44NTgsMy44NTgsMCwwLDAsMS45MTQtMi45NzUsMS44LDEuOCwwLDAsMC0xLjYtMS43NTFBMS45MjEsMS45MjEsMCwwLDAsMTIuMDIxLDExLjdhMC41MDAxMywwLjUwMDEzLDAsMSwwLC45NTcuMjkxaDBhMC45MTQsMC45MTQsMCwwLDEsMS4wNTMtLjcyNSwwLjgxLDAuODEsMCwwLDEsLjc0NC43NjJjMCwxLjA3Ni0xLjE2OTcxLDEuODY5ODItMS45Mzk3MSwyLjQzMDgyQTEuNDU2MzksMS40NTYzOSwwLDAsMCwxMiwxNS41YTAuNSwwLjUsMCwwLDAsLjUuNWgzQTAuNSwwLjUsMCwwLDAsMTUuNSwxNVogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU05LjY1LDUuMjQxYTEsMSwwLDAsMC0xLjQwOS4xMDhMNiw3Ljk2NCwzLjc1OSw1LjM0OUExLDEsMCwwLDAsMi4xOTIsNi41OTE3OFEyLjIxNTQxLDYuNjIxMywyLjI0MSw2LjY0OUw0LjY4NCw5LjUsMi4yNDEsMTIuMzVBMSwxLDAsMCwwLDMuNzEsMTMuNzA3MjJxMC4wMjU1Ny0uMDI3NjguMDQ5LTAuMDU3MjJMNiwxMS4wMzYsOC4yNDEsMTMuNjVhMSwxLDAsMSwwLDEuNTY3LTEuMjQyNzdROS43ODQ1OSwxMi4zNzc3LDkuNzU5LDEyLjM1TDcuMzE2LDkuNSw5Ljc1OSw2LjY1MUExLDEsMCwwLDAsOS42NSw1LjI0MVogLz4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTUuNSw3SDEzLjg2MWE0LjAxNSw0LjAxNSwwLDAsMCwxLjkxNC0yLjk3NSwxLjgsMS44LDAsMCwwLTEuNi0xLjc1MUExLjkyMiwxLjkyMiwwLDAsMCwxMi4wMjEsMy43YTAuNSwwLjUsMCwxLDAsLjk1Ny4yOTEsMC45MTcsMC45MTcsMCwwLDEsMS4wNTMtLjcyNSwwLjgxLDAuODEsMCwwLDEsLjc0NC43NjJjMCwxLjA3Ny0xLjE2NCwxLjkyNS0xLjkzNCwyLjQ4NkExLjQyMywxLjQyMywwLDAsMCwxMiw3LjVhMC41LDAuNSwwLDAsMCwuNS41aDNBMC41LDAuNSwwLDAsMCwxNS41LDdaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NOS42NTEsNS4yNDFhMSwxLDAsMCwwLTEuNDEuMTA4TDYsNy45NjQsMy43NTksNS4zNDlhMSwxLDAsMSwwLTEuNTE5LDEuM0w0LjY4Myw5LjUsMi4yNDEsMTIuMzVhMSwxLDAsMSwwLDEuNTE5LDEuM0w2LDExLjAzNiw4LjI0MSwxMy42NWExLDEsMCwwLDAsMS41MTktMS4zTDcuMzE3LDkuNSw5Ljc1OSw2LjY1MUExLDEsMCwwLDAsOS42NTEsNS4yNDFaIC8+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDEwNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1cXFwicWwtc3Ryb2tlIHFsLXRoaW5cXFwiIHgxPTE1LjUgeDI9Mi41IHkxPTguNSB5Mj05LjU+PC9saW5lPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTkuMDA3LDhDNi41NDIsNy43OTEsNiw3LjUxOSw2LDYuNSw2LDUuNzkyLDcuMjgzLDUsOSw1YzEuNTcxLDAsMi43NjUuNjc5LDIuOTY5LDEuMzA5YTEsMSwwLDAsMCwxLjktLjYxN0MxMy4zNTYsNC4xMDYsMTEuMzU0LDMsOSwzLDYuMiwzLDQsNC41MzgsNCw2LjVhMy4yLDMuMiwwLDAsMCwuNSwxLjg0M1o+PC9wYXRoPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTguOTg0LDEwQzExLjQ1NywxMC4yMDgsMTIsMTAuNDc5LDEyLDExLjVjMCwwLjcwOC0xLjI4MywxLjUtMywxLjUtMS41NzEsMC0yLjc2NS0uNjc5LTIuOTY5LTEuMzA5YTEsMSwwLDEsMC0xLjkuNjE3QzQuNjQ0LDEzLjg5NCw2LjY0NiwxNSw5LDE1YzIuOCwwLDUtMS41MzgsNS0zLjVhMy4yLDMuMiwwLDAsMC0uNS0xLjg0M1o+PC9wYXRoPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtc3Ryb2tlIGQ9TTUsM1Y5YTQuMDEyLDQuMDEyLDAsMCwwLDQsNEg5YTQuMDEyLDQuMDEyLDAsMCwwLDQtNFYzPjwvcGF0aD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSByeD0wLjUgcnk9MC41IHdpZHRoPTEyIHg9MyB5PTE1PjwvcmVjdD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxyZWN0IGNsYXNzPXFsLXN0cm9rZSBoZWlnaHQ9MTIgd2lkdGg9MTIgeD0zIHk9Mz48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEyIHdpZHRoPTEgeD01IHk9Mz48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEyIHdpZHRoPTEgeD0xMiB5PTM+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0yIHdpZHRoPTggeD01IHk9OD48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEgd2lkdGg9MyB4PTMgeT01PjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSB3aWR0aD0zIHg9MyB5PTc+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0zIHk9MTA+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0zIHk9MTI+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0xMiB5PTU+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0xMiB5PTc+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0xMiB5PTEwPjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSB3aWR0aD0zIHg9MTIgeT0xMj48L3JlY3Q+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDEwNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cG9seWdvbiBjbGFzcz1xbC1zdHJva2UgcG9pbnRzPVxcXCI3IDExIDkgMTMgMTEgMTEgNyAxMVxcXCI+PC9wb2x5Z29uPiA8cG9seWdvbiBjbGFzcz1xbC1zdHJva2UgcG9pbnRzPVxcXCI3IDcgOSA1IDExIDcgNyA3XFxcIj48L3BvbHlnb24+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDEwOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5CdWJibGVUb29sdGlwID0gdW5kZWZpbmVkO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblxudmFyIF9lbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9lbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VtaXR0ZXIpO1xuXG52YXIgX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xuXG52YXIgX3NlbGVjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG52YXIgX2ljb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG5cbnZhciBfaWNvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaWNvbnMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBUT09MQkFSX0NPTkZJRyA9IFtbJ2JvbGQnLCAnaXRhbGljJywgJ2xpbmsnXSwgW3sgaGVhZGVyOiAxIH0sIHsgaGVhZGVyOiAyIH0sICdibG9ja3F1b3RlJ11dO1xuXG52YXIgQnViYmxlVGhlbWUgPSBmdW5jdGlvbiAoX0Jhc2VUaGVtZSkge1xuICBfaW5oZXJpdHMoQnViYmxlVGhlbWUsIF9CYXNlVGhlbWUpO1xuXG4gIGZ1bmN0aW9uIEJ1YmJsZVRoZW1lKHF1aWxsLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1YmJsZVRoZW1lKTtcblxuICAgIGlmIChvcHRpb25zLm1vZHVsZXMudG9vbGJhciAhPSBudWxsICYmIG9wdGlvbnMubW9kdWxlcy50b29sYmFyLmNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zLm1vZHVsZXMudG9vbGJhci5jb250YWluZXIgPSBUT09MQkFSX0NPTkZJRztcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQnViYmxlVGhlbWUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCdWJibGVUaGVtZSkpLmNhbGwodGhpcywgcXVpbGwsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnF1aWxsLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdxbC1idWJibGUnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnViYmxlVGhlbWUsIFt7XG4gICAga2V5OiAnZXh0ZW5kVG9vbGJhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZFRvb2xiYXIodG9vbGJhcikge1xuICAgICAgdGhpcy50b29sdGlwID0gbmV3IEJ1YmJsZVRvb2x0aXAodGhpcy5xdWlsbCwgdGhpcy5vcHRpb25zLmJvdW5kcyk7XG4gICAgICB0aGlzLnRvb2x0aXAucm9vdC5hcHBlbmRDaGlsZCh0b29sYmFyLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmJ1aWxkQnV0dG9ucyhbXS5zbGljZS5jYWxsKHRvb2xiYXIuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpKSwgX2ljb25zMi5kZWZhdWx0KTtcbiAgICAgIHRoaXMuYnVpbGRQaWNrZXJzKFtdLnNsaWNlLmNhbGwodG9vbGJhci5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0JykpLCBfaWNvbnMyLmRlZmF1bHQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWJibGVUaGVtZTtcbn0oX2Jhc2UyLmRlZmF1bHQpO1xuXG5CdWJibGVUaGVtZS5ERUZBVUxUUyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KSh0cnVlLCB7fSwgX2Jhc2UyLmRlZmF1bHQuREVGQVVMVFMsIHtcbiAgbW9kdWxlczoge1xuICAgIHRvb2xiYXI6IHtcbiAgICAgIGhhbmRsZXJzOiB7XG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIGxpbmsodmFsdWUpIHtcbiAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGluaycsIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5xdWlsbC50aGVtZS50b29sdGlwLmVkaXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgQnViYmxlVG9vbHRpcCA9IGZ1bmN0aW9uIChfQmFzZVRvb2x0aXApIHtcbiAgX2luaGVyaXRzKEJ1YmJsZVRvb2x0aXAsIF9CYXNlVG9vbHRpcCk7XG5cbiAgZnVuY3Rpb24gQnViYmxlVG9vbHRpcChxdWlsbCwgYm91bmRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1YmJsZVRvb2x0aXApO1xuXG4gICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCdWJibGVUb29sdGlwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnViYmxlVG9vbHRpcCkpLmNhbGwodGhpcywgcXVpbGwsIGJvdW5kcykpO1xuXG4gICAgX3RoaXMyLnF1aWxsLm9uKF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5FRElUT1JfQ0hBTkdFLCBmdW5jdGlvbiAodHlwZSwgcmFuZ2UsIG9sZFJhbmdlLCBzb3VyY2UpIHtcbiAgICAgIGlmICh0eXBlICE9PSBfZW1pdHRlcjIuZGVmYXVsdC5ldmVudHMuU0VMRUNUSU9OX0NIQU5HRSkgcmV0dXJuO1xuICAgICAgaWYgKHJhbmdlICE9IG51bGwgJiYgcmFuZ2UubGVuZ3RoID4gMCAmJiBzb3VyY2UgPT09IF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUikge1xuICAgICAgICBfdGhpczIuc2hvdygpO1xuICAgICAgICAvLyBMb2NrIG91ciB3aWR0aCBzbyB3ZSB3aWxsIGV4cGFuZCBiZXlvbmQgb3VyIG9mZnNldFBhcmVudCBib3VuZGFyaWVzXG4gICAgICAgIF90aGlzMi5yb290LnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgX3RoaXMyLnJvb3Quc3R5bGUud2lkdGggPSAnJztcbiAgICAgICAgX3RoaXMyLnJvb3Quc3R5bGUud2lkdGggPSBfdGhpczIucm9vdC5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgIHZhciBsaW5lcyA9IF90aGlzMi5xdWlsbC5nZXRMaW5lcyhyYW5nZS5pbmRleCwgcmFuZ2UubGVuZ3RoKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzMi5wb3NpdGlvbihfdGhpczIucXVpbGwuZ2V0Qm91bmRzKHJhbmdlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGxhc3RMaW5lID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMyLnF1aWxsLmdldEluZGV4KGxhc3RMaW5lKTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4obGFzdExpbmUubGVuZ3RoKCkgLSAxLCByYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aCAtIGluZGV4KTtcbiAgICAgICAgICB2YXIgX2JvdW5kcyA9IF90aGlzMi5xdWlsbC5nZXRCb3VuZHMobmV3IF9zZWxlY3Rpb24uUmFuZ2UoaW5kZXgsIGxlbmd0aCkpO1xuICAgICAgICAgIF90aGlzMi5wb3NpdGlvbihfYm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBfdGhpczIudGV4dGJveCAmJiBfdGhpczIucXVpbGwuaGFzRm9jdXMoKSkge1xuICAgICAgICBfdGhpczIuaGlkZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnViYmxlVG9vbHRpcCwgW3tcbiAgICBrZXk6ICdsaXN0ZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW4oKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgX2dldChCdWJibGVUb29sdGlwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJ1YmJsZVRvb2x0aXAucHJvdG90eXBlKSwgJ2xpc3RlbicsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcignLnFsLWNsb3NlJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5yb290LmNsYXNzTGlzdC5yZW1vdmUoJ3FsLWVkaXRpbmcnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5xdWlsbC5vbihfZW1pdHRlcjIuZGVmYXVsdC5ldmVudHMuU0NST0xMX09QVElNSVpFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIExldCBzZWxlY3Rpb24gYmUgcmVzdG9yZWQgYnkgdG9vbGJhciBoYW5kbGVycyBiZWZvcmUgcmVwb3NpdGlvbmluZ1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMzLnJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1oaWRkZW4nKSkgcmV0dXJuO1xuICAgICAgICAgIHZhciByYW5nZSA9IF90aGlzMy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICBpZiAocmFuZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMzLnBvc2l0aW9uKF90aGlzMy5xdWlsbC5nZXRCb3VuZHMocmFuZ2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FuY2VsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbihyZWZlcmVuY2UpIHtcbiAgICAgIHZhciBzaGlmdCA9IF9nZXQoQnViYmxlVG9vbHRpcC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCdWJibGVUb29sdGlwLnByb3RvdHlwZSksICdwb3NpdGlvbicsIHRoaXMpLmNhbGwodGhpcywgcmVmZXJlbmNlKTtcbiAgICAgIHZhciBhcnJvdyA9IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKCcucWwtdG9vbHRpcC1hcnJvdycpO1xuICAgICAgYXJyb3cuc3R5bGUubWFyZ2luTGVmdCA9ICcnO1xuICAgICAgaWYgKHNoaWZ0ID09PSAwKSByZXR1cm4gc2hpZnQ7XG4gICAgICBhcnJvdy5zdHlsZS5tYXJnaW5MZWZ0ID0gLTEgKiBzaGlmdCAtIGFycm93Lm9mZnNldFdpZHRoIC8gMiArICdweCc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1YmJsZVRvb2x0aXA7XG59KF9iYXNlLkJhc2VUb29sdGlwKTtcblxuQnViYmxlVG9vbHRpcC5URU1QTEFURSA9IFsnPHNwYW4gY2xhc3M9XCJxbC10b29sdGlwLWFycm93XCI+PC9zcGFuPicsICc8ZGl2IGNsYXNzPVwicWwtdG9vbHRpcC1lZGl0b3JcIj4nLCAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS1mb3JtdWxhPVwiZT1tY14yXCIgZGF0YS1saW5rPVwiaHR0cHM6Ly9xdWlsbGpzLmNvbVwiIGRhdGEtdmlkZW89XCJFbWJlZCBVUkxcIj4nLCAnPGEgY2xhc3M9XCJxbC1jbG9zZVwiPjwvYT4nLCAnPC9kaXY+J10uam9pbignJyk7XG5cbmV4cG9ydHMuQnViYmxlVG9vbHRpcCA9IEJ1YmJsZVRvb2x0aXA7XG5leHBvcnRzLmRlZmF1bHQgPSBCdWJibGVUaGVtZTtcblxuLyoqKi8gfSksXG4vKiAxMDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlbXCJkZWZhdWx0XCJdO1xufSk7Il0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwic2VsZiIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJuIiwiX19lc01vZHVsZSIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwidmFsdWUiLCJjb250YWluZXJfMSIsImZvcm1hdF8xIiwibGVhZl8xIiwic2Nyb2xsXzEiLCJpbmxpbmVfMSIsImJsb2NrXzEiLCJlbWJlZF8xIiwidGV4dF8xIiwiYXR0cmlidXRvcl8xIiwiY2xhc3NfMSIsInN0eWxlXzEiLCJzdG9yZV8xIiwiUmVnaXN0cnkiLCJQYXJjaG1lbnQiLCJTY29wZSIsImNyZWF0ZSIsImZpbmQiLCJxdWVyeSIsInJlZ2lzdGVyIiwiQ29udGFpbmVyIiwiZGVmYXVsdCIsIkZvcm1hdCIsIkxlYWYiLCJFbWJlZCIsIlNjcm9sbCIsIkJsb2NrIiwiSW5saW5lIiwiVGV4dCIsIkF0dHJpYnV0b3IiLCJBdHRyaWJ1dGUiLCJDbGFzcyIsIlN0eWxlIiwiU3RvcmUiLCJfX2V4dGVuZHMiLCJleHRlbmRTdGF0aWNzIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJBcnJheSIsImIiLCJfXyIsImNvbnN0cnVjdG9yIiwiUGFyY2htZW50RXJyb3IiLCJfc3VwZXIiLCJtZXNzYWdlIiwiX3RoaXMiLCJFcnJvciIsImF0dHJpYnV0ZXMiLCJjbGFzc2VzIiwidGFncyIsInR5cGVzIiwiREFUQV9LRVkiLCJpbnB1dCIsIm1hdGNoIiwiQmxvdENsYXNzIiwibm9kZSIsIk5vZGUiLCJURVhUX05PREUiLCJidWJibGUiLCJibG90IiwicGFyZW50Tm9kZSIsInNjb3BlIiwiQU5ZIiwiTEVWRUwiLCJCTE9DSyIsIklOTElORSIsIkhUTUxFbGVtZW50IiwibmFtZXMiLCJnZXRBdHRyaWJ1dGUiLCJzcGxpdCIsInRhZ05hbWUiLCJUWVBFIiwiRGVmaW5pdGlvbnMiLCJfaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsIm1hcCIsIkRlZmluaXRpb24iLCJibG90TmFtZSIsImF0dHJOYW1lIiwia2V5TmFtZSIsImNsYXNzTmFtZSIsImlzQXJyYXkiLCJ0b1VwcGVyQ2FzZSIsInRhZ05hbWVzIiwiZm9yRWFjaCIsInRhZyIsImRpZmYiLCJlcXVhbCIsImV4dGVuZCIsIm9wIiwiTlVMTF9DSEFSQUNURVIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJEZWx0YSIsIm9wcyIsImluc2VydCIsInRleHQiLCJuZXdPcCIsImtleXMiLCJwdXNoIiwicmV0YWluIiwiaW5kZXgiLCJsYXN0T3AiLCJ1bnNoaWZ0Iiwic3BsaWNlIiwiY2hvcCIsInBvcCIsImZpbHRlciIsInByZWRpY2F0ZSIsInBhcnRpdGlvbiIsInBhc3NlZCIsImZhaWxlZCIsInRhcmdldCIsInJlZHVjZSIsImluaXRpYWwiLCJjaGFuZ2VMZW5ndGgiLCJlbGVtIiwiZGVsZXRlIiwic2xpY2UiLCJzdGFydCIsImVuZCIsIkluZmluaXR5IiwiaXRlciIsIml0ZXJhdG9yIiwiaGFzTmV4dCIsIm5leHRPcCIsIm5leHQiLCJjb21wb3NlIiwib3RoZXIiLCJ0aGlzSXRlciIsIm90aGVySXRlciIsImZpcnN0T3RoZXIiLCJwZWVrIiwiZmlyc3RMZWZ0IiwicGVla1R5cGUiLCJwZWVrTGVuZ3RoIiwiZGVsdGEiLCJNYXRoIiwibWluIiwidGhpc09wIiwib3RoZXJPcCIsInJlc3QiLCJjb25jYXQiLCJzdHJpbmdzIiwicHJlcCIsImpvaW4iLCJkaWZmUmVzdWx0IiwiY29tcG9uZW50Iiwib3BMZW5ndGgiLCJJTlNFUlQiLCJERUxFVEUiLCJFUVVBTCIsImVhY2hMaW5lIiwibmV3bGluZSIsImxpbmUiLCJpbmRleE9mIiwidHJhbnNmb3JtIiwicHJpb3JpdHkiLCJ0cmFuc2Zvcm1Qb3NpdGlvbiIsIm9mZnNldCIsIm5leHRUeXBlIiwiaGFzT3duIiwidG9TdHIiLCJ0b1N0cmluZyIsImdPUEQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJhcnIiLCJpc1BsYWluT2JqZWN0Iiwib2JqIiwiaGFzT3duQ29uc3RydWN0b3IiLCJoYXNJc1Byb3RvdHlwZU9mIiwia2V5Iiwic2V0UHJvcGVydHkiLCJvcHRpb25zIiwibmV3VmFsdWUiLCJ3cml0YWJsZSIsImdldFByb3BlcnR5Iiwic3JjIiwiY29weSIsImNvcHlJc0FycmF5IiwiY2xvbmUiLCJkZWVwIiwiQmxvY2tFbWJlZCIsImJ1YmJsZUZvcm1hdHMiLCJ1bmRlZmluZWQiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfZ2V0IiwicmVjZWl2ZXIiLCJGdW5jdGlvbiIsImRlc2MiLCJwYXJlbnQiLCJnZXRQcm90b3R5cGVPZiIsIl9leHRlbmQiLCJfZXh0ZW5kMiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfcXVpbGxEZWx0YSIsIl9xdWlsbERlbHRhMiIsIl9wYXJjaG1lbnQiLCJfcGFyY2htZW50MiIsIl9icmVhayIsIl9icmVhazIiLCJfaW5saW5lIiwiX2lubGluZTIiLCJfdGV4dCIsIl90ZXh0MiIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiVHlwZUVycm9yIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsIk5FV0xJTkVfTEVOR1RIIiwiX1BhcmNobWVudCRFbWJlZCIsImFwcGx5IiwiYXR0YWNoIiwiZG9tTm9kZSIsImZvcm1hdHMiLCJ2YWx1ZXMiLCJmb3JtYXQiLCJhdHRyaWJ1dGUiLCJCTE9DS19BVFRSSUJVVEUiLCJmb3JtYXRBdCIsImluc2VydEF0IiwiZGVmIiwiZW5kc1dpdGgiLCJibG9jayIsImluc2VydEJlZm9yZSIsIkJMT0NLX0JMT1QiLCJfUGFyY2htZW50JEJsb2NrIiwiX3RoaXMyIiwiY2FjaGUiLCJkZXNjZW5kYW50cyIsImxlYWYiLCJkZWxldGVBdCIsImxpbmVzIiwic2hpZnQiLCJjaGlsZHJlbiIsInRhaWwiLCJyZWYiLCJoZWFkIiwicmVtb3ZlIiwibW92ZUNoaWxkcmVuIiwib3B0aW1pemUiLCJjb250ZXh0IiwicGF0aCIsInJlbW92ZUNoaWxkIiwiY2hpbGQiLCJmb3JjZSIsImRlZmF1bHRDaGlsZCIsImFsbG93ZWRDaGlsZHJlbiIsInN0YXRpY3MiLCJvdmVybG9hZCIsImV4cGFuZENvbmZpZyIsIl90eXBlb2YiLCJTeW1ib2wiLCJfc2xpY2VkVG9BcnJheSIsInNsaWNlSXRlcmF0b3IiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwiX3MiLCJkb25lIiwiZXJyIiwiX2VkaXRvciIsIl9lZGl0b3IyIiwiX2VtaXR0ZXIzIiwiX2VtaXR0ZXI0IiwiX21vZHVsZSIsIl9tb2R1bGUyIiwiX3NlbGVjdGlvbiIsIl9zZWxlY3Rpb24yIiwiX2xvZ2dlciIsIl9sb2dnZXIyIiwiX3RoZW1lIiwiX3RoZW1lMiIsIl9kZWZpbmVQcm9wZXJ0eSIsImRlYnVnIiwiUXVpbGwiLCJsaW1pdCIsImxldmVsIiwiX19xdWlsbCIsIl9pbXBvcnQiLCJpbXBvcnRzIiwiZXJyb3IiLCJvdmVyd3JpdGUiLCJ3YXJuIiwic3RhcnRzV2l0aCIsImNvbnRhaW5lciIsImh0bWwiLCJpbm5lckhUTUwiLCJ0cmltIiwiY2xhc3NMaXN0IiwiYWRkIiwiYWRkQ29udGFpbmVyIiwic2V0QXR0cmlidXRlIiwic2Nyb2xsaW5nQ29udGFpbmVyIiwiZW1pdHRlciIsInNjcm9sbCIsIndoaXRlbGlzdCIsImVkaXRvciIsInNlbGVjdGlvbiIsInRoZW1lIiwia2V5Ym9hcmQiLCJhZGRNb2R1bGUiLCJjbGlwYm9hcmQiLCJoaXN0b3J5IiwiaW5pdCIsIm9uIiwiZXZlbnRzIiwiRURJVE9SX0NIQU5HRSIsInR5cGUiLCJURVhUX0NIQU5HRSIsInRvZ2dsZSIsImlzQmxhbmsiLCJTQ1JPTExfVVBEQVRFIiwic291cmNlIiwibXV0YXRpb25zIiwicmFuZ2UiLCJsYXN0UmFuZ2UiLCJtb2RpZnkiLCJ1cGRhdGUiLCJjb250ZW50cyIsImNvbnZlcnQiLCJzZXRDb250ZW50cyIsImNsZWFyIiwicGxhY2Vob2xkZXIiLCJyZWFkT25seSIsImRpc2FibGUiLCJyZWZOb2RlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYmx1ciIsInNldFJhbmdlIiwiZGVsZXRlVGV4dCIsIl90aGlzMyIsIl9vdmVybG9hZCIsIl9vdmVybG9hZDIiLCJlbmFibGUiLCJlbmFibGVkIiwiZm9jdXMiLCJzY3JvbGxUb3AiLCJzY3JvbGxJbnRvVmlldyIsIl90aGlzNCIsInNvdXJjZXMiLCJBUEkiLCJnZXRTZWxlY3Rpb24iLCJjaGFuZ2UiLCJmb3JtYXRMaW5lIiwiZm9ybWF0VGV4dCIsInNldFNlbGVjdGlvbiIsIlNJTEVOVCIsIl90aGlzNSIsIl9vdmVybG9hZDMiLCJfb3ZlcmxvYWQ0IiwiX3RoaXM2IiwiX292ZXJsb2FkNSIsIl9vdmVybG9hZDYiLCJnZXRCb3VuZHMiLCJib3VuZHMiLCJjb250YWluZXJCb3VuZHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJib3R0b20iLCJ0b3AiLCJoZWlnaHQiLCJsZWZ0IiwicmlnaHQiLCJ3aWR0aCIsImdldENvbnRlbnRzIiwiZ2V0TGVuZ3RoIiwiX292ZXJsb2FkNyIsIl9vdmVybG9hZDgiLCJnZXRGb3JtYXQiLCJnZXRJbmRleCIsImdldExlYWYiLCJnZXRMaW5lIiwiZ2V0TGluZXMiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJnZXRNb2R1bGUiLCJnZXRSYW5nZSIsImdldFRleHQiLCJfb3ZlcmxvYWQ5IiwiX292ZXJsb2FkMTAiLCJoYXNGb2N1cyIsImluc2VydEVtYmVkIiwiZW1iZWQiLCJfdGhpczciLCJpbnNlcnRUZXh0IiwiX3RoaXM4IiwiX292ZXJsb2FkMTEiLCJfb3ZlcmxvYWQxMiIsImlzRW5hYmxlZCIsImNvbnRhaW5zIiwib2ZmIiwib25jZSIsInBhc3RlSFRNTCIsImRhbmdlcm91c2x5UGFzdGVIVE1MIiwicmVtb3ZlRm9ybWF0IiwiX3RoaXM5IiwiX292ZXJsb2FkMTMiLCJfb3ZlcmxvYWQxNCIsIl90aGlzMTAiLCJkZWxldGVkIiwiYXBwbGllZCIsImFwcGx5RGVsdGEiLCJyZXQiLCJfb3ZlcmxvYWQxNSIsIl9vdmVybG9hZDE2IiwiUmFuZ2UiLCJzZXRUZXh0IiwiVVNFUiIsInVwZGF0ZUNvbnRlbnRzIiwiX3RoaXMxMSIsIkRFRkFVTFRTIiwic3RyaWN0IiwidmVyc2lvbiIsInVzZXJDb25maWciLCJpbXBvcnQiLCJ0aGVtZUNvbmZpZyIsImNvbmZpZyIsIm1vZHVsZU5hbWVzIiwibW9kdWxlQ29uZmlnIiwibW9kdWxlQ2xhc3MiLCJ0b29sYmFyIiwicXVlcnlTZWxlY3RvciIsIm1vZGlmaWVyIiwib2xkRGVsdGEiLCJzaGlmdFJhbmdlIiwiX2VtaXR0ZXIiLCJhcmdzIiwiZW1pdCIsIl9lbWl0dGVyMiIsIl9tYXAiLCJwb3MiLCJfbWFwMiIsIl9tYXAzIiwibWF4IiwiX21hcDQiLCJfUGFyY2htZW50JElubGluZSIsImNvbXBhcmUiLCJCTE9UIiwiaXNvbGF0ZSIsIndyYXAiLCJzZWxmSW5kZXgiLCJvcmRlciIsIm90aGVySW5kZXgiLCJUZXh0QmxvdCIsIl9QYXJjaG1lbnQkVGV4dCIsIl9ldmVudGVtaXR0ZXIiLCJfZXZlbnRlbWl0dGVyMiIsIkVWRU5UUyIsImV2ZW50TmFtZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfbGVuIiwiX2tleSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJfbm9kZSRfX3F1aWxsJGVtaXR0ZXIiLCJoYW5kbGVET00iLCJFbWl0dGVyIiwiX0V2ZW50RW1pdHRlciIsImxpc3RlbmVycyIsImxvZyIsImV2ZW50IiwiX2xlbjIiLCJfa2V5MiIsIl9yZWYiLCJoYW5kbGVyIiwibGlzdGVuRE9NIiwiU0NST0xMX0JFRk9SRV9VUERBVEUiLCJTQ1JPTExfT1BUSU1JWkUiLCJTRUxFQ1RJT05fQ0hBTkdFIiwiTW9kdWxlIiwicXVpbGwiLCJsZXZlbHMiLCJtZXRob2QiLCJfY29uc29sZSIsImNvbnNvbGUiLCJuYW1lc3BhY2UiLCJucyIsImxvZ2dlciIsImJpbmQiLCJuZXdMZXZlbCIsInBTbGljZSIsIm9iamVjdEtleXMiLCJpc0FyZ3VtZW50cyIsImRlZXBFcXVhbCIsImFjdHVhbCIsImV4cGVjdGVkIiwib3B0cyIsIkRhdGUiLCJnZXRUaW1lIiwib2JqRXF1aXYiLCJpc1VuZGVmaW5lZE9yTnVsbCIsImlzQnVmZmVyIiwieCIsImEiLCJrYSIsImtiIiwiZSIsInNvcnQiLCJhdHRyaWJ1dGVCaXQiLCJBVFRSSUJVVEUiLCJpdGVtIiwiY2FuQWRkIiwicmVwbGFjZSIsInJlbW92ZUF0dHJpYnV0ZSIsIkNvZGUiLCJfYmxvY2siLCJfYmxvY2syIiwiX0lubGluZSIsIkNvZGVCbG9jayIsIl9CbG9jayIsInRleHRDb250ZW50IiwiZnJhZyIsIl9kZXNjZW5kYW50IiwiZGVzY2VuZGFudCIsIl9kZXNjZW5kYW50MiIsIm5leHROZXdsaW5lIiwibmV3bGluZUluZGV4IiwicHJldk5ld2xpbmUiLCJpc29sYXRlTGVuZ3RoIiwiX2Rlc2NlbmRhbnQzIiwiX2Rlc2NlbmRhbnQ0Iiwic2VhcmNoSW5kZXgiLCJyZXZlcnNlIiwibGFzdEluZGV4T2YiLCJhcHBlbmRDaGlsZCIsInByZXYiLCJ1bndyYXAiLCJUQUIiLCJfb3AiLCJfb3AyIiwiX2NvZGUiLCJfY29kZTIiLCJfY3Vyc29yIiwiX2N1cnNvcjIiLCJfY2xvbmUiLCJfY2xvbmUyIiwiX2RlZXBFcXVhbCIsIl9kZWVwRXF1YWwyIiwiQVNDSUkiLCJFZGl0b3IiLCJnZXREZWx0YSIsImNvbnN1bWVOZXh0TmV3bGluZSIsInNjcm9sbExlbmd0aCIsImJhdGNoU3RhcnQiLCJub3JtYWxpemVEZWx0YSIsIl9zY3JvbGwkbGluZSIsIl9zY3JvbGwkbGluZTIiLCJfbGluZSRkZXNjZW5kYW50IiwiX2xpbmUkZGVzY2VuZGFudDIiLCJiYXRjaEVuZCIsImxlbmd0aFJlbWFpbmluZyIsImxpbmVMZW5ndGgiLCJjb2RlSW5kZXgiLCJjb2RlTGVuZ3RoIiwibGVhdmVzIiwiX3BhdGgiLCJmb3JtYXRzQXJyIiwiYmxvdHMiLCJjb21iaW5lRm9ybWF0cyIsIl9zY3JvbGwkbGluZTMiLCJfc2Nyb2xsJGxpbmU0Iiwic3VmZml4TGVuZ3RoIiwic3VmZml4IiwiY3Vyc29ySW5kZXgiLCJkYXRhIiwidGV4dEJsb3QiLCJvbGRWYWx1ZSIsIkNPTlRFTlRTIiwib2xkVGV4dCIsIm5ld1RleHQiLCJkaWZmRGVsdGEiLCJjb21iaW5lZCIsIm1lcmdlZCIsImltYWdlIiwibGlzdCIsImJ1bGxldCIsIl90b0NvbnN1bWFibGVBcnJheSIsImFycjIiLCJmcm9tIiwiU2VsZWN0aW9uIiwiY29tcG9zaW5nIiwibW91c2VEb3duIiwiY3Vyc29yIiwic2F2ZWRSYW5nZSIsImhhbmRsZUNvbXBvc2l0aW9uIiwiaGFuZGxlRHJhZ2dpbmciLCJzZXRUaW1lb3V0IiwibmF0aXZlIiwiZ2V0TmF0aXZlUmFuZ2UiLCJ0ZXh0Tm9kZSIsInNldE5hdGl2ZVJhbmdlIiwiaWdub3JlZCIsIl9jb250ZXh0JHJhbmdlIiwic3RhcnROb2RlIiwic3RhcnRPZmZzZXQiLCJlbmROb2RlIiwiZW5kT2Zmc2V0IiwicmVzdG9yZSIsImJvZHkiLCJfZm9ybWF0IiwibmF0aXZlUmFuZ2UiLCJjb2xsYXBzZWQiLCJhZnRlciIsIl9zY3JvbGwkbGVhZiIsIl9zY3JvbGwkbGVhZjIiLCJfbGVhZiRwb3NpdGlvbiIsInBvc2l0aW9uIiwiX2xlYWYkcG9zaXRpb24yIiwiY3JlYXRlUmFuZ2UiLCJzZXRTdGFydCIsIl9zY3JvbGwkbGVhZjMiLCJfc2Nyb2xsJGxlYWY0IiwiX2xlYWYkcG9zaXRpb24zIiwiX2xlYWYkcG9zaXRpb240Iiwic2V0RW5kIiwic2lkZSIsInJlY3QiLCJyYW5nZUNvdW50IiwiZ2V0UmFuZ2VBdCIsIm5vcm1hbGl6ZU5hdGl2ZSIsImluZm8iLCJub3JtYWxpemVkIiwibm9ybWFsaXplZFRvUmFuZ2UiLCJhY3RpdmVFbGVtZW50IiwicG9zaXRpb25zIiwiaW5kZXhlcyIsIl9wb3NpdGlvbiIsInN0YXJ0Q29udGFpbmVyIiwiZW5kQ29udGFpbmVyIiwiY2hpbGROb2RlcyIsImxhc3RDaGlsZCIsInJhbmdlVG9OYXRpdmUiLCJfc2Nyb2xsJGxlYWY1IiwiX3Njcm9sbCRsZWFmNiIsIl9sZWFmJHBvc2l0aW9uNSIsIl9sZWFmJHBvc2l0aW9uNiIsImZpcnN0IiwibGFzdCIsInNjcm9sbEJvdW5kcyIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwib2xkUmFuZ2UiLCJfZ2V0UmFuZ2UiLCJfZ2V0UmFuZ2UyIiwiQnJlYWsiLCJpbnNlcnRJbnRvIiwibGlua2VkX2xpc3RfMSIsInNoYWRvd18xIiwiQ29udGFpbmVyQmxvdCIsImJ1aWxkIiwibWFrZUJsb3QiLCJmb3JFYWNoQXQiLCJjcml0ZXJpYSIsIl9hIiwibGVuZ3RoTGVmdCIsImRldGFjaCIsImNoaWxkQmxvdCIsInJlZkJsb3QiLCJzb21lIiwibWVtbyIsInRhcmdldFBhcmVudCIsImluY2x1c2l2ZSIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJtdXRhdGlvbiIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZIiwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIiwibmV4dFNpYmxpbmciLCJyZXBsYWNlQ2hpbGQiLCJGb3JtYXRCbG90IiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlV2l0aCIsInJlcGxhY2VtZW50Iiwid3JhcHBlciIsIm1vdmUiLCJMZWFmQmxvdCIsIklOTElORV9CTE9UIiwibGliIiwia2VlcE51bGwiLCJJdGVyYXRvciIsInJldE9wIiwic3Vic3RyIiwiX2luc3RhbmNlb2YiLCJuYXRpdmVNYXAiLCJNYXAiLCJfIiwibmF0aXZlU2V0IiwiU2V0IiwibmF0aXZlUHJvbWlzZSIsIlByb21pc2UiLCJjaXJjdWxhciIsImRlcHRoIiwiaW5jbHVkZU5vbkVudW1lcmFibGUiLCJhbGxQYXJlbnRzIiwiYWxsQ2hpbGRyZW4iLCJ1c2VCdWZmZXIiLCJCdWZmZXIiLCJwcm90byIsInJlc29sdmUiLCJyZWplY3QiLCJ0aGVuIiwiX19pc0FycmF5IiwiX19pc1JlZ0V4cCIsIlJlZ0V4cCIsIl9fZ2V0UmVnRXhwRmxhZ3MiLCJsYXN0SW5kZXgiLCJfX2lzRGF0ZSIsImFsbG9jVW5zYWZlIiwia2V5Q2hpbGQiLCJ2YWx1ZUNoaWxkIiwic2V0IiwiZW50cnlDaGlsZCIsImF0dHJzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsInN5bWJvbCIsImFsbFByb3BlcnR5TmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicHJvcGVydHlOYW1lIiwiY2xvbmVQcm90b3R5cGUiLCJfX29ialRvU3RyIiwicmUiLCJmbGFncyIsImdsb2JhbCIsImlnbm9yZUNhc2UiLCJtdWx0aWxpbmUiLCJfY29udGFpbmVyIiwiX2NvbnRhaW5lcjIiLCJpc0xpbmUiLCJfUGFyY2htZW50JFNjcm9sbCIsImJhdGNoIiwiX2xpbmUiLCJfbGluZTIiLCJfbGluZTMiLCJfbGluZTQiLCJfbmV3bGluZUluZGV4Iiwib2JzZXJ2ZXIiLCJ0YWtlUmVjb3JkcyIsIlNIT1JUS0VZIiwiX3F1aWxsIiwiX3F1aWxsMiIsInRlc3QiLCJuYXZpZ2F0b3IiLCJwbGF0Zm9ybSIsIktleWJvYXJkIiwiX01vZHVsZSIsImV2dCIsImJpbmRpbmciLCJub3JtYWxpemUiLCJ3aGljaCIsImtleUNvZGUiLCJiaW5kaW5ncyIsImFkZEJpbmRpbmciLCJFTlRFUiIsInNoaWZ0S2V5IiwiaGFuZGxlRW50ZXIiLCJtZXRhS2V5IiwiY3RybEtleSIsImFsdEtleSIsInVzZXJBZ2VudCIsIkJBQ0tTUEFDRSIsImhhbmRsZUJhY2tzcGFjZSIsImhhbmRsZURlbGV0ZSIsInByZWZpeCIsImhhbmRsZURlbGV0ZVJhbmdlIiwibGlzdGVuIiwiZGVmYXVsdFByZXZlbnRlZCIsIl9xdWlsbCRnZXRMaW5lIiwiX3F1aWxsJGdldExpbmUyIiwiX3F1aWxsJGdldExlYWYiLCJfcXVpbGwkZ2V0TGVhZjIiLCJsZWFmU3RhcnQiLCJvZmZzZXRTdGFydCIsIl9yZWYyIiwibGVhZkVuZCIsIm9mZnNldEVuZCIsInByZWZpeFRleHQiLCJzdWZmaXhUZXh0IiwiY3VyQ29udGV4dCIsImVtcHR5IiwicHJldmVudGVkIiwiZXZlcnkiLCJwcmV2ZW50RGVmYXVsdCIsIkVTQ0FQRSIsIkxFRlQiLCJVUCIsIlJJR0hUIiwiRE9XTiIsIm1ha2VGb3JtYXRIYW5kbGVyIiwiaW5kZW50IiwibWFrZUNvZGVCbG9ja0hhbmRsZXIiLCJjdXRvZmYiLCJfcXVpbGwkZ2V0TGluZTMiLCJfcXVpbGwkZ2V0TGluZTQiLCJfcXVpbGwkZ2V0TGluZTUiLCJfcXVpbGwkZ2V0TGluZTYiLCJoZWFkZXIiLCJfcXVpbGwkZ2V0TGluZTciLCJfcXVpbGwkZ2V0TGluZTgiLCJfcXVpbGwkZ2V0TGluZTkiLCJfcXVpbGwkZ2V0TGluZTEwIiwibWFrZUVtYmVkQXJyb3dIYW5kbGVyIiwiX3JlZjMiLCJ3aGVyZSIsIl9xdWlsbCRnZXRMZWFmMyIsIl9xdWlsbCRnZXRMZWFmNCIsIl9xdWlsbCRnZXRMaW5lMTEiLCJfcXVpbGwkZ2V0TGluZTEyIiwiX3F1aWxsJGdldExpbmUxMyIsIl9xdWlsbCRnZXRMaW5lMTQiLCJjdXJGb3JtYXRzIiwicHJldkZvcm1hdHMiLCJuZXh0TGVuZ3RoIiwiX3F1aWxsJGdldExpbmUxNSIsIl9xdWlsbCRnZXRMaW5lMTYiLCJfcXVpbGwkZ2V0TGluZTE3IiwiX3F1aWxsJGdldExpbmUxOCIsIm5leHRGb3JtYXRzIiwiZmlyc3RGb3JtYXRzIiwibGFzdEZvcm1hdHMiLCJsaW5lRm9ybWF0cyIsIl9xdWlsbCRzY3JvbGwkZGVzY2VuZCIsIl9xdWlsbCRzY3JvbGwkZGVzY2VuZDIiLCJzY3JvbGxJbmRleCIsInNob3J0S2V5IiwiY2hhckNvZGVBdCIsIkN1cnNvciIsImNyZWF0ZVRleHROb2RlIiwiX2xlbmd0aCIsInJlc3RvcmVUZXh0IiwiX1BhcmNobWVudCRDb250YWluZXIiLCJDb2xvclN0eWxlIiwiQ29sb3JDbGFzcyIsIkNvbG9yQXR0cmlidXRvciIsIl9QYXJjaG1lbnQkQXR0cmlidXRvciIsInBhcnNlSW50Iiwic2FuaXRpemUiLCJMaW5rIiwidXJsIiwiX3Nhbml0aXplIiwiUFJPVE9DT0xfV0hJVEVMSVNUIiwiU0FOSVRJWkVEX1VSTCIsInByb3RvY29scyIsImFuY2hvciIsImhyZWYiLCJwcm90b2NvbCIsIl9rZXlib2FyZCIsIl9rZXlib2FyZDIiLCJfZHJvcGRvd24iLCJfZHJvcGRvd24yIiwib3B0aW9uc0NvdW50ZXIiLCJ0b2dnbGVBcmlhQXR0cmlidXRlIiwiZWxlbWVudCIsIlBpY2tlciIsInNlbGVjdCIsImJ1aWxkUGlja2VyIiwic3R5bGUiLCJkaXNwbGF5IiwibGFiZWwiLCJ0b2dnbGVQaWNrZXIiLCJlc2NhcGUiLCJidWlsZEl0ZW0iLCJvcHRpb24iLCJ0YWJJbmRleCIsImhhc0F0dHJpYnV0ZSIsInNlbGVjdEl0ZW0iLCJidWlsZExhYmVsIiwiYnVpbGRPcHRpb25zIiwiaWQiLCJzZWxlY3RlZCIsImNsb3NlIiwidHJpZ2dlciIsInNlbGVjdGVkSW5kZXgiLCJFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImlzQWN0aXZlIiwiX2VtYmVkIiwiX2VtYmVkMiIsIl9zY3JvbGwiLCJfc2Nyb2xsMiIsIl9jbGlwYm9hcmQiLCJfY2xpcGJvYXJkMiIsIl9oaXN0b3J5IiwiX2hpc3RvcnkyIiwiU2hhZG93QmxvdCIsImNsb25lTm9kZSIsInBhcmVudEJsb3QiLCJyZWZEb21Ob2RlIiwiQXR0cmlidXRvclN0b3JlIiwic3R5bGVzIiwiYXR0ciIsIkNsYXNzQXR0cmlidXRvciIsIm1hdGNoZXMiLCJyZXN1bHQiLCJjYW1lbGl6ZSIsInBhcnRzIiwicGFydCIsIlN0eWxlQXR0cmlidXRvciIsIlRoZW1lIiwidGhlbWVzIiwiR1VBUkRfVEVYVCIsImNvbnRlbnROb2RlIiwiY2hpbGROb2RlIiwibGVmdEd1YXJkIiwicmlnaHRHdWFyZCIsInByZXZMZW5ndGgiLCJBbGlnblN0eWxlIiwiQWxpZ25DbGFzcyIsIkFsaWduQXR0cmlidXRlIiwiQmFja2dyb3VuZFN0eWxlIiwiQmFja2dyb3VuZENsYXNzIiwiX2NvbG9yIiwiRGlyZWN0aW9uU3R5bGUiLCJEaXJlY3Rpb25DbGFzcyIsIkRpcmVjdGlvbkF0dHJpYnV0ZSIsIkZvbnRDbGFzcyIsIkZvbnRTdHlsZSIsIkZvbnRTdHlsZUF0dHJpYnV0b3IiLCJTaXplU3R5bGUiLCJTaXplQ2xhc3MiLCJnZXRMYXN0Q2hhbmdlSW5kZXgiLCJIaXN0b3J5IiwibGFzdFJlY29yZGVkIiwiaWdub3JlQ2hhbmdlIiwidXNlck9ubHkiLCJyZWNvcmQiLCJ1bmRvIiwicmVkbyIsImRlc3QiLCJzdGFjayIsImNoYW5nZURlbHRhIiwidW5kb0RlbHRhIiwidGltZXN0YW1wIiwibm93IiwiZGVsYXkiLCJtYXhTdGFjayIsImVuZHNXaXRoTmV3bGluZUNoYW5nZSIsImRlbGV0ZUxlbmd0aCIsImNoYW5nZUluZGV4IiwiQmFzZVRvb2x0aXAiLCJfY29sb3JQaWNrZXIiLCJfY29sb3JQaWNrZXIyIiwiX2ljb25QaWNrZXIiLCJfaWNvblBpY2tlcjIiLCJfcGlja2VyIiwiX3BpY2tlcjIiLCJfdG9vbHRpcCIsIl90b29sdGlwMiIsIkFMSUdOUyIsIkNPTE9SUyIsIkZPTlRTIiwiSEVBREVSUyIsIlNJWkVTIiwiQmFzZVRoZW1lIiwiX1RoZW1lIiwibGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidG9vbHRpcCIsInRleHRib3giLCJoaWRlIiwicGlja2VycyIsInBpY2tlciIsImV4dGVuZFRvb2xiYXIiLCJidWlsZEJ1dHRvbnMiLCJidXR0b25zIiwiaWNvbnMiLCJidXR0b24iLCJidWlsZFBpY2tlcnMiLCJzZWxlY3RzIiwiZmlsbFNlbGVjdCIsImFsaWduIiwiaGFuZGxlcnMiLCJmb3JtdWxhIiwiZWRpdCIsImZpbGVJbnB1dCIsImZpbGVzIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsInJlYWRBc0RhdGFVUkwiLCJjbGljayIsInZpZGVvIiwiX1Rvb2x0aXAiLCJib3VuZHNDb250YWluZXIiLCJzYXZlIiwiY2FuY2VsIiwibW9kZSIsInByZXZpZXciLCJyZXN0b3JlRm9jdXMiLCJsaW5rUmFuZ2UiLCJleHRyYWN0VmlkZW9VcmwiLCJkZWZhdWx0VmFsdWUiLCJMaW5rZWRMaXN0IiwiYXBwZW5kIiwibm9kZXMiLCJjdXIiLCJjdXJOb2RlIiwiY2FsbGJhY2siLCJjdXJJbmRleCIsImN1ckxlbmd0aCIsIk9CU0VSVkVSX0NPTkZJRyIsImNoYXJhY3RlckRhdGEiLCJjaGFyYWN0ZXJEYXRhT2xkVmFsdWUiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiTUFYX09QVElNSVpFX0lURVJBVElPTlMiLCJTY3JvbGxCbG90IiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwicmVjb3JkcyIsIm1hcmsiLCJtYXJrUGFyZW50IiwicmVtYWluaW5nIiwicHJldmlvdXNTaWJsaW5nIiwiZ3JhbmRDaGlsZCIsImlzRXF1YWwiLCJvYmoxIiwib2JqMiIsInByb3AiLCJJbmxpbmVCbG90IiwiQmxvY2tCbG90IiwiRW1iZWRCbG90Iiwic3BsaXRUZXh0IiwiX3RvZ2dsZSIsIkRPTVRva2VuTGlzdCIsInRva2VuIiwic2VhcmNoU3RyaW5nIiwic3ViamVjdFN0cmluZyIsImlzRmluaXRlIiwiZmxvb3IiLCJ0aGlzQXJnIiwiZXhlY0NvbW1hbmQiLCJESUZGX0RFTEVURSIsIkRJRkZfSU5TRVJUIiwiRElGRl9FUVVBTCIsImRpZmZfbWFpbiIsInRleHQxIiwidGV4dDIiLCJjdXJzb3JfcG9zIiwiY29tbW9ubGVuZ3RoIiwiZGlmZl9jb21tb25QcmVmaXgiLCJjb21tb25wcmVmaXgiLCJzdWJzdHJpbmciLCJkaWZmX2NvbW1vblN1ZmZpeCIsImNvbW1vbnN1ZmZpeCIsImRpZmZzIiwiZGlmZl9jb21wdXRlXyIsImRpZmZfY2xlYW51cE1lcmdlIiwiZml4X2N1cnNvciIsImZpeF9lbW9qaSIsImxvbmd0ZXh0Iiwic2hvcnR0ZXh0IiwiaG0iLCJkaWZmX2hhbGZNYXRjaF8iLCJ0ZXh0MV9hIiwidGV4dDFfYiIsInRleHQyX2EiLCJ0ZXh0Ml9iIiwibWlkX2NvbW1vbiIsImRpZmZzX2EiLCJkaWZmc19iIiwiZGlmZl9iaXNlY3RfIiwidGV4dDFfbGVuZ3RoIiwidGV4dDJfbGVuZ3RoIiwibWF4X2QiLCJjZWlsIiwidl9vZmZzZXQiLCJ2X2xlbmd0aCIsInYxIiwidjIiLCJmcm9udCIsImsxc3RhcnQiLCJrMWVuZCIsImsyc3RhcnQiLCJrMmVuZCIsImsxIiwiazFfb2Zmc2V0IiwieDEiLCJ5MSIsImNoYXJBdCIsImsyX29mZnNldCIsIngyIiwiZGlmZl9iaXNlY3RTcGxpdF8iLCJrMiIsInkyIiwieSIsInRleHQxYSIsInRleHQyYSIsInRleHQxYiIsInRleHQyYiIsImRpZmZzYiIsInBvaW50ZXJtaW4iLCJwb2ludGVybWF4IiwicG9pbnRlcm1pZCIsInBvaW50ZXJzdGFydCIsInBvaW50ZXJlbmQiLCJkaWZmX2hhbGZNYXRjaElfIiwic2VlZCIsImoiLCJiZXN0X2NvbW1vbiIsImJlc3RfbG9uZ3RleHRfYSIsImJlc3RfbG9uZ3RleHRfYiIsImJlc3Rfc2hvcnR0ZXh0X2EiLCJiZXN0X3Nob3J0dGV4dF9iIiwicHJlZml4TGVuZ3RoIiwiaG0xIiwiaG0yIiwicG9pbnRlciIsImNvdW50X2RlbGV0ZSIsImNvdW50X2luc2VydCIsInRleHRfZGVsZXRlIiwidGV4dF9pbnNlcnQiLCJjaGFuZ2VzIiwiY3Vyc29yX25vcm1hbGl6ZV9kaWZmIiwiY3VycmVudF9wb3MiLCJuZXh0X3BvcyIsInNwbGl0X3BvcyIsImRfbGVmdCIsImRfcmlnaHQiLCJub3JtIiwibmRpZmZzIiwiY3Vyc29yX3BvaW50ZXIiLCJkX25leHQiLCJtZXJnZV90dXBsZXMiLCJjb21wYWN0Iiwic3RhcnRzX3dpdGhfcGFpcl9lbmQiLCJzdHIiLCJlbmRzX3dpdGhfcGFpcl9zdGFydCIsImZpeGVkX2RpZmZzIiwibGVmdF9kIiwicmlnaHRfZCIsInNoaW0iLCJzdXBwb3J0c0FyZ3VtZW50c0NsYXNzIiwic3VwcG9ydGVkIiwidW5zdXBwb3J0ZWQiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImhhcyIsIkV2ZW50cyIsIkVFIiwiZm4iLCJFdmVudEVtaXR0ZXIiLCJfZXZlbnRzIiwiX2V2ZW50c0NvdW50IiwiZXZlbnROYW1lcyIsImV4aXN0cyIsImF2YWlsYWJsZSIsImVlIiwiYTEiLCJhMiIsImEzIiwiYTQiLCJhNSIsImxlbiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiYWRkTGlzdGVuZXIiLCJzZXRNYXhMaXN0ZW5lcnMiLCJwcmVmaXhlZCIsIm1hdGNoVGV4dCIsIm1hdGNoU3BhY2luZyIsIm1hdGNoTmV3bGluZSIsIm1hdGNoQmxvdCIsIm1hdGNoQXR0cmlidXRvciIsIl9leHRlbmQzIiwiX2FsaWduIiwiX2JhY2tncm91bmQiLCJfZGlyZWN0aW9uIiwiX2ZvbnQiLCJfc2l6ZSIsIkRPTV9LRVkiLCJDTElQQk9BUkRfQ09ORklHIiwibWF0Y2hCcmVhayIsIkVMRU1FTlRfTk9ERSIsIm1hdGNoU3R5bGVzIiwibWF0Y2hJbmRlbnQiLCJtYXRjaEFsaWFzIiwibWF0Y2hJZ25vcmUiLCJBVFRSSUJVVEVfQVRUUklCVVRPUlMiLCJTVFlMRV9BVFRSSUJVVE9SUyIsIkNsaXBib2FyZCIsIm9uUGFzdGUiLCJtYXRjaGVycyIsInNlbGVjdG9yIiwibWF0Y2hlciIsIm1hdGNoVmlzdWFsIiwiYWRkTWF0Y2hlciIsImlubmVyVGV4dCIsIl9wcmVwYXJlTWF0Y2hpbmciLCJwcmVwYXJlTWF0Y2hpbmciLCJfcHJlcGFyZU1hdGNoaW5nMiIsImVsZW1lbnRNYXRjaGVycyIsInRleHRNYXRjaGVycyIsInRyYXZlcnNlIiwiZGVsdGFFbmRzV2l0aCIsInBhc3RlIiwicGFpciIsIl9wYWlyIiwiYXBwbHlGb3JtYXQiLCJjb21wdXRlU3R5bGUiLCJub2RlVHlwZSIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJlbmRUZXh0IiwiY2hpbGRyZW5EZWx0YSIsIm5leHRFbGVtZW50U2libGluZyIsIm5vZGVIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJwYXJzZUZsb2F0IiwibWFyZ2luVG9wIiwibWFyZ2luQm90dG9tIiwib2Zmc2V0VG9wIiwiZm9udFN0eWxlIiwiaXRhbGljIiwiZm9udFdlaWdodCIsImJvbGQiLCJ0ZXh0SW5kZW50Iiwid2hpdGVTcGFjZSIsInJlcGxhY2VyIiwiY29sbGFwc2UiLCJCb2xkIiwiYWRkQ29udHJvbHMiLCJUb29sYmFyIiwiX3JldCIsImNvbnRyb2xzIiwiYWRkSGFuZGxlciIsIl90aGlzJHF1aWxsJHNlbGVjdGlvbiIsIl90aGlzJHF1aWxsJHNlbGVjdGlvbjIiLCJfcXVpbGwkc2VsZWN0aW9uJGdldFIiLCJfcXVpbGwkc2VsZWN0aW9uJGdldFIyIiwicHJvbXB0IiwiYWRkQnV0dG9uIiwiZ3JvdXBzIiwiZ3JvdXAiLCJjb250cm9sIiwiYWRkU2VsZWN0IiwiY2xlYW4iLCJkaXJlY3Rpb24iLCJsaW5rIiwiQ29sb3JQaWNrZXIiLCJfUGlja2VyIiwiYmFja2dyb3VuZENvbG9yIiwiY29sb3JMYWJlbCIsInN0cm9rZSIsImZpbGwiLCJJY29uUGlja2VyIiwiZGVmYXVsdEl0ZW0iLCJUb29sdGlwIiwiVEVNUExBVEUiLCJyZWZlcmVuY2UiLCJvZmZzZXRXaWR0aCIsInJvb3RCb3VuZHMiLCJ2ZXJ0aWNhbFNoaWZ0Iiwic2hvdyIsIl9iYXNlIiwiX2Jhc2UyIiwiX2xpbmsiLCJfbGluazIiLCJfaWNvbnMiLCJfaWNvbnMyIiwiVE9PTEJBUl9DT05GSUciLCJTbm93VGhlbWUiLCJfQmFzZVRoZW1lIiwiU25vd1Rvb2x0aXAiLCJfQmFzZVRvb2x0aXAiLCJfY29yZSIsIl9jb3JlMiIsIl9pbmRlbnQiLCJfYmxvY2txdW90ZSIsIl9ibG9ja3F1b3RlMiIsIl9oZWFkZXIiLCJfaGVhZGVyMiIsIl9saXN0IiwiX2xpc3QyIiwiX2JvbGQiLCJfYm9sZDIiLCJfaXRhbGljIiwiX2l0YWxpYzIiLCJfc2NyaXB0IiwiX3NjcmlwdDIiLCJfc3RyaWtlIiwiX3N0cmlrZTIiLCJfdW5kZXJsaW5lIiwiX3VuZGVybGluZTIiLCJfaW1hZ2UiLCJfaW1hZ2UyIiwiX3ZpZGVvIiwiX3ZpZGVvMiIsIl9mb3JtdWxhIiwiX2Zvcm11bGEyIiwiX3N5bnRheCIsIl9zeW50YXgyIiwiX3Rvb2xiYXIiLCJfdG9vbGJhcjIiLCJfYnViYmxlIiwiX2J1YmJsZTIiLCJfc25vdyIsIl9zbm93MiIsIkluZGVudENsYXNzIiwiTGlzdEl0ZW0iLCJJZGVudEF0dHJpYnV0b3IiLCJCbG9ja3F1b3RlIiwiSGVhZGVyIiwiTGlzdCIsIl9Db250YWluZXIiLCJsaXN0RXZlbnRIYW5kbGVyIiwiSXRhbGljIiwiX0JvbGQiLCJTY3JpcHQiLCJTdHJpa2UiLCJVbmRlcmxpbmUiLCJBVFRSSUJVVEVTIiwiSW1hZ2UiLCJWaWRlbyIsIl9CbG9ja0VtYmVkIiwiRm9ybXVsYUJsb3QiLCJfRW1iZWQiLCJrYXRleCIsInJlbmRlciIsInRocm93T25FcnJvciIsImVycm9yQ29sb3IiLCJGb3JtdWxhIiwiQ29kZVRva2VuIiwiU3ludGF4Q29kZUJsb2NrIiwiX0NvZGVCbG9jayIsImhpZ2hsaWdodCIsIl9oaWdobGlnaHQiLCJjYWNoZWRUZXh0IiwiU3ludGF4IiwidGltZXIiLCJjbGVhclRpbWVvdXQiLCJpbnRlcnZhbCIsImNvZGUiLCJobGpzIiwiaGlnaGxpZ2h0QXV0byIsIkJ1YmJsZVRvb2x0aXAiLCJCdWJibGVUaGVtZSIsImxhc3RMaW5lIiwiX2JvdW5kcyIsImFycm93IiwibWFyZ2luTGVmdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/quill/dist/quill.js\n");

/***/ })

};
;